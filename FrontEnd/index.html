<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>æ­å­è®¡åˆ’</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #87CEEB; 
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif; 
            user-select: none; -webkit-user-select: none;
        }

        /* --- å·¦ä¸Šè§’ï¼šæ—¥ç¨‹ä¸å¤©æ°” (é«˜é€æ˜ç£¨ç ‚) --- */
        #sidebar {
            position: absolute; top: 20px; left: 20px; width: 240px;
            display: flex; flex-direction: column; gap: 10px; z-index: 10;
            pointer-events: none; /* å®¹å™¨ç©¿é€ */
        }

        .glass-panel {
            /* æé«˜é€æ˜åº¦ */
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px; padding: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            pointer-events: auto; transition: transform 0.2s, background 0.3s;
            color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .glass-panel:hover { transform: translateY(-2px); background: rgba(255, 255, 255, 0.35); }

        /* å¤©æ°”æ  */
        .weather-row { display: flex; justify-content: space-around; font-size: 18px; }
        .weather-icon { cursor: pointer; opacity: 0.6; transition: 0.3s; }
        .weather-icon:hover, .weather-icon.active { opacity: 1; transform: scale(1.2); text-shadow: 0 0 10px yellow; }

        /* æ—¥ç¨‹åˆ—è¡¨ */
        .panel-header { font-size: 13px; font-weight: 800; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 4px; display: flex; justify-content: space-between;}
        #schedule-list { list-style: none; padding: 0; margin: 0; max-height: 200px; overflow-y: auto; }
        #schedule-list::-webkit-scrollbar { display: none; }
        #schedule-list li { 
            font-size: 11px; color: #fff; margin-bottom: 5px; padding: 6px; 
            background: rgba(0,0,0,0.2); border-radius: 8px; 
            border-left: 3px solid #81D4FA; display: flex; flex-direction: column;
            position: relative; animation: slideIn 0.3s ease;
        }
        .time-badge { font-weight: bold; color: #81D4FA; font-size: 10px; margin-bottom: 2px; }
        .del-btn { position: absolute; right: 5px; top: 5px; color: rgba(255,255,255,0.6); cursor: pointer; font-size: 10px; }
        .del-btn:hover { color: #FF5252; }

        /* --- åº•éƒ¨ï¼šç”Ÿæˆå¼å¯¹è¯ UI --- */
        #chat-layer {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 500px;
            display: flex; flex-direction: column; justify-content: flex-end;
            gap: 10px; z-index: 20; pointer-events: none;
        }

        /* èŠå¤©æµ (æç®€é€æ˜) */
        #chat-history {
            display: flex; flex-direction: column; gap: 8px; 
            margin-bottom: 10px; padding-right: 5px;
            align-items: center; /* å±…ä¸­æ˜¾ç¤º */
        }
        
        .msg {
            max-width: 90%; padding: 8px 16px; border-radius: 20px; font-size: 13px; line-height: 1.5;
            backdrop-filter: blur(4px); pointer-events: auto; 
            animation: slideUp 0.4s ease;
            text-align: center;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            transition: opacity 1s, transform 1s; /* æ·¡å‡ºåŠ¨ç”» */
        }
        
        .msg-user { background: rgba(33, 150, 243, 0.4); color: white; border: 1px solid rgba(255,255,255,0.2); }
        .msg-ai { background: rgba(255, 255, 255, 0.25); color: white; border: 1px solid rgba(255,255,255,0.3); }
        
        /* æ­£åœ¨æ¶ˆå¤±çš„ç±» */
        .fading-out { opacity: 0; transform: translateY(-10px) scale(0.9); }

        /* ç”Ÿæˆå¼å¡ç‰‡å®¹å™¨ */
        #card-deck {
            display: flex; gap: 10px; overflow-x: auto; padding: 5px; pointer-events: auto;
            justify-content: center; min-height: 5px;
        }
        #card-deck::-webkit-scrollbar { display: none; }

        .activity-card {
            min-width: 140px; 
            background: rgba(255,255,255,0.2); backdrop-filter: blur(10px);
            border-radius: 12px; padding: 10px; border: 1px solid rgba(255,255,255,0.4);
            display: flex; flex-direction: column; gap: 4px;
            cursor: pointer; transition: 0.2s; animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .activity-card:hover { transform: translateY(-5px); background: rgba(255,255,255,0.4); }
        .act-time { font-size: 10px; color: #FFD54F; font-weight: bold; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 4px; align-self: flex-start;}
        .act-title { font-size: 13px; font-weight: bold; }
        .act-desc { font-size: 11px; opacity: 0.9; }
        .act-add { 
            margin-top: 5px; background: rgba(76, 175, 80, 0.6); color: white; border: 1px solid rgba(255,255,255,0.3); 
            padding: 4px; border-radius: 6px; font-size: 11px; cursor: pointer; text-align: center;
            transition: 0.2s;
        }
        .act-add:hover { background: rgba(76, 175, 80, 0.9); }

        /* è¾“å…¥æ¡† (æé€æ˜) */
        .input-box {
            background: rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px);
            border-radius: 25px; padding: 5px 5px 5px 15px;
            display: flex; align-items: center; pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.2);
        }
        input { 
            flex: 1; border: none; background: transparent; outline: none; font-size: 14px; color: white; 
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        input::placeholder { color: rgba(255,255,255,0.6); }
        .btn-send {
            width: 36px; height: 36px; border-radius: 50%; border: none;
            background: rgba(255, 255, 255, 0.2); color: white; font-size: 16px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: 0.2s;
        }
        .btn-send:hover { transform: scale(1.1); background: rgba(255, 255, 255, 0.4); }
        .btn-send.loading { animation: spin 1s infinite linear; content: 'â³'; }

        @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes popIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* è­¦å‘Šå¼¹çª— */
        .toast {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            color: white; padding: 10px 20px; border-radius: 8px;
            font-size: 14px; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 200;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.35);
            backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 300;
        }
        .modal-content {
            width: 90%; max-width: 360px; border-radius: 16px; padding: 16px;
            background: rgba(255,255,255,0.25); color: white; border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .modal-title { font-size: 16px; font-weight: 800; }
        .modal-close { cursor: pointer; font-size: 18px; opacity: 0.8; }
        .modal-close:hover { opacity: 1; }
        .modal-time { font-size: 12px; color: #FFD54F; margin-bottom: 6px; }
        .modal-desc { font-size: 12px; opacity: 0.9; }
        .modal-actions { display: flex; gap: 8px; margin-top: 12px; }
        .btn-primary { flex: 1; text-align: center; padding: 8px; border-radius: 10px; cursor: pointer; background: rgba(76,175,80,0.7); border: 1px solid rgba(255,255,255,0.3); }
        .btn-primary:hover { background: rgba(76,175,80,0.9); }
        .btn-secondary { flex: 1; text-align: center; padding: 8px; border-radius: 10px; cursor: pointer; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); }
        .btn-secondary:hover { background: rgba(255,255,255,0.35); }

        /* --- å® ç‰©é€‰æ‹©å™¨ --- */
        #pet-selector {
            position: absolute; top: 20px; right: 20px;
            display: flex; gap: 10px; z-index: 100;
        }
        .pet-option {
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(255,255,255,0.3); border: 2px solid rgba(255,255,255,0.5);
            backdrop-filter: blur(4px); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; transition: 0.3s; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .pet-option:hover, .pet-option.active {
            background: rgba(255,255,255,0.8); transform: scale(1.1); border-color: #fff;
        }

        /* --- å® ç‰©çŠ¶æ€é¢æ¿ (New) --- */
    #pet-status-panel {
        position: absolute; top: 20px; left: 270px; /* ä½äºå·¦ä¾§è¾¹æ å³ä¾§ */
        width: 200px; z-index: 10;
        display: flex; flex-direction: column; gap: 8px;
    }
    .status-bar-row {
        display: flex; align-items: center; gap: 8px; font-size: 12px; color: #fff;
    }
    .status-label { width: 40px; text-align: right; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
    .progress-bg {
        flex: 1; height: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;
        border: 1px solid rgba(255,255,255,0.2);
    }
    .progress-fill { height: 100%; transition: width 0.5s, background-color 0.5s; }
    
    /* äº¤äº’æŒ‰é’®ç»„ */
    #interaction-panel {
        position: absolute; bottom: 180px; right: 20px;
        display: flex; flex-direction: column; gap: 10px; z-index: 50;
    }
    .interact-btn {
        width: 50px; height: 50px; border-radius: 50%;
        background: rgba(255,255,255,0.3); backdrop-filter: blur(5px);
        border: 2px solid rgba(255,255,255,0.6);
        font-size: 24px; cursor: pointer;
        display: flex; align-items: center; justify-content: center;
        transition: 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    .interact-btn:hover { transform: scale(1.1); background: rgba(255,255,255,0.8); }
    .interact-btn:active { transform: scale(0.95); }
    /* å® ç‰©æƒ³æ³•æ°”æ³¡ (ä½äºå¤©ç©ºä¸­å¤®) */
    #pet-thoughts {
        position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
        z-index: 80; pointer-events: none;
        display: flex; flex-direction: column; align-items: center;
        opacity: 0; transition: opacity 0.5s;
    }
    .thought-bubble {
        background: rgba(255, 255, 255, 0.9); padding: 10px 20px;
        border-radius: 20px; font-size: 14px; color: #333;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        position: relative;
    }
    .thought-bubble::after {
        content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
        border-width: 8px 8px 0; border-style: solid;
        border-color: rgba(255, 255, 255, 0.9) transparent transparent transparent;
    }
    </style>
</head>
<body oncontextmenu="return false;">

<!-- è­¦å‘Š/æç¤ºå¼¹çª— -->
<div id="login-modal" class="modal-overlay" style="display:flex; z-index: 1000;">
    <div class="modal-content" style="text-align:center; width: 340px;">
        <h2 id="auth-title" style="margin-bottom:10px;">æ¬¢è¿æ¥åˆ°ç–—æ„ˆç©ºé—´</h2>
        <p id="auth-subtitle" style="margin-bottom: 20px; font-size: 13px; opacity: 0.8;">è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç å¼€å¯æ‚¨çš„ä¸“å±æ—…ç¨‹</p>
        
        <input type="email" id="login-email" placeholder="your@email.com" list="email-history" style="width:85%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.5); background:rgba(255,255,255,0.2); color:white; margin-bottom:10px; outline:none;">
        <datalist id="email-history"></datalist>

        <input type="password" id="login-pass" placeholder="Password" style="width:85%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.5); background:rgba(255,255,255,0.2); color:white; margin-bottom:20px; outline:none;">
        
        <div class="btn-primary" id="btn-auth" onclick="handleAuth()" style="margin: 0 auto; width: 120px; margin-bottom: 15px;">è¿›å…¥ç©ºé—´</div>
        
        <div style="font-size: 12px; opacity: 0.9;">
            <span id="toggle-text">è¿˜æ²¡æœ‰è´¦å·ï¼Ÿ</span>
            <span id="toggle-btn" onclick="toggleAuthMode()" style="text-decoration: underline; cursor: pointer; font-weight: bold; color: #E0F2F1;">ç«‹å³æ³¨å†Œ</span>
        </div>
    </div>
</div>

<div id="message-modal" class="modal-overlay" style="z-index: 500;">
    <div class="modal-content" style="text-align: center;">
        <div class="modal-header" style="justify-content: center;">
            <div id="msg-title" class="modal-title">æç¤º</div>
            <div class="modal-close" style="position: absolute; right: 20px;" onclick="closeMessageModal()">Ã—</div>
        </div>
        <div id="msg-content" class="modal-desc" style="font-size: 14px; margin: 15px 0;">å†…å®¹</div>
        <div class="btn-primary" onclick="closeMessageModal()" style="margin: 0 auto; width: 100px;">ç¡®å®š</div>
    </div>
</div>

<!-- å® ç‰©é€‰æ‹©å™¨ -->
<div id="pet-selector">
    <div class="pet-option active" onclick="selectPet('corgi')" title="æŸ¯åŸº">ğŸ¶</div>
    <div class="pet-option" onclick="selectPet('rabbit')" title="å°ç™½å…”">ğŸ°</div>
    <div class="pet-option" onclick="selectPet('cat')" title="å°èŠ±çŒ«">ğŸ±</div>
</div>

<!-- å® ç‰©çŠ¶æ€é¢æ¿ -->
<div id="pet-status-panel">
    <div class="status-bar-row">
        <div class="status-label">å¿ƒæƒ…</div>
        <div class="progress-bg"><div id="bar-mood" class="progress-fill" style="width: 80%; background: #FFB74D;"></div></div>
    </div>
    <div class="status-bar-row">
        <div class="status-label">å¥åº·</div>
        <div class="progress-bg"><div id="bar-health" class="progress-fill" style="width: 90%; background: #81C784;"></div></div>
    </div>
    <div class="status-bar-row">
        <div class="status-label">é“ä¸½</div>
        <div class="progress-bg"><div id="bar-gloss" class="progress-fill" style="width: 70%; background: #64B5F6;"></div></div>
    </div>
</div>

<!-- äº¤äº’æŒ‰é’®ç»„ -->
<div id="interaction-panel">
    <div class="interact-btn" onclick="interact('feed')" title="å–‚é£Ÿ">ğŸ–</div>
    <div class="interact-btn" onclick="interact('groom')" title="æ¢³æ¯›">ğŸ§¶</div>
    <div class="interact-btn" onclick="interact('play')" title="ç©è€">ğŸ¥</div>
</div>

<!-- å® ç‰©æƒ³æ³•æ°”æ³¡ (ä½äºèŠå¤©çª—å£ä¸Šæ–¹) -->
<div id="pet-thoughts">
    <div id="thought-text" class="thought-bubble">...</div>
</div>

<!-- å·¦ä¾§è¾¹æ  -->
<div id="sidebar">
    <!-- å¤©æ°”æ§åˆ¶ (Removed per user request) -->
    <!-- <div class="glass-panel weather-row"> ... </div> -->

    <!-- æ—¥ç¨‹è¡¨ -->
    <div class="glass-panel">
        <div class="panel-header">
            <span>ğŸ“… æ­å­è®¡åˆ’</span>
            <span style="font-weight:normal; font-size:10px; opacity:0.8" id="task-count">0/5</span>
        </div>
        <div id="empty-hint" style="font-size:11px; opacity:0.7; text-align:center; padding:10px;">å‘Šè¯‰æˆ‘ä½ çš„å¿ƒæƒ…...</div>
        <ul id="schedule-list"></ul>
    </div>
</div>

<!-- åº•éƒ¨ç”Ÿæˆå¼ UI -->
<div id="chat-layer">
    <div id="chat-history">
        <!-- æ¶ˆæ¯ä¼šåœ¨è¿™é‡Œç”Ÿæˆï¼Œå¹¶è‡ªåŠ¨æ¶ˆå¤± -->
        <div class="msg msg-ai" id="intro-msg">å—¨ï¼æˆ‘æ˜¯ä½ çš„ç–—æ„ˆå°ç‹—ã€‚ä»Šå¤©æ„Ÿè§‰æ€ä¹ˆæ ·ï¼Ÿ</div>
    </div>
    
    <!-- åŠ¨æ€ç”Ÿæˆçš„å¡ç‰‡æµ -->
    <div id="card-deck"></div>

    <div class="input-box">
        <input type="text" id="user-input" placeholder="è¾“å…¥æƒ³æ³• (å¦‚: æœ‰ç‚¹ç´¯)..." autocomplete="off">
        <button class="btn-send" onclick="sendMessage()">â¤</button>
    </div>
</div>

<div id="activity-modal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <div id="modal-title" class="modal-title"></div>
            <div class="modal-close" onclick="closeActivityModal()">Ã—</div>
        </div>
        <div id="modal-time" class="modal-time"></div>
        <div id="modal-desc" class="modal-desc"></div>
        <div class="modal-actions">
            <div id="modal-add" class="btn-primary">æ·»åŠ åˆ°æ—¥ç¨‹</div>
            <div class="btn-secondary" onclick="closeActivityModal()">ç¨å</div>
        </div>
    </div>
</div>

<script>
    (function(){
        function loadScript(src){
            return new Promise(function(resolve){
                var s=document.createElement('script');
                s.src=src; s.async=true;
                s.onload=function(){ resolve(true); };
                s.onerror=function(){ resolve(false); };
                document.head.appendChild(s);
            });
        }
        async function ensureThree(){
            if(window.THREE) return true;
            let loaded=false;
            // Prefer local first (no HEAD probing to avoid abort logs)
            if(await loadScript('./lib/three.min.js')){ loaded=!!window.THREE; }
            if(!loaded){
                const threeCDNs = [
                    'https://unpkg.com/three@0.128.0/build/three.min.js',
                    'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js'
                ];
                for(let src of threeCDNs){
                    const ok = await loadScript(src);
                    if(ok && window.THREE){ loaded=true; break; }
                }
            }
            if(!loaded){ console.warn('Three.js not loaded, running in text-only mode'); return false; }
            let ctrlLoaded=false;
            if(await loadScript('./lib/OrbitControls.js')){ ctrlLoaded=!!THREE.OrbitControls; }
            if(!ctrlLoaded){
                const ctrlCDNs = [
                    'https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js',
                    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js'
                ];
                for(let src of ctrlCDNs){
                    const ok = await loadScript(src);
                    if(ok && THREE.OrbitControls){ ctrlLoaded=true; break; }
                }
            }
            return loaded && ctrlLoaded;
        }
        window.__ensureThree = ensureThree;
    })();
</script>

<script>
    if(!window.THREE){
        try{ document.getElementById('intro-msg').innerText = 'ä¸‰ç»´åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'; }catch(e){}
    }
    // è‡ªåŠ¨æ¸…ç†åˆå§‹æ¶ˆæ¯
    setTimeout(() => {
        const intro = document.getElementById('intro-msg');
        if(intro) {
            intro.classList.add('fading-out');
            setTimeout(() => intro.remove(), 1000);
        }
    }, 5000);

    // ==========================================
    // 1. é€»è¾‘æ ¸å¿ƒ (æ—¥ç¨‹ & Gemini API)
    // ==========================================
    
    // --- æ—¥ç¨‹ç®¡ç† ---
    const schedule = []; 

    function timeToMin(timeStr) {
        const [h, m] = timeStr.split(':').map(Number);
        return h * 60 + m;
    }

    function checkConflict(newStart, newEnd) {
        for (let item of schedule) {
            if (newStart < item.end && newEnd > item.start) {
                return true;
            }
        }
        return false;
    }

    function addScheduleItem(title, timeStr, type) {
        const times = timeStr.split('-');
        if (times.length !== 2) return;
        
        const startMin = timeToMin(times[0]);
        const endMin = timeToMin(times[1]);

        if (checkConflict(startMin, endMin)) {
            showToast(`âš ï¸ å†²çªï¼æ—¶æ®µ ${timeStr} å·²å ç”¨`);
            return false;
        }

        schedule.push({ title, start: startMin, end: endMin, timeStr, type });
        schedule.sort((a, b) => a.start - b.start); 
        
        renderScheduleUI();
        showToast("âœ… å·²æ·»åŠ : " + title);
        
        // Do NOT clear cards here, per user request
        // document.getElementById('card-deck').innerHTML = '';
        
        return true;
    }

    // --- Pet Traits & Persistence ---
    function generatePetTraits() {
        return {
            bodyScale: 0.95 + Math.random() * 0.1,
            headScale: 0.9 + Math.random() * 0.2,
            earScale: 0.85 + Math.random() * 0.3,
            legLen: 0.9 + Math.random() * 0.2
        };
    }

    window.restorePet = function(config) {
        if(!config || !config.type) return;
        const allowed = ['corgi','rabbit','cat'];
        currentPet = allowed.includes(config.type) ? config.type : 'corgi';
        if(!window.THREE || !window.corgiGroup){
            window.pendingPetConfig = config;
            const btn = document.querySelector(`.pet-option[onclick="selectPet('${currentPet}')"]`);
            if(btn){
                document.querySelectorAll('.pet-option').forEach(el => el.classList.remove('active'));
                btn.classList.add('active');
            }
            return;
        }
        window.corgiGroup.userData.traits = config.traits || generatePetTraits();
        document.querySelectorAll('.pet-option').forEach(el => el.classList.remove('active'));
        const btn = document.querySelector(`.pet-option[onclick="selectPet('${currentPet}')"]`);
        if(btn) btn.classList.add('active');
        rebuildPet();
    }

    function rebuildPet() {
        if(!window.THREE || !window.corgiGroup) return;
        const type = currentPet;
        // Base Scale
        let baseScale = 1;
        if(type === 'corgi') baseScale = 0.7; // Slightly larger than cat (0.6)
        else baseScale = 0.6;

        // Apply body scale trait to the whole group for simplicity, 
        // or we can pass traits to create functions for more detail.
        // Let's pass traits to create functions implicitly via corgiGroup.userData.traits
        
        const traits = window.corgiGroup.userData.traits || generatePetTraits();
        window.corgiGroup.scale.setScalar(baseScale * traits.bodyScale);

        if(type === 'corgi' && window.createCorgi) window.createCorgi();
        else if(type === 'rabbit' && window.createRabbit) window.createRabbit();
        else if(type === 'cat' && window.createCat) window.createCat();
        else if(window.createCorgi) window.createCorgi();
        
        // Reset position
        window.corgiBody.position.set(0,0,0);
        window.corgiBody.rotation.set(0,0,0);
    }

    function removeScheduleItem(index) {
        schedule.splice(index, 1);
        renderScheduleUI();
    }

    function renderScheduleUI() {
        const list = document.getElementById('schedule-list');
        const empty = document.getElementById('empty-hint');
        const count = document.getElementById('task-count');
        
        list.innerHTML = '';
        if(schedule.length === 0) empty.style.display = 'block';
        else empty.style.display = 'none';

        schedule.forEach((item, index) => {
            const li = document.createElement('li');
            li.innerHTML = `
                <div class="time-badge">${item.timeStr}</div>
                <div>${item.title}</div>
                <span class="del-btn" onclick="removeScheduleItem(${index})">Ã—</span>
            `;
            list.appendChild(li);
        });
        count.innerText = `${schedule.length}/8`;
    }

    function showToast(msg, title="æç¤º") {
        const m = document.getElementById('message-modal');
        document.getElementById('msg-title').innerText = title;
        document.getElementById('msg-content').innerText = msg;
        m.style.display = 'flex';
    }
    
    function closeMessageModal() {
        document.getElementById('message-modal').style.display = 'none';
    }

    if(!window.petStatus){ window.petStatus = { mood: 80, health: 90, gloss: 75 }; }
    var petStatus = window.petStatus;
    if(typeof updateStatusUI !== 'function'){
        function updateStatusUI(){
            var m=document.getElementById('bar-mood'); if(m) m.style.width = window.petStatus.mood + '%';
            var h=document.getElementById('bar-health'); if(h) h.style.width = window.petStatus.health + '%';
            var g=document.getElementById('bar-gloss'); if(g) g.style.width = window.petStatus.gloss + '%';
        }
    }

    // --- Backend Integration ---
    const API_BASE = 'http://localhost:3000/api';
    let currentUser = null;

    // Auth Logic
    let isRegister = false;
    
    function toggleAuthMode() {
        isRegister = !isRegister;
        const title = document.getElementById('auth-title');
        const sub = document.getElementById('auth-subtitle');
        const btn = document.getElementById('btn-auth');
        const txt = document.getElementById('toggle-text');
        const tBtn = document.getElementById('toggle-btn');
        
        if(isRegister) {
            title.innerText = "æ³¨å†Œæ–°è´¦å·";
            sub.innerText = "åˆ›å»ºæ‚¨çš„ä¸“å±ç–—æ„ˆç©ºé—´";
            btn.innerText = "ç«‹å³æ³¨å†Œ";
            txt.innerText = "å·²æœ‰è´¦å·ï¼Ÿ";
            tBtn.innerText = "ç›´æ¥ç™»å½•";
        } else {
            title.innerText = "æ¬¢è¿æ¥åˆ°ç–—æ„ˆç©ºé—´";
            sub.innerText = "è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç å¼€å¯æ‚¨çš„ä¸“å±æ—…ç¨‹";
            btn.innerText = "è¿›å…¥ç©ºé—´";
            txt.innerText = "è¿˜æ²¡æœ‰è´¦å·ï¼Ÿ";
            tBtn.innerText = "ç«‹å³æ³¨å†Œ";
        }
    }

    function loadAuthHistory() {
        const history = JSON.parse(localStorage.getItem('auth_history') || '[]');
        const dl = document.getElementById('email-history');
        if(dl) {
            dl.innerHTML = '';
            history.forEach(email => {
                const op = document.createElement('option');
                op.value = email;
                dl.appendChild(op);
            });
            if(history.length > 0) {
                const input = document.getElementById('login-email');
                if(input) input.value = history[0];
            }
        }
    }
    setTimeout(loadAuthHistory, 500); // Wait for DOM

    if(!window.handleAuth){ window.handleAuth = function(){ alert('æ­£åœ¨åŠ è½½ï¼Œè¯·ç¨å€™'); }; }

    async function handleAuth() {
        const email = document.getElementById('login-email').value.trim();
        const password = document.getElementById('login-pass').value.trim();
        if(!email || !password) return alert('è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ');
        
        const endpoint = isRegister ? '/auth/register' : '/auth/login';

        try {
            const res = await fetch(`${API_BASE}${endpoint}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ email, password })
            });
            const data = await res.json();
            if(!res.ok) throw new Error(data.error || 'æ“ä½œå¤±è´¥');

            // Save history
            let history = JSON.parse(localStorage.getItem('auth_history') || '[]');
            history = history.filter(e => e !== email);
            history.unshift(email);
            if(history.length > 5) history.pop();
            localStorage.setItem('auth_history', JSON.stringify(history));

            currentUser = data.user;
            document.getElementById('login-modal').style.display = 'none';
            
            // Session Reset: Clear Chat & Mood
            document.getElementById('chat-history').innerHTML = ''; 
            addMessage(`æ¬¢è¿å›æ¥, ${currentUser.email}ã€‚ä»Šå¤©æƒ³èŠç‚¹ä»€ä¹ˆï¼Ÿ`, 'ai', false);
            showToast(`æ¬¢è¿å›æ¥, ${currentUser.email}`);

            // Reset Mood/Status to defaults for new session
            petStatus.mood = 80; 
            petStatus.health = 90;
            petStatus.gloss = 75;
            updateStatusUI();

            if(window.THREE && typeof restorePet==='function' && currentUser.petConfig){
                restorePet(currentUser.petConfig);
            } else if(window.THREE && typeof selectPet==='function'){
                selectPet('corgi');
            }

            if(currentUser.schedule) {
                schedule.length = 0;
                currentUser.schedule.forEach(s => schedule.push(s));
                renderScheduleUI();
            }

        } catch(e) {
            console.error(e);
            alert((isRegister ? 'æ³¨å†Œå¤±è´¥: ' : 'ç™»å½•å¤±è´¥: ') + e.message);
        }
    }

    async function loadChatHistory() {
        if(!currentUser) return;
        try {
            const res = await fetch(`${API_BASE}/chat/history?email=${currentUser.email}`);
            const chats = await res.json();
            const recent = chats.slice(-5); 
            document.getElementById('chat-history').innerHTML = ''; // Clear first
            recent.forEach(msg => {
                addMessage(msg.text, msg.sender === 'user' ? 'user' : 'ai', false);
            });
        } catch(e) { console.error(e); }
    }

    async function saveUserData(updates) {
        if(!currentUser) return;
        try {
            await fetch(`${API_BASE}/user/update`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ email: currentUser.email, updates })
            });
            currentUser = { ...currentUser, ...updates };
        } catch(e) { console.error("Save failed", e); }
    }

    function addMessage(text, type, autoFade=false) {
        const container = document.getElementById('chat-history');
        const div = document.createElement('div');
        div.className = `msg msg-${type}`;
        div.innerText = text;
        container.appendChild(div);

        // Keep only last 5 messages visible
        while(container.children.length > 5) {
            container.removeChild(container.firstChild);
        }
    }
    let currentPet = 'corgi';
    const PET_BEHAVIOR_TEXT = {
        corgi: { 
            idle: ["åˆ°å¤„é—»é—»...", "è¿½å°¾å·´...", "æ±ªï¼Ÿ"],
            click: ["(ç–¯ç‹‚æ‘‡å°¾å·´)", "æ±ªæ±ªï¼æŠ±æŠ±ï¼", "(åœ¨åœ°ä¸Šæ‰“æ»š)"],
            move: "å“’å“’å“’è·‘è¿‡å»ï¼"
        },
        rabbit: { 
            idle: ["åŠ¨åŠ¨è€³æœµ...", "æ¸…ç†æ¯›å‘...", "å‘å‘†..."],
            click: ["(æŠ–åŠ¨é¼»å­)", "å˜¤å˜¤...", "(å¾€ä½ æ€€é‡Œé’»)"],
            move: "è¹¦è¹¦è·³è·³ï¼"
        },
        cat: { 
            idle: ["èˆ”çˆªå­...", "ä¼¸æ‡’è…°...", "ç›¯ç€æŸå¤„..."],
            click: ["å–µ~ (å‘¼å™œå£°)", "åˆ«çƒ¦æˆ‘... (ä½†æ²¡èµ°å¼€)", "(è¹­è¹­ä½ çš„è…¿)"],
            move: "ä¼˜é›…åœ°èµ°å¼€..."
        }
    };

    const PET_PERSONALITY = {
        corgi: { type: "energetic", sniffChance: 0.016, probeChance: 0.012 }, 
        rabbit: { type: "timid", sniffChance: 0.01, probeChance: 0.01 }, 
        cat: { type: "arrogant", sniffChance: 0.012, probeChance: 0.016 } 
    };

    // --- æ¶ˆæ¯å¤„ç† ---
    async function sendMessage() {
        const input = document.getElementById('user-input');
        const btn = document.querySelector('.btn-send');
        const text = input.value.trim();
        if (!text) return;
        lastOwnerInteractionTime = Date.now() * 0.001;
        didWanderAfterOwnerIdle = false;

        // 1. æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
        addMessage(text, 'user');
        input.value = '';
        btn.classList.add('loading');
        btn.innerText = '';

        // 2. è°ƒç”¨ Backend AI
        try {
            let data;
            if (currentUser && API_BASE) {
                const res = await fetch(`${API_BASE}/chat/message`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        email: currentUser.email, 
                        message: text,
                        petType: currentPet
                    })
                });
                data = await res.json();
            } else {
                data = await mockResponse(text);
            }
            
            // 3. å¤„ç†è¿”å›
            btn.classList.remove('loading');
            btn.innerText = 'â¤';
            addMessage(data.reply, 'ai');
            
            if (data.activities && data.activities.length > 0) {
                renderCards(data.activities);
            }
            if (data.weather) setWeather(data.weather);

        } catch(e) {
            console.error(e);
            btn.classList.remove('loading');
            btn.innerText = 'â¤';
            addMessage("(æœåŠ¡è¿æ¥å¤±è´¥...)", 'ai');
        }
    }

    function mockResponse(text) {
         return Promise.resolve().then(() => {
            let reply = "æˆ‘å¬åˆ°äº†ä½ çš„å¿ƒå£°ã€‚ç”Ÿæ´»æ€»ä¼šæœ‰èµ·ä¼ï¼Œè¯•ç€æ·±å‘¼å¸ï¼Œæ„Ÿå—å½“ä¸‹çš„å¹³é™ã€‚";
            let weather = "sunset";
            let activities = [];
            
            const petNames = { corgi: "æŸ¯åŸº", rabbit: "å°ç™½å…”", cat: "å°çŒ«" };
            const pName = petNames[currentPet] || "å® ç‰©";

            if (text.includes("å®ƒ") || text.includes("å® ç‰©") || text.includes("ç‹—") || text.includes("å…”") || text.includes("çŒ«")) {
                if(text.includes("å–œæ¬¢")) {
                    reply = `${pName}æœ€å–œæ¬¢ä½ çš„é™ªä¼´äº†ï¼Œå½“ç„¶è¿˜æœ‰ç¾å‘³çš„é›¶é£Ÿå’Œèˆ’æœçš„æŠšæ‘¸ã€‚`;
                } else if(text.includes("å¹²ä»€ä¹ˆ") || text.includes("åœ¨åš")) {
                    reply = `${pName}æ­£äº«å—ç€æ‚ é—²çš„æ—¶å…‰å‘¢ï¼Œå¯èƒ½åœ¨å‘å‘†ï¼Œä¹Ÿå¯èƒ½åœ¨æƒ³ä½ ã€‚`;
                } else {
                    reply = `${pName}ä¼¼ä¹å¾ˆåœ¨æ„ä½ ï¼Œå®ƒä¼šä¸€ç›´é™é™åœ°é™ªç€ä½ ã€‚`;
                }
                weather = "sunny";
            }
            else if (text.includes("ç´¯") || text.includes("çƒ¦") || text.includes("éš¾è¿‡") || text.includes("å‹åŠ›")) {
                reply = "çœ‹èµ·æ¥ä½ æœ€è¿‘æ‰¿æ‹…äº†å¾ˆå¤šã€‚è¯·å…è®¸è‡ªå·±åœä¸‹æ¥ä¼‘æ¯ä¸€ä¼šå„¿ï¼Œä½ å·²ç»åšå¾—å¾ˆå¥½äº†ã€‚æŠ±æŠ±è‡ªå·±ã€‚";
                weather = "night";
            } else if (text.includes("å¼€å¿ƒ") || text.includes("å¥½") || text.includes("æ£’") || text.includes("é¡º")) {
                reply = "çœŸä¸ºä½ æ„Ÿåˆ°é«˜å…´ï¼ä¿æŒè¿™ç§ç§¯æçš„çŠ¶æ€ï¼Œä¸–ç•Œä¹Ÿä¼šå˜å¾—æ˜äº®èµ·æ¥ã€‚";
                weather = "sunny";
                activities = [{ title: "è®°å½•ç¾å¥½", time: "Now", desc: "å†™ä¸‹æ­¤åˆ»çš„å¼€å¿ƒç¬é—´ã€‚" }];
            }

            return { reply, activities, weather };
        });
    }

    function addMessage(text, type, autoFade=true) {
        const container = document.getElementById('chat-history');
        const div = document.createElement('div');
        div.className = `msg msg-${type}`;
        div.innerText = text;
        container.appendChild(div);

        if(autoFade) {
            setTimeout(() => {
                div.classList.add('fading-out');
                setTimeout(() => div.remove(), 1000); 
            }, 5000);
        } else {
             setTimeout(() => {
                div.classList.add('fading-out');
                setTimeout(() => div.remove(), 1000); 
            }, 8000); 
        }
    }

    function renderCards(activities) {
        const deck = document.getElementById('card-deck');
        deck.innerHTML = '';
        
        activities.forEach(act => {
            const card = document.createElement('div');
            card.className = 'activity-card';
            card.innerHTML = `
                <div class="act-time">${act.time}</div>
                <div class="act-title">${act.title}</div>
                <div class="act-desc">${act.desc}</div>
                <div class="act-add">ï¼‹</div>
            `;
            card.onclick = () => {
                openActivityModal(act, card);
            };
            const addBtn = card.querySelector('.act-add');
            addBtn.onclick = (e) => {
                e.stopPropagation();
                const success = addScheduleItem(act.title, act.time, 'TODO');
                if (success) {
                    card.style.transform = 'scale(0)';
                    setTimeout(() => card.remove(), 300);
                }
            };
            deck.appendChild(card);
        });
    }

    function openActivityModal(act, cardElement = null) {
        const overlay = document.getElementById('activity-modal');
        document.getElementById('modal-title').innerText = act.title;
        document.getElementById('modal-time').innerText = act.time;
        document.getElementById('modal-desc').innerText = act.desc;
        const add = document.getElementById('modal-add');
        add.onclick = () => {
            const success = addScheduleItem(act.title, act.time, 'TODO');
            if (success) {
                closeActivityModal();
                if (cardElement) {
                    cardElement.style.transform = 'scale(0)';
                    setTimeout(() => cardElement.remove(), 300);
                }
            }
        };
        overlay.style.display = 'flex';
    }

    function closeActivityModal() {
        const overlay = document.getElementById('activity-modal');
        overlay.style.display = 'none';
    }
    
    document.getElementById('user-input').addEventListener('keypress', (e) => {
        if(e.key === 'Enter') sendMessage();
    });

    if(typeof window.setWeather !== 'function'){
        window.setWeather = function(type){};
    }
    if(typeof window.selectPet !== 'function'){
        window.selectPet = function(type){
            currentPet = type;
            document.querySelectorAll('.pet-option').forEach(el => el.classList.remove('active'));
            const btn = document.querySelector(`.pet-option[onclick="selectPet('${type}')"]`);
            if(btn) btn.classList.add('active');
        };
    }

    // ==========================================
    // 2. 3D åœºæ™¯ (Original Corgi)
    // ==========================================
    
    if(!window.THREE){
        document.body.style.background = 'linear-gradient(180deg,#1A237E,#E0F7FA)';
        try{
            const warn = document.createElement('div');
            warn.id = 'runtime-warning';
            warn.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:9999;background:rgba(255,255,255,0.9);color:#333;padding:10px 16px;border-radius:10px;border:1px solid rgba(0,0,0,0.1);font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.15)';
            warn.innerText = 'ä¸‰ç»´åº“æœªåŠ è½½ï¼Œæ­£åœ¨å°è¯•å¤‡ç”¨æ¥æº...';
            document.body.appendChild(warn);
            const ps=document.getElementById('pet-selector'); if(ps) ps.style.display='none';
            const ip=document.getElementById('interaction-panel'); if(ip) ip.style.display='none';
            addMessage('ä¸‰ç»´åº“æœªåŠ è½½ï¼Œå½“å‰ä¸ºçº¯æ–‡å­—æ¨¡å¼','ai', false);
            if(typeof window.__ensureThree==='function'){
                window.__ensureThree().then(function(ok){
                    if(ok){ try{ document.getElementById('runtime-warning').remove(); }catch(e){}
                        if(typeof window.initThreeScene==='function'){ window.initThreeScene(); }
                    } else {
                        warn.innerText = 'ä¸‰ç»´åº“æœªåŠ è½½ï¼Œå»ºè®®ç”¨ç³»ç»Ÿæµè§ˆå™¨æ‰“å¼€ http://localhost:8080/ æˆ–æ£€æŸ¥ç½‘ç»œ';
                    }
                });
            }
        }catch(e){}
    }
    function initThreeScene() {
    if (!window.THREE || !THREE.OrbitControls) return;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); 

    // Increased far plane for smoother mountain visibility
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 8000);
    camera.position.set(0, 4, 6); 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
    document.body.appendChild(renderer.domElement); 

    var psReady=document.getElementById('pet-selector'); if(psReady) psReady.style.display='flex';
    var ipReady=document.getElementById('interaction-panel'); if(ipReady) ipReady.style.display='flex';

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.minDistance = 2; controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2 - 0.05; 
    controls.target.set(0, 0.5, 0);
    controls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };
    renderer.domElement.addEventListener('mousedown', (e) => { if(e.button===2) controls.enableRotate = true; });
    window.addEventListener('mouseup', (e) => { if(e.button===2) controls.enableRotate = false; });

    // --- åœºæ™¯ç‰©ä½“æ„å»º ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const targetRing = new THREE.Mesh(new THREE.RingGeometry(0.25, 0.35, 32), new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.7, side: THREE.DoubleSide }));
    targetRing.rotation.x = -Math.PI / 2; targetRing.visible = false; scene.add(targetRing);

    const STATE = { IDLE: 0, RUN: 1, BELLY: 2, BUSY: 3 };
    let currentState = STATE.IDLE;
    const targetPos = new THREE.Vector3();
    const dogPos = new THREE.Vector3(0, 0, 0); 
    const dogSpeed = 0.04; 
    const WORLD_RADIUS = 90;

    // --- å® ç‰©æ„å»ºç³»ç»Ÿ ---
    const corgiGroup = new THREE.Group();
    window.corgiGroup = corgiGroup;
    const corgiBody = new THREE.Group(); 
    window.corgiBody = corgiBody;
    const headGroup = new THREE.Group(); 
    corgiGroup.add(corgiBody); scene.add(corgiGroup);
    let legs = []; let tail;

    function clearPet() {
        corgiBody.clear();
        headGroup.clear();
        corgiBody.add(headGroup); // Re-add head group structure
        legs = [];
    }

    // 1. å‘†èŒæ°´ç‰› (Buffalo) - Removed per user request


    // 2. æŸ¯åŸº (Corgi) - Redesigned (Fluffy, Cute, Short Legs)
    function createCorgi() {
        clearPet();
        const traits = corgiGroup.userData.traits || { bodyScale:1, headScale:1, earScale:1 };
        
        const matOrange = new THREE.MeshStandardMaterial({ color: 0xF57C00, roughness: 0.6 });
        const matWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.6 });
        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });

        // Body (Capsule-like using merged spheres for fluffiness)
        const bodyR = 0.35 * traits.bodyScale;
        const bodyGroup = new THREE.Group();
        bodyGroup.position.y = 0.4;
        corgiBody.add(bodyGroup);

        // Main Body
        const b1 = new THREE.Mesh(new THREE.SphereGeometry(bodyR, 32, 32), matOrange);
        b1.scale.set(1, 0.9, 1.2);
        bodyGroup.add(b1);
        
        // White Belly/Chest
        const chest = new THREE.Mesh(new THREE.SphereGeometry(bodyR*0.9, 32, 32), matWhite);
        chest.position.set(0, -0.05, 0.2);
        chest.scale.set(0.9, 0.8, 1);
        bodyGroup.add(chest);

        // Butt (Heart shaped-ish)
        const buttL = new THREE.Mesh(new THREE.SphereGeometry(bodyR*0.6, 32, 32), matOrange);
        buttL.position.set(0.12, 0.03, -0.25);
        bodyGroup.add(buttL);
        const buttR = new THREE.Mesh(new THREE.SphereGeometry(bodyR*0.6, 32, 32), matOrange);
        buttR.position.set(-0.12, 0.03, -0.25);
        bodyGroup.add(buttR);

        // Tail (Nub)
        tail = new THREE.Group(); 
        tail.position.set(0, 0.4, -0.45);
        const tMesh = new THREE.Mesh(new THREE.SphereGeometry(0.08), matOrange);
        tail.add(tMesh);
        corgiBody.add(tail);

        // Head
        corgiBody.add(headGroup);
        headGroup.position.set(0, 0.75, 0.45);

        const headR = 0.32 * traits.headScale;
        const head = new THREE.Mesh(new THREE.SphereGeometry(headR, 32, 32), matOrange);
        head.castShadow = true; 
        headGroup.add(head);

        // Snout
        const snoutGeo = new THREE.SphereGeometry(0.14, 32, 32);
        const snoutM = new THREE.Mesh(snoutGeo, matWhite);
        snoutM.scale.set(1, 0.7, 1.2);
        snoutM.position.set(0, -0.12, 0.25);
        headGroup.add(snoutM);

        const nose = new THREE.Mesh(new THREE.SphereGeometry(0.05), matBlack);
        nose.position.set(0, -0.05, 0.4);
        headGroup.add(nose);

        // Ears (Big Triangles)
        const earGeo = new THREE.ConeGeometry(0.15 * traits.earScale, 0.3 * traits.earScale, 32);
        const earL = new THREE.Group(); earL.position.set(0.22, 0.20, 0);
        const elM = new THREE.Mesh(earGeo, matOrange); elM.position.y=0.12;
        earL.add(elM); 
        earL.rotation.set(0, 0, -0.4);
        headGroup.add(earL);

        const earR = new THREE.Group(); earR.position.set(-0.22, 0.20, 0);
        const erM = new THREE.Mesh(earGeo, matOrange); erM.position.y=0.12;
        earR.add(erM); 
        earR.rotation.set(0, 0, 0.4);
        headGroup.add(earR);
        corgiGroup.userData.ears = [earL, earR];

        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.05, 32, 32);
        const eyeL = new THREE.Mesh(eyeGeo, matBlack); 
        eyeL.position.set(0.14, 0.05, 0.29); 
        headGroup.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, matBlack); 
        eyeR.position.set(-0.14, 0.05, 0.29); 
        headGroup.add(eyeR);

        // Legs (Short & Stubby)
        const legGeo = new THREE.CylinderGeometry(0.09, 0.07, 0.3, 32);
        const legPos = [{x:0.2, z:0.25}, {x:-0.2, z:0.25}, {x:0.2, z:-0.25}, {x:-0.2, z:-0.25}];
        legPos.forEach(p => {
            const legG = new THREE.Group(); 
            legG.position.set(p.x, 0.25, p.z); 
            corgiBody.add(legG);
            
            const l = new THREE.Mesh(legGeo, matWhite); 
            l.position.y = -0.15; 
            l.castShadow = true; 
            legG.add(l);
            
            // Paws
            const paw = new THREE.Mesh(new THREE.SphereGeometry(0.08), matWhite);
            paw.position.set(0, -0.15, 0.05);
            l.add(paw);

            legs.push(legG);
        });
    }

    // 3. å°ç™½å…” (Rabbit) - Fixed (Visuals & Structure)
    function createRabbit() {
        clearPet();
        const traits = corgiGroup.userData.traits || { bodyScale:1, headScale:1, earScale:1 };
        
        const matWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.8 });
        const matPink = new THREE.MeshStandardMaterial({ color: 0xF8BBD0, roughness: 0.8 });
        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });

        // Body - Rounder
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.32 * traits.bodyScale, 32, 32), matWhite);
        body.position.y = 0.38; 
        body.scale.set(0.95, 0.85, 1.05); 
        body.castShadow = true;
        corgiBody.add(body);

        // Tail (Tiny fluffy ball)
        tail = new THREE.Group(); tail.position.set(0, 0.3, -0.42);
        const tMesh = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), matWhite);
        tail.add(tMesh); corgiBody.add(tail);

        // Head - Distinctly forward
        corgiBody.add(headGroup);
        headGroup.position.set(0, 0.6, 0.35);
        headGroup.rotation.set(0, 0, 0);

        const headR = 0.25 * traits.headScale;
        const head = new THREE.Mesh(new THREE.SphereGeometry(headR, 32, 32), matWhite);
        head.castShadow = true; headGroup.add(head);

        // Chest fluff
        const chestFluff = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), matWhite);
        chestFluff.position.set(0, 0.32, 0.18);
        corgiBody.add(chestFluff);

        // Snout
        const snout = new THREE.Mesh(new THREE.SphereGeometry(headR * 0.4, 16, 16), matWhite);
        snout.position.set(0, -0.05, 0.2); headGroup.add(snout);
        const nose = new THREE.Mesh(new THREE.SphereGeometry(0.03), matPink);
        nose.position.set(0, 0.02, 0.12); snout.add(nose);

        // Ears (Long and upright)
        const earGeo = new THREE.CylinderGeometry(0.05 * traits.earScale, 0.04 * traits.earScale, 0.45 * traits.earScale, 16);
        const eL = new THREE.Group(); eL.position.set(0.12, 0.2, 0);
        const elMesh = new THREE.Mesh(earGeo, matWhite); elMesh.position.y = 0.2; elMesh.rotation.x = -0.1;
        eL.add(elMesh); headGroup.add(eL);
        
        const eR = new THREE.Group(); eR.position.set(-0.12, 0.2, 0);
        const erMesh = new THREE.Mesh(earGeo, matWhite); erMesh.position.y = 0.2; erMesh.rotation.x = -0.1;
        eR.add(erMesh); headGroup.add(eR);

        corgiGroup.userData.ears = [eL, eR];

        // Eyes
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.03), matBlack); eyeL.position.set(0.1, 0.05, 0.22); headGroup.add(eyeL);
        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.03), matBlack); eyeR.position.set(-0.1, 0.05, 0.22); headGroup.add(eyeR);

        // Legs - Attached to body, moving with it
        const legGeo = new THREE.CylinderGeometry(0.05, 0.04, 0.18, 16);
        const legPos = [{x:0.15, z:0.2}, {x:-0.15, z:0.2}, {x:0.15, z:-0.2}, {x:-0.15, z:-0.2}];
        legPos.forEach(p => {
            const legG = new THREE.Group(); 
            legG.position.set(p.x, 0.28, p.z); // Embed deeper into body (Was 0.18)
            corgiBody.add(legG);
            
            const l = new THREE.Mesh(legGeo, matWhite); 
            l.position.y = -0.16; 
            l.castShadow = true; 
            legG.add(l);
            const paw = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), matPink);
            paw.position.set(0, -0.06, 0.06);
            l.add(paw);
            legs.push(legG);
        });
    }

    // 4. å°èŠ±çŒ« (Cat) - Fixed (Legs & Structure)
    function createCat() {
        clearPet();
        const traits = corgiGroup.userData.traits || { bodyScale:1, headScale:1, earScale:1 };
        
        const matGrey = new THREE.MeshStandardMaterial({ color: 0x9E9E9E, roughness: 0.7 });
        const matWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.7 });
        const matPink = new THREE.MeshStandardMaterial({ color: 0xF48FB1 });
        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });

        // Body
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.38 * traits.bodyScale, 32, 32), matGrey);
        body.position.y = 0.42; body.scale.set(0.65, 0.8, 1.25); body.castShadow = true;
        corgiBody.add(body);
        
        // Belly patch
        const belly = new THREE.Mesh(new THREE.SphereGeometry(0.28 * traits.bodyScale, 32, 32), matWhite);
        belly.position.set(0, 0.30, 0.05); belly.scale.set(0.9, 0.6, 1.0);
        corgiBody.add(belly);

        // Tail (Long)
        tail = new THREE.Group(); tail.position.set(0, 0.5, -0.45);
        const tMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.02, 0.5, 16), matGrey);
        tMesh.rotation.x = 0.5; tMesh.position.set(0, 0.2, -0.1);
        tail.add(tMesh); corgiBody.add(tail);

        // Head
        corgiBody.add(headGroup); // Ensure headGroup is added!
        const headR = 0.24 * traits.headScale;
        headGroup.position.set(0, 0.65, 0.35);
        const head = new THREE.Mesh(new THREE.SphereGeometry(headR, 32, 32), matGrey);
        head.castShadow = true; headGroup.add(head);

        // Chest fluff (white)
        const chestFluffCat = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), matWhite);
        chestFluffCat.position.set(0, 0.38, 0.18);
        corgiBody.add(chestFluffCat);

        // Ears (Pointy)
        const earGeo = new THREE.ConeGeometry(0.07 * traits.earScale, 0.18 * traits.earScale, 4);
        const eL = new THREE.Mesh(earGeo, matGrey); eL.position.set(0.15, 0.25, 0); eL.rotation.set(0, 0, -0.3); headGroup.add(eL);
        const eR = new THREE.Mesh(earGeo, matGrey); eR.position.set(-0.15, 0.25, 0); eR.rotation.set(0, 0, 0.3); headGroup.add(eR);
        corgiGroup.userData.ears = [eL, eR];

        // Eyes (Vertical Slit)
        const eyeGeo = new THREE.BoxGeometry(0.02, 0.08, 0.02);
        const eyeL = new THREE.Mesh(eyeGeo, matBlack); eyeL.position.set(0.1, 0.05, 0.24); headGroup.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, matBlack); eyeR.position.set(-0.1, 0.05, 0.24); headGroup.add(eyeR);

        // Nose
        const noseMesh = new THREE.Mesh(new THREE.ConeGeometry(0.02, 0.02, 4), matPink);
        noseMesh.rotation.x = Math.PI/2; noseMesh.rotation.y = Math.PI/4;
        noseMesh.position.set(0, -0.02, 0.24); headGroup.add(noseMesh);

        // Mouth (8-petal / 'w' shape)
        const mouthGroup = new THREE.Group();
        mouthGroup.position.set(0, -0.05, 0.24);
        headGroup.add(mouthGroup);
        const mouthCurve = new THREE.TorusGeometry(0.03, 0.006, 8, 16, Math.PI);
        const mL = new THREE.Mesh(mouthCurve, matBlack);
        mL.position.set(0.03, 0, 0); mL.rotation.z = Math.PI;
        mouthGroup.add(mL);
        const mR = new THREE.Mesh(mouthCurve, matBlack);
        mR.position.set(-0.03, 0, 0); mR.rotation.z = Math.PI;
        mouthGroup.add(mR);

        // Legs
        const legGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.28, 16);
        const legPos = [{x:0.15, z:0.2}, {x:-0.15, z:0.2}, {x:0.15, z:-0.2}, {x:-0.15, z:-0.2}];
        legPos.forEach(p => {
            const legG = new THREE.Group(); legG.position.set(p.x, 0.2, p.z); // Raised to body height
            corgiBody.add(legG); // Ensure added to body
            const l = new THREE.Mesh(legGeo, matWhite); l.position.y = -0.1; l.castShadow = true; 
            legG.add(l);
            const paw = new THREE.Mesh(new THREE.SphereGeometry(0.045, 16, 16), matPink);
            paw.position.set(0, -0.10, 0.06);
            l.add(paw);
            legs.push(legG);
        });
    }

    window.createCorgi = createCorgi;
    window.createRabbit = createRabbit;
    window.createCat = createCat;

    // --- å® ç‰©çŠ¶æ€ç³»ç»Ÿ ---
    const petStatus = {
        mood: 80,
        health: 90,
        gloss: 75
    };

    function updateStatusUI() {
        document.getElementById('bar-mood').style.width = petStatus.mood + '%';
        document.getElementById('bar-health').style.width = petStatus.health + '%';
        document.getElementById('bar-gloss').style.width = petStatus.gloss + '%';
    }

    window.interact = function(type) {
        lastOwnerInteractionTime = Date.now() * 0.001;
        didWanderAfterOwnerIdle = false;
        if (currentState !== STATE.IDLE) return; // å¿™ç¢Œä¸­
        currentState = STATE.BUSY; // é”å®šçŠ¶æ€

        // 1. æ›´æ–°æ•°å€¼ & æç¤º
        if (type === 'feed') {
            petStatus.health = Math.min(100, petStatus.health + 10);
            petStatus.mood = Math.min(100, petStatus.mood + 5);
            showThought("å§å”§å§å”§... å¥½åƒï¼");
        } else if (type === 'groom') {
            petStatus.gloss = Math.min(100, petStatus.gloss + 15);
            petStatus.mood = Math.min(100, petStatus.mood + 10);
            showThought("å‘¼å™œå‘¼å™œ... èˆ’æœ~");
        } else if (type === 'play') {
            petStatus.mood = Math.min(100, petStatus.mood + 20);
            petStatus.health = Math.max(0, petStatus.health - 5); // æ¶ˆè€—ä½“åŠ›
            showThought("å¥½è€¶ï¼å†æ¥ï¼");
        }
        updateStatusUI();

        // 2. æ‰§è¡Œä¸“å±åŠ¨ç”»
        let startTime = Date.now();
        
        // Show Props
        if(type === 'feed' && propFood) propFood.visible = true;
        if(type === 'groom' && propComb) propComb.visible = true;
        if(type === 'play' && propToy) propToy.visible = true;

        const animLoop = () => {
            const now = Date.now();
            const t = (now - startTime) / 1000; // elapsed seconds
            let finished = false;
            const duration = 2.0; // é»˜è®¤åŠ¨ç”»æ—¶é•¿

            // é‡ç½®åŸºç¡€å§¿æ€ (æ¯å¸§è¦†ç›–ï¼Œé¿å…ç´¯ç§¯è¯¯å·®)
            corgiBody.rotation.set(0,0,0);
            corgiBody.position.set(0,0,0);
            headGroup.rotation.set(0,0,0);
            if(tail) tail.rotation.set(0,0,0);

            if (type === 'feed') {
                if (currentPet === 'corgi') {
                    // æŸ¯åŸº: å¼€å¿ƒè·³è·ƒ
                    corgiBody.position.y = Math.abs(Math.sin(t * 15)) * 0.2; 
                    corgiBody.rotation.z = Math.sin(t * 20) * 0.1;
                } else if (currentPet === 'rabbit') {
                    // å…”å­: å¿«é€Ÿå’€åš¼
                    headGroup.rotation.x = Math.sin(t * 25) * 0.15 + 0.15;
                    corgiBody.rotation.x = 0.15;
                } else if (currentPet === 'cat') {
                    // çŒ«å’ª: åŸ‹å¤´åƒ
                    headGroup.rotation.x = 0.6 + Math.sin(t * 8) * 0.1; 
                    corgiBody.position.y = -0.1; 
                }
            } else if (type === 'groom') {
                if (currentPet === 'corgi') {
                    // æŸ¯åŸº: å±è‚¡å·¦å³æ‘†åŠ¨ (No yaw spin)
                    corgiBody.rotation.z = Math.sin(t * 12) * 0.12; 
                    if(tail) tail.rotation.z = Math.sin(t * 20) * 1.0;
                } else if (currentPet === 'rabbit') {
                    // å…”å­: èˆ’æœé¢¤æŠ–
                    corgiBody.position.x = Math.sin(t * 40) * 0.02;
                    headGroup.rotation.z = Math.sin(t * 6) * 0.15;
                } else if (currentPet === 'cat') {
                    // çŒ«å’ª: é«˜é«˜æ‹±èƒŒ
                    corgiBody.rotation.x = -0.5; 
                    headGroup.rotation.x = 0.6;
                    corgiBody.position.y = 0.15;
                }
            } else if (type === 'play') {
                if (currentPet === 'corgi') {
                    // æŸ¯åŸº: æ¬¢å¿«è·³è·ƒ (No spinning)
                    corgiBody.rotation.z = Math.sin(t * 15) * 0.1; // Wiggle
                    corgiBody.position.y = Math.abs(Math.sin(t * 15)) * 0.15;
                } else if (currentPet === 'rabbit') {
                    // å…”å­: è¶…çº§å¤§è·³
                    corgiBody.position.y = Math.abs(Math.sin(t * 8)) * 0.8;
                    corgiBody.rotation.x = -Math.sin(t * 8) * 0.4;
                } else if (currentPet === 'cat') {
                    // çŒ«å’ª: æ‰‘æ€
                    corgiBody.position.z = Math.sin(t * 10) * 0.8;
                    corgiBody.position.y = Math.abs(Math.sin(t * 10)) * 0.3;
                }
            }

            if (t > duration) {
                // ç»“æŸåŠ¨ç”»ï¼Œå¤ä½
                corgiBody.rotation.set(0,0,0);
                corgiBody.position.set(0,0,0);
                headGroup.rotation.set(0,0,0);
                if(tail) tail.rotation.set(0,0,0);
                
                // Hide Props
                if(propFood) propFood.visible = false;
                if(propComb) propComb.visible = false;
                if(propToy) propToy.visible = false;

                currentState = STATE.IDLE;
            } else {
                requestAnimationFrame(animLoop);
            }
        };
        animLoop();
    }
    
    // å®šæ—¶é™ä½çŠ¶æ€ (æ¨¡æ‹Ÿéœ€æ±‚)
    setInterval(() => {
        petStatus.mood = Math.max(0, petStatus.mood - 0.5);
        petStatus.health = Math.max(0, petStatus.health - 0.2);
        petStatus.gloss = Math.max(0, petStatus.gloss - 0.1);
        updateStatusUI();
    }, 5000);



    // --- å® ç‰©è‡ªä¸»è¡Œä¸ºç³»ç»Ÿ ---
    let lastBehaviorTime = 0;
    let behaviorTimer = null;
    let runLookAtCooldown = 0;
    let runStateStart = 0;
    let lastRunDist = Infinity;
    let lastDistDecreaseTime = 0;
    let lastOwnerInteractionTime = 0;
    const OWNER_IDLE_THRESHOLD = 60; // seconds
    let didWanderAfterOwnerIdle = false;

    // --- åˆ‡æ¢ä¸åˆå§‹åŒ– ---
    window.selectPet = function(type) {
        document.querySelectorAll('.pet-option').forEach(el => el.classList.remove('active'));
        document.querySelector(`.pet-option[onclick="selectPet('${type}')"]`).classList.add('active');
        
        currentPet = type;
        lastBehaviorTime = Date.now() * 0.001;
        
        // New traits for new selection
        corgiGroup.userData.traits = generatePetTraits();
        
        rebuildPet();

        // Save to backend
        if(currentUser) {
            const config = { type: currentPet, traits: corgiGroup.userData.traits };
            saveUserData({ petConfig: config });
        }
    }

        // Default startup pet
    selectPet(currentPet);
    if(window.pendingPetConfig){
        restorePet(window.pendingPetConfig);
        window.pendingPetConfig = null;
    }
    
    function showThought(text) {
        const bubble = document.getElementById('pet-thoughts');
        const txt = document.getElementById('thought-text');
        txt.innerText = text;
        bubble.style.opacity = 1;
        
        if(behaviorTimer) clearTimeout(behaviorTimer);
        behaviorTimer = setTimeout(() => {
            bubble.style.opacity = 0;
        }, 3000);
    }

    // Helper to check position validity (Avoid Ponds)
    function isValidPos(pos) {
        for(let p of ponds) {
            if(pos.distanceTo(p.position) < p.radius + 1.5) return false;
        }
        return true;
    }

    function updatePetBehavior(time) {
        // åªæœ‰åœ¨ IDLE çŠ¶æ€ä¸‹æ‰è§¦å‘è‡ªä¸»è¡Œä¸º
        if (currentState !== STATE.IDLE) return;
        const ownerIdle = (time - lastOwnerInteractionTime) > OWNER_IDLE_THRESHOLD;

        if (time - lastBehaviorTime > 100 + Math.random() * 125) {
            lastBehaviorTime = time;
            const texts = PET_BEHAVIOR_TEXT[currentPet];
            let personality = PET_PERSONALITY[currentPet];
            if(!personality) personality = { type:'energetic', sniffChance:0.5, probeChance:0.5 };
            const rand = Math.random();
            if (!ownerIdle || Math.random() < 0.95) {
                if (Math.random() < 0.6) {
                    const camPos = camera.position.clone();
                    camPos.y = corgiGroup.position.y;
                    corgiGroup.lookAt(camPos);
                    headGroup.rotation.z = (Math.random()<0.5?1:-1) * 0.25;
                    setTimeout(()=> headGroup.rotation.z = 0, 1200);
                    showThought("(çœ‹ç€ä½ ...)");
                } else {
                    // è‡ªæˆ‘ç…§æ–™ (åŸåœ°)
                    if (currentPet === 'cat') {
                        showThought("(èˆ”çˆªå­...)");
                        headGroup.rotation.x = 0.25;
                        setTimeout(()=> headGroup.rotation.x = 0, 1500);
                    } else if (currentPet === 'rabbit') {
                        showThought("(æŠ–åŠ¨é¼»å­...)");
                        let c=0; const s=setInterval(()=>{ headGroup.position.y = 0.65 + Math.sin(c)*0.02; c+=0.5; if(c>10){clearInterval(s); headGroup.position.y=0.65;} }, 50);
                    } else {
                        showThought("(æ¢³ç†æ¯›å‘...)");
                        if(tail) { let c=0; const w=setInterval(()=>{ tail.rotation.z = Math.sin(c)*0.8; c+=0.3; if(c>Math.PI*2){ clearInterval(w); tail.rotation.z=0; }}, 50); }
                    }
                }
                return;
            }

            // Helper to check position validity (Avoid Ponds)
            const isValidPos = (pos) => {
                for(let p of ponds) {
                    if(pos.distanceTo(p.position) < p.radius + 1.5) return false;
                }
                return true;
            };

            // --- 1. ä¸ç”¨æˆ·äº’åŠ¨ (é—»å—…/è¯•æ¢) ---
            const distToCam = dogPos.distanceTo(camera.position);
            // å¦‚æœè·ç¦»ç›¸æœºè¾ƒè¿œä¸”è§¦å‘æ¦‚ç‡ï¼Œåˆ™é è¿‘
            if (ownerIdle && !didWanderAfterOwnerIdle && distToCam > 4.0 && distToCam < 15.0 && Math.random() < personality.sniffChance) {
                const camPosXZ = new THREE.Vector3(camera.position.x, 0, camera.position.z);
                const dir = camPosXZ.clone().sub(dogPos).normalize();
                const stopDist = 3.5; // åœåœ¨ç›¸æœºå‰
                
                const target = camPosXZ.sub(dir.multiplyScalar(stopDist));
                if(isValidPos(target)) {
                    targetPos.copy(target);
                    currentState = STATE.RUN;
                    
                    const approachTexts = ["(å¥½å¥‡åœ°èµ°è¿‡æ¥...)", "(æƒ³è¦é è¿‘ä½ ...)", "(å—…å—…ä½ çš„å‘³é“...)"];
                    showThought(approachTexts[Math.floor(Math.random()*approachTexts.length)]);
                    return;
                }
            }

            // å¦‚æœå·²ç»åœ¨ç›¸æœºé™„è¿‘ (Sniff/Probe Animation)
            if (distToCam <= 4.5 && Math.random() < personality.probeChance) {
                 // Face camera
                 const camPos = camera.position.clone();
                 const dx = camPos.x - corgiGroup.position.x;
                 const dz = camPos.z - corgiGroup.position.z;
                 corgiGroup.rotation.y = Math.atan2(dx, dz);

                 if (currentPet === 'corgi') {
                     showThought("(æ­ªå¤´æ€~)");
                     headGroup.rotation.z = 0.5;
                     setTimeout(()=>headGroup.rotation.z=0, 1000);
                 } else if (currentPet === 'cat') {
                     showThought("(ç›¯ç€ä½ çœ‹...)");
                     // åä¸‹å‡è§†
                     corgiBody.rotation.x = -Math.PI/6;
                     corgiBody.position.y = -0.1;
                     setTimeout(()=>{ corgiBody.rotation.x=0; corgiBody.position.y=0; }, 2000);
                 } else {
                     showThought("(åŠ¨åŠ¨é¼»å­å—…å—…)");
                     // Rabbit sniff
                     let count=0;
                     const s = setInterval(()=>{ headGroup.position.y = 0.65 + Math.sin(count)*0.02; count+=0.5; if(count>10) clearInterval(s); }, 50);
                 }
                 return;
            }

            // --- 1.5 Environmental Attraction (Ponds, Mushrooms, Bushes, Flowers) ---
            const attractions = [...flowerInstances, ...bushes, ...ponds, ...mushrooms, ...stones];
            // Filter attractions within 5m
            const nearby = attractions.filter(a => a.position.distanceTo(dogPos) < 5.0);
            
            if (ownerIdle && !didWanderAfterOwnerIdle && nearby.length > 0 && Math.random() < 0.03) {
                 const target = nearby[Math.floor(Math.random() * nearby.length)];
                 
                 // Calculate safe stopping point
                 const dir = dogPos.clone().sub(target.position).normalize();
                 // If target is pond, stop further away
                 let stopDist = 0.5;
                 // Check if target is in 'ponds' array (by reference or property)
                 // We constructed attractions array, so we can't easily check type.
                 // But we can check if it has 'radius'.
                 if(target.radius && target.radius > 3) stopDist = target.radius + 1.0; // Pond

                 const dest = target.position.clone().add(dir.multiplyScalar(stopDist));
                 
                 if(isValidPos(dest)) {
                     targetPos.copy(dest);
                     currentState = STATE.RUN;
                     didWanderAfterOwnerIdle = true;
                     showThought("(è¢«ä»€ä¹ˆå¸å¼•äº†...)");
                     return;
                 }
            }

            // --- 2. æ„å›¾è¡¨è¾¾ (Intention) ---
            if (ownerIdle && !didWanderAfterOwnerIdle && Math.random() < 0.18) {
                const intentions = [
                    { text: "æƒ³å»é‚£è¾¹çœ‹çœ‹...", action: "wander" },
                    { text: "è‚šå­æœ‰ç‚¹é¥¿äº†...", action: "food" },
                    { text: "å¥½æƒ³ç©çƒå•Š...", action: "play" },
                    { text: "é‚£æ£µæ ‘çœ‹èµ·æ¥ä¸é”™...", action: "tree" },
                    { text: "ä»Šå¤©å¤©æ°”çœŸå¥½~", action: "idle" }
                ];
                // æ ¹æ®æ€§æ ¼è°ƒæ•´
                if(personality.type === 'energetic') intentions.push({ text: "å¿«é™ªæˆ‘ç©ï¼", action: "play_beg" });
                if(personality.type === 'timid') intentions.push({ text: "æœ‰ç‚¹å®³æ€•...", action: "hide" });

                const intent = intentions[Math.floor(Math.random() * intentions.length)];
                showThought(intent.text);
                
                if(intent.action === "wander" || intent.action === "tree") {
                    let targetTree = null;
                    if(intent.action === "tree" && trees.length > 0) {
                        // Filter trees within 5m (slightly larger range for trees)
                        const nearbyTrees = trees.filter(t => t.position.distanceTo(dogPos) < 5.0);
                        if (nearbyTrees.length > 0) {
                            targetTree = nearbyTrees[Math.floor(Math.random() * nearbyTrees.length)];
                        }
                    }

                    if(targetTree) {
                         const dir = dogPos.clone().sub(targetTree.position).normalize();
                         const dest = targetTree.position.clone().add(dir.multiplyScalar(2.0));
                         if(isValidPos(dest)) {
                             targetPos.copy(dest);
                             currentState = STATE.RUN;
                             didWanderAfterOwnerIdle = true;
                         }
                    } else {
                         // Fallback to short wander
                         // Try up to 3 times to find valid pos
                         for(let k=0; k<3; k++) {
                             const angle = Math.random() * Math.PI * 2;
                             const dist = 0.3 + Math.random() * 1.0;
                             let tx = dogPos.x + Math.cos(angle)*dist;
                             let tz = dogPos.z + Math.sin(angle)*dist;
                             const dest = new THREE.Vector3(tx, 0, tz);
                             if(isValidPos(dest)) {
                                 targetPos.copy(dest);
                                 currentState = STATE.RUN;
                                 didWanderAfterOwnerIdle = true;
                                 break;
                             }
                         }
                    }
                } else if (intent.action === "play_beg") {
                     // Jump
                     corgiBody.position.y = 0.3;
                     setTimeout(()=>corgiBody.position.y=0, 300);
                }
                return;
            }


            // --- 3. ç¯å¢ƒäº¤äº’æ£€æµ‹ (æ ‘æœ¨, èŠ±æœµ, çŒæœ¨, çŸ³å¤´, è˜‘è‡) ---
            
            // A. Trees (Climb/Rub)
            let nearbyTree = trees.find(t => dogPos.distanceTo(t.position) < 3.5);
            if (nearbyTree && Math.random() < 0.03) {
                const treeDir = nearbyTree.position.clone().sub(dogPos).normalize();
                corgiGroup.rotation.y = Math.atan2(treeDir.x, treeDir.z);
                
                if(currentPet === 'corgi') {
                    showThought("(é—»é—»æ ‘æ ¹...)");
                    corgiBody.rotation.x = 0.2;
                    setTimeout(()=>corgiBody.rotation.x=0, 1000);
                } else if(currentPet === 'cat') {
                    showThought("(æƒ³è¦çˆ¬æ ‘...)"); 
                    // Climb animation (Vertical jump & hold)
                    let count = 0;
                    const climbAnim = setInterval(() => {
                        if(count < 15) corgiBody.position.y += 0.08; // Up
                        else if(count < 40) corgiBody.rotation.x = -0.6; // Hold & Look up
                        else corgiBody.position.y -= 0.08; // Down
                        
                        count++;
                        if(count > 55 || corgiBody.position.y < 0) { 
                            clearInterval(climbAnim); 
                            corgiBody.position.y = 0; 
                            corgiBody.rotation.x = 0; 
                        }
                    }, 30);
                } else {
                     showThought("(ç»•ç€æ ‘è·‘...)");
                     let count = 0;
                     const hop = setInterval(() => {
                        corgiBody.position.y = Math.abs(Math.sin(count)) * 0.3;
                        count += 0.3;
                        if(count > Math.PI*4) { clearInterval(hop); corgiBody.position.y = 0; }
                     }, 30);
                }
                return;
            }

            // B. Flowers (Sniff)
            let nearbyFlower = flowerInstances.find(f => dogPos.distanceTo(f.position) < 2.5);
            if (nearbyFlower && Math.random() < 0.04) {
                const dir = nearbyFlower.position.clone().sub(dogPos).normalize();
                corgiGroup.rotation.y = Math.atan2(dir.x, dir.z);
                showThought("(é—»é—»èŠ±é¦™...)");
                
                // Sniff animation
                corgiBody.rotation.x = 0.3; 
                headGroup.rotation.x = 0.2;
                
                let count = 0;
                const sniff = setInterval(() => {
                    headGroup.position.z = 0.35 + Math.sin(count*20)*0.02; 
                    count += 0.1;
                    if(count > 2) { 
                        clearInterval(sniff); 
                        corgiBody.rotation.x = 0; 
                        headGroup.rotation.x = 0; 
                        headGroup.position.z = 0.35; 
                        
                        showThought("å¥½é¦™å•Š~");
                        if(currentPet === 'rabbit' || currentPet === 'corgi') {
                            corgiBody.position.y = 0.2; 
                            setTimeout(()=>corgiBody.position.y=0, 200);
                        }
                    }
                }, 30);
                return;
            }

            // C. Bushes (Bounce/Hide/Find Berries)
            let nearbyBush = bushes.find(b => dogPos.distanceTo(b.position) < 2.5);
            if (nearbyBush && Math.random() < 0.04) {
                const dir = nearbyBush.position.clone().sub(dogPos).normalize();
                corgiGroup.rotation.y = Math.atan2(dir.x, dir.z);
                
                const randAction = Math.random();
                
                if (randAction < 0.3) { // 30% Find Berries
                     showThought("(å‘ç°é‡æœï¼)");
                     corgiBody.rotation.x = 0.35; 
                     headGroup.rotation.x = 0.25;
                     if(propFood) propFood.visible = true;
                     
                     setTimeout(() => { showThought("é…¸é…¸ç”œç”œ~"); }, 1000);
                     setTimeout(() => {
                        corgiBody.rotation.x = 0;
                        headGroup.rotation.x = 0;
                        if(propFood) propFood.visible = false;
                        petStatus.health = Math.min(100, petStatus.health + 2);
                        updateStatusUI();
                     }, 2500);
                     
                } else if (currentPet === 'rabbit' || currentPet === 'cat') {
                    showThought("(é’»è¿›çŒæœ¨ä¸›...)");
                    corgiBody.scale.setScalar(0.5); 
                    corgiBody.position.y = -0.2;
                    setTimeout(() => {
                        showThought("(çªç„¶è·³å‡ºæ¥ï¼)");
                        corgiBody.scale.setScalar(1);
                        corgiBody.position.y = 0.5; 
                        setTimeout(()=>corgiBody.position.y=0, 300);
                    }, 2000);
                } else {
                    showThought("(å¼¹è·³çŒæœ¨ä¸›ï¼)");
                    let count = 0;
                    const bounce = setInterval(() => {
                        corgiBody.position.y = Math.abs(Math.sin(count)) * 0.4;
                        count += 0.2;
                        if(count > Math.PI*4) { clearInterval(bounce); corgiBody.position.y = 0; }
                    }, 30);
                }
                return;
            }

            // D. Mushrooms (Find Food)
            let nearbyMush = mushrooms.find(m => dogPos.distanceTo(m.position) < 2.0);
            if (nearbyMush && Math.random() < 0.04) {
                const dir = nearbyMush.position.clone().sub(dogPos).normalize();
                corgiGroup.rotation.y = Math.atan2(dir.x, dir.z);
                showThought("(å‘ç°å°è˜‘è‡ï¼)");
                
                // Eating animation
                corgiBody.rotation.x = 0.35; 
                headGroup.rotation.x = 0.25;
                if(propFood) propFood.visible = true;

                setTimeout(() => {
                    showThought("å§å”§å§å”§...");
                }, 1000);

                setTimeout(() => {
                    corgiBody.rotation.x = 0;
                    headGroup.rotation.x = 0;
                    if(propFood) propFood.visible = false;
                    showThought("å‘³é“çœŸä¸é”™~");
                    petStatus.health = Math.min(100, petStatus.health + 3);
                    updateStatusUI();
                }, 3000);
                return;
            }

            // E. Stones (Jump)
            let nearbyStone = stones.find(s => dogPos.distanceTo(s.position) < 2.0);
            if (nearbyStone && Math.random() < 0.02) {
                const dir = nearbyStone.position.clone().sub(dogPos).normalize();
                corgiGroup.rotation.y = Math.atan2(dir.x, dir.z);
                let count = 0;
                const jump = setInterval(() => {
                    corgiBody.position.y = Math.abs(Math.sin(count)) * 0.35;
                    count += 0.25;
                    if(count > Math.PI*4) { clearInterval(jump); corgiBody.position.y = 0; }
                }, 30);
                showThought("(è·³ä¸ŠçŸ³å¤´ï¼)");
                return;
            }

            // --- 2. éšæœºåŠ¨ä½œ (Sit/Beg, Idle, Wander) ---

            if (rand < 0.03) {
                // ** Beg Pose (Sit with front legs up) **
                showThought("(åä¸‹æ±‚æŠ±æŠ±...)");
                
                // Animation: Body rotates back, front lifts
                const duration = 3000; // Hold for 3s
                const startY = corgiBody.position.y;
                
                corgiBody.rotation.x = -Math.PI / 4; // Tilt back 45 deg
                corgiBody.position.y = 0.1;
                
                setTimeout(() => {
                    corgiBody.rotation.x = 0;
                    corgiBody.position.y = startY;
                }, duration);
                
            } else if (ownerIdle && !didWanderAfterOwnerIdle && rand < 0.0067) {
                // Wander (Relative to current position, short range)
                for(let k=0; k<3; k++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 0.3 + Math.random() * 1.0;
                    
                    let tx = dogPos.x + Math.cos(angle) * dist;
                    let tz = dogPos.z + Math.sin(angle) * dist;
                    
                    // Clamp to safe area
                    if(tx > 30) tx = 30; if(tx < -30) tx = -30;
                    if(tz > 30) tz = 30; if(tz < -30) tz = -30;
                    
                    const dest = new THREE.Vector3(tx, 0, tz);
                    // Check pond
                    let inPond = false;
                    for(let p of ponds) {
                        if(dest.distanceTo(p.position) < p.radius + 1.5) { inPond = true; break; }
                    }
                    
                    if(!inPond) {
                        targetPos.copy(dest);
                        currentState = STATE.RUN;
                        didWanderAfterOwnerIdle = true;
                        showThought(texts.move);
                        break;
                    }
                }

            } else {
                // Idle / Look at user
                if (Math.random() < 0.5) {
                    const camPos = camera.position.clone();
                    camPos.y = corgiGroup.position.y;
                    corgiGroup.lookAt(camPos);
                    headGroup.rotation.z = (Math.random()<0.5?1:-1) * 0.25;
                    setTimeout(()=> headGroup.rotation.z = 0, 1200);
                    showThought("(çœ‹ç€ä½ ...)");
                } else {
                    showThought(texts.idle[Math.floor(Math.random() * texts.idle.length)]);
                    // Simple idle anim
                    corgiBody.rotation.z = (Math.random()-0.5)*0.2;
                    setTimeout(()=>corgiBody.rotation.z=0, 500);
                }
            }
        }
    }

    // --- äº¤äº’ç‚¹å‡» ---
    window.addEventListener('pointerup', (e) => {
        if(e.button !== 0 || e.target.closest('.glass-panel') || e.target.closest('#chat-layer') || e.target.closest('#interaction-panel') || e.target.closest('#pet-selector') || e.target.closest('.modal-overlay')) return;

        mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse, camera);

        // 1. ä¼˜å…ˆæ£€æµ‹ç‚¹å‡»å® ç‰©
        const petHits = raycaster.intersectObjects(corgiGroup.children, true);
        if(petHits.length > 0) {
            const texts = PET_BEHAVIOR_TEXT[currentPet];
            showThought(texts.click[Math.floor(Math.random() * texts.click.length)]);
            
            // æ’’å¨‡åŠ¨ç”»
            corgiBody.position.y = 0.3;
            setTimeout(() => corgiBody.position.y = 0, 200);
            setTimeout(() => corgiBody.position.y = 0.3, 300);
            setTimeout(() => corgiBody.position.y = 0, 500);
            return;
        }

        // 2. ç‚¹å‡»åœ°é¢ç§»åŠ¨ (ä»…å½“æ²¡ç‚¹åˆ°å® ç‰©æ—¶)
        const hits = raycaster.intersectObject(ground);
        if(hits.length > 0) {
            let p = hits[0].point.clone();
            if(p.length() > WORLD_RADIUS - 1) { p.normalize().multiplyScalar(WORLD_RADIUS - 1); }
            for(let pond of ponds){
                const d = p.distanceTo(pond.position);
                if(d < pond.radius + 0.8){
                    const dir = p.clone().sub(pond.position).normalize();
                    p = pond.position.clone().add(dir.multiplyScalar(pond.radius + 1.2));
                }
            }
            targetPos.copy(p);
            targetRing.position.set(p.x, 0.05, p.z);
            targetRing.visible = true; targetRing.scale.set(0,0,0);
            if(targetRing.userData.anim) clearInterval(targetRing.userData.anim);
            let s=0; targetRing.userData.anim = setInterval(()=>{ s+=0.2; targetRing.scale.set(s,s,s); if(s>=1)clearInterval(targetRing.userData.anim);},16);
            currentState = STATE.RUN;
            // é‡ç½®è‡ªä¸»è¡Œä¸ºè®¡æ—¶ï¼Œé¿å…ç§»åŠ¨ä¸­è§¦å‘
            lastBehaviorTime = Date.now() * 0.001;
            lastOwnerInteractionTime = lastBehaviorTime;
            didWanderAfterOwnerIdle = false;
        }
    });

    // --- äº¤äº’é“å…· (Props) ---
    const propGroup = new THREE.Group();
    corgiGroup.add(propGroup);
    
    let propFood, propComb, propToy;
    
    function createProps() {
        // Food (Bone/Carrot)
        propFood = new THREE.Group();
        const fMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8), new THREE.MeshStandardMaterial({color: 0xFF5722}));
        fMesh.rotation.z = Math.PI/2;
        propFood.add(fMesh);
        const fBoneL = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshStandardMaterial({color: 0xFFCCBC}));
        fBoneL.position.x = -0.15; propFood.add(fBoneL);
        const fBoneR = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshStandardMaterial({color: 0xFFCCBC}));
        fBoneR.position.x = 0.15; propFood.add(fBoneR);
        propFood.visible = false; 
        // propFood will be attached to headGroup in attachPropsToPet

        // Comb
        propComb = new THREE.Group();
        const cHandle = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.1), new THREE.MeshStandardMaterial({color: 0x8D6E63}));
        propComb.add(cHandle);
        for(let i=0; i<6; i++) {
            const t = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.1, 0.02), new THREE.MeshStandardMaterial({color: 0xD7CCC8}));
            t.position.set(-0.1 + i*0.04, -0.08, 0);
            propComb.add(t);
        }
        propComb.visible = false;
        // propComb will be attached to corgiBody in attachPropsToPet

        // Toy (Ball)
        propToy = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), new THREE.MeshStandardMaterial({color: 0xFDD835}));
        propToy.visible = false;
        // propToy will be attached to headGroup in attachPropsToPet
    }
    createProps();

    // --- ç¯å¢ƒç”Ÿæˆ (Refined for Reference Image & User Requests) ---
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0xAED581, roughness: 1, flatShading: true })); 
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    const trees = []; 
    const bushes = [];
    var flowerInstances = [];
    var flowerStemMesh, flowerPetalMesh, flowerCenterMesh;
    const ponds = []; 
    const mushrooms = []; 
    
    // Helper to attach props after pet rebuild
    function attachPropsToPet() {
        if(!headGroup || !corgiBody) return;
        
        // Detach from previous parent if any
        if(propFood.parent) propFood.parent.remove(propFood);
        if(propComb.parent) propComb.parent.remove(propComb);
        if(propToy.parent) propToy.parent.remove(propToy);

        // Attach Food (Mouth) & Toy (Head Top) to Head
        headGroup.add(propFood);
        headGroup.add(propToy);
        
        // Attach Comb (Body) to Body
        corgiBody.add(propComb);

        // Set Positions based on Pet Type
        if(currentPet === 'corgi') {
            propFood.position.set(0, -0.2, 0.5);
            propToy.position.set(0, 0.45, 0);
            propComb.position.set(0, 0.5, 0);
        } else if(currentPet === 'rabbit') {
            propFood.position.set(0, -0.1, 0.3);
            propToy.position.set(0, 0.5, 0); // Between ears
            propComb.position.set(0, 0.4, 0);
        } else if(currentPet === 'cat') {
            propFood.position.set(0, -0.15, 0.35);
            propToy.position.set(0, 0.4, 0);
            propComb.position.set(0, 0.45, 0);
        }
        
        // Reset visibility (controlled by interact)
        propFood.visible = false;
        propComb.visible = false;
        propToy.visible = false;
    }

    var stones = [];
var maxTrunkTop = 2.5;
    function createNature() {
        const treeMat = new THREE.MeshStandardMaterial({color: 0x795548, flatShading:true});
        const leafMat = new THREE.MeshStandardMaterial({color: 0xA5D6A7, flatShading: true});
        const leafMat2 = new THREE.MeshStandardMaterial({color: 0x9CCC65, flatShading: true});
        const bushMat = new THREE.MeshStandardMaterial({color: 0x7CB342, flatShading:true});
        const pondMat = new THREE.MeshStandardMaterial({color: 0x29B6F6, roughness: 0.1, metalness: 0.1, opacity: 0.8, transparent: true});
        const mushStemMat = new THREE.MeshStandardMaterial({color: 0xFFE0B2});
        const mushCapMat = new THREE.MeshStandardMaterial({color: 0xE57373});

        // 4. Ponds (Generated first)
        const pondGeo = new THREE.CircleGeometry(4, 32);
        for(let i=0; i<5; i++) {
            const x=(Math.random()-0.5)*120, z=(Math.random()-0.5)*120;
            if(Math.abs(x)<10 && Math.abs(z)<10) continue;
            
            const pond = new THREE.Mesh(pondGeo, pondMat);
            pond.rotation.x = -Math.PI/2;
            pond.position.set(x, 0.02, z);
            pond.scale.set(1+Math.random(), 0.8+Math.random(), 1);
            scene.add(pond);
            ponds.push({ position: new THREE.Vector3(x, 0, z), radius: 4 * pond.scale.x });
            
            // Stones (Outside pond - Fixed position)
            for(let k=0; k<6; k++) {
                const stone = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3, 0), new THREE.MeshStandardMaterial({color:0x9E9E9E}));
                const a = (k/6)*Math.PI*2 + (Math.random()-0.5)*0.2;
                // Use ellipse radii to ensure outside
                const rx = 4 * pond.scale.x + 0.35;
                const rz = 4 * pond.scale.y + 0.35;
                
                stone.position.set(x + Math.cos(a)*rx, 0.05, z + Math.sin(a)*rz);
                stone.rotation.set(Math.random(), Math.random(), Math.random());
                scene.add(stone);
                stones.push({ position: stone.position.clone(), radius: 0.35 });
            }
        }

        // --- Instanced Trees ---
        const treeCount = 150; // Increased from 80
        // Geometries
        const trunkGeo = new THREE.CylinderGeometry(0.18, 0.24, 1.5, 8); 
        const branchGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.6, 6);
        const crownGeo = new THREE.IcosahedronGeometry(0.8, 0);

        // Instanced Meshes
        // Max estimations: Branches=2/tree, Base=8/tree (Increased for fuller crown), Mid=1/tree
        const trunkMesh = new THREE.InstancedMesh(trunkGeo, treeMat, treeCount);
        const branchMesh = new THREE.InstancedMesh(branchGeo, treeMat, treeCount * 2);
        const crownBaseMesh = new THREE.InstancedMesh(crownGeo, leafMat2, treeCount * 9); // Increased buffer
        const crownMidMesh = new THREE.InstancedMesh(crownGeo, leafMat, treeCount);

        trunkMesh.castShadow = true; trunkMesh.receiveShadow = true;
        branchMesh.castShadow = true; branchMesh.receiveShadow = true;
        crownBaseMesh.castShadow = true; crownBaseMesh.receiveShadow = true;
        crownMidMesh.castShadow = true; crownMidMesh.receiveShadow = true;

        scene.add(trunkMesh); scene.add(branchMesh); scene.add(crownBaseMesh); scene.add(crownMidMesh);

        let trunkIdx=0, branchIdx=0, baseIdx=0, midIdx=0;
        const dummyTree = new THREE.Group();
        const dTrunk = new THREE.Mesh(trunkGeo); dummyTree.add(dTrunk);
        const dB1 = new THREE.Mesh(branchGeo); dTrunk.add(dB1);
        const dB2 = new THREE.Mesh(branchGeo); dTrunk.add(dB2);
        const dCrown = new THREE.Group(); dummyTree.add(dCrown);
        const dMid = new THREE.Mesh(crownGeo); dCrown.add(dMid);
        const dSubs = [];
        for(let k=0; k<9; k++) { const s=new THREE.Mesh(crownGeo); dCrown.add(s); dSubs.push(s); }

        for(let i=0; i<treeCount; i++) { 
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 180;
            if(Math.abs(x)<5 && Math.abs(z)<5) continue; 
            let inPond = false;
            for(let p of ponds) {
                if(new THREE.Vector3(x,0,z).distanceTo(p.position) < p.radius + 2.0) { inPond = true; break; }
            }
            if(inPond) continue;

            // Setup dummy tree hierarchy
            const scaleH = 1.1 + (Math.random()-0.5) * 0.4; 
            dummyTree.position.set(x, 0, z);
            dummyTree.rotation.y = Math.random() * Math.PI * 2;
            dummyTree.scale.setScalar(1 + Math.random()*0.8);
            
            // Trunk
            dTrunk.position.y = 0.75 * scaleH;
            dTrunk.scale.set(1, scaleH, 1);
            
            // Branches
            dB1.position.set(0.12, 0.55 * scaleH, 0);
            dB1.rotation.set(-0.2, Math.random(), 0.45);
            dB2.position.set(-0.12, 0.55 * scaleH, 0);
            dB2.rotation.set(-0.2, dB1.rotation.y + Math.PI, -0.45);

            // Crown
            dCrown.position.y = 1.8 * scaleH;
            // Center crown with slight random jitter
            dMid.position.set((Math.random()-0.5)*0.05, 0.2 + (Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05);
            dMid.rotation.set((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3);
            dMid.scale.setScalar(1.0 + (Math.random()-0.5)*0.1);

            // Subs (Regular arrangement with controlled randomness)
            const baseCount = 8; 
            for(let k=0; k<9; k++) {
                if(k < baseCount) {
                    dSubs[k].visible = true;
                    
                    // Add small random jitter to angle and radius
                    const angleJitter = (Math.random() - 0.5) * 0.4; 
                    const radiusJitter = (Math.random() - 0.5) * 0.15;
                    const ang = (k/baseCount)*Math.PI*2 + angleJitter; 
                    const r = 0.6 + radiusJitter;
                    
                    // Add small random jitter to Y position
                    const yJitter = (Math.random() - 0.5) * 0.15;

                    dSubs[k].position.set(Math.cos(ang)*r, -0.35 + yJitter, Math.sin(ang)*r); 
                    
                    // Random rotation for natural look
                    dSubs[k].rotation.set(
                        (Math.random()-0.5)*0.6, 
                        (Math.random()-0.5)*0.6, 
                        (Math.random()-0.5)*0.6
                    );
                    
                    // Random scale jitter
                    const scaleJitter = (Math.random() - 0.5) * 0.15;
                    dSubs[k].scale.setScalar(0.85 + scaleJitter); 
                } else {
                    dSubs[k].visible = false;
                    dSubs[k].scale.setScalar(0); // Hide
                }
            }

            // Update matrices
            dummyTree.updateMatrixWorld(true);

            // Copy to instances
            trunkMesh.setMatrixAt(trunkIdx++, dTrunk.matrixWorld);
            branchMesh.setMatrixAt(branchIdx++, dB1.matrixWorld);
            branchMesh.setMatrixAt(branchIdx++, dB2.matrixWorld);
            crownMidMesh.setMatrixAt(midIdx++, dMid.matrixWorld);
            for(let k=0; k<baseCount; k++) {
                crownBaseMesh.setMatrixAt(baseIdx++, dSubs[k].matrixWorld);
            }

            trees.push({ position: new THREE.Vector3(x, 0, z), radius: 1.0 });
        }
        // Trim unused
        trunkMesh.count = trunkIdx;
        branchMesh.count = branchIdx;
        crownMidMesh.count = midIdx;
        crownBaseMesh.count = baseIdx;
        trunkMesh.instanceMatrix.needsUpdate = true;
        branchMesh.instanceMatrix.needsUpdate = true;
        crownMidMesh.instanceMatrix.needsUpdate = true;
        crownBaseMesh.instanceMatrix.needsUpdate = true;


        // --- Instanced Bushes ---
        const bushCount = 100; // Increased from 30
        const bushGeo = new THREE.IcosahedronGeometry(0.32, 1);
        const bushMesh = new THREE.InstancedMesh(bushGeo, bushMat, bushCount * 8); // 8 parts per bush

        bushMesh.castShadow = true; bushMesh.receiveShadow = true;
        scene.add(bushMesh);
        
        let bushIdx = 0;
        const dummyBush = new THREE.Group();
        const bParts = [];
        for(let i=0; i<8; i++) { const p=new THREE.Mesh(bushGeo); dummyBush.add(p); bParts.push(p); }

        for(let i=0; i<bushCount; i++) {
            const x=(Math.random()-0.5)*160, z=(Math.random()-0.5)*160;
            if(Math.abs(x)<5 && Math.abs(z)<5) continue;
            let nearPond=false; for(let p of ponds){ if(new THREE.Vector3(x,0,z).distanceTo(p.position) < p.radius + 0.5){ nearPond=true; break; } }
            if(nearPond) continue;

            dummyBush.position.set(x, 0.06, z);
            dummyBush.updateMatrixWorld(true);

            // Parts logic (4 base, 3 mid, 1 top)
            let partK = 0;
            // Base
            for(let j=0; j<4; j++) {
                const ang = (j/4)*Math.PI*2;
                bParts[partK].position.set(Math.cos(ang)*0.5 + (Math.random()-0.5)*0.05, 0.08, Math.sin(ang)*0.5 + (Math.random()-0.5)*0.05);
                bParts[partK].scale.setScalar(0.95 + (Math.random()*0.05));
                partK++;
            }
            // Mid
            for(let j=0; j<3; j++) {
                const ang = (j/3)*Math.PI*2 + 0.4;
                bParts[partK].position.set(Math.cos(ang)*0.35 + (Math.random()-0.5)*0.05, 0.26, Math.sin(ang)*0.35 + (Math.random()-0.5)*0.05);
                bParts[partK].scale.setScalar(0.9 + (Math.random()*0.05));
                partK++;
            }
            // Top
            bParts[partK].position.set((Math.random()-0.5)*0.1, 0.42 + Math.random()*0.05, (Math.random()-0.5)*0.1);
            bParts[partK].scale.setScalar(0.85 + (Math.random()*0.05));
            partK++;

            dummyBush.updateMatrixWorld(true);
            for(let k=0; k<8; k++) {
                bushMesh.setMatrixAt(bushIdx++, bParts[k].matrixWorld);
            }
            bushes.push({ position: new THREE.Vector3(x, 0.5, z), radius: 1.0 });
        }
        bushMesh.count = bushIdx;
        bushMesh.instanceMatrix.needsUpdate = true;

        // 3. Mountains (Distant Background) - Varied Distance for Fading
        const mountainColors = [
            0x1B5E20, 0x2E7D32, 0x388E3C, 0x43A047, 0x2BAF84
        ];
        // More mountains, spread out
        for(let i=0; i<24; i++) {
            const angle = (i / 24) * Math.PI * 2 + (Math.random()-0.5)*0.2;
            // Increase distance: 800 to 1800
            const r = 800 + Math.random() * 1000; 
            
            const s = (60 + Math.random() * 40) * 1.5;
            
            // Use StandardMaterial to react to Fog + Lights
            const mMat = new THREE.MeshStandardMaterial({ 
                color: mountainColors[Math.floor(Math.random()*mountainColors.length)],
                roughness: 0.9
            });
            
            const mGeom = new THREE.SphereGeometry(s, 16, 12, 0, Math.PI*2, 0, Math.PI/2);
            const m = new THREE.Mesh(mGeom, mMat);
            m.scale.set(1 + Math.random()*0.5, 1.2 + Math.random()*0.8, 1 + Math.random()*0.5); 
            m.position.set(Math.cos(angle)*r, -10, Math.sin(angle)*r);
            
            // Notch effect
            const posAttr = m.geometry.attributes.position;
            const notch = 0.15;
            for(let vi=0; vi<posAttr.count; vi++){
                const x = posAttr.getX(vi), y = posAttr.getY(vi), z = posAttr.getZ(vi);
                const yn = (y + s*0.0) / s;
                const g = 1 - notch * Math.exp(-((yn - 0.45)*(yn - 0.45))/0.02);
                posAttr.setX(vi, x * g);
                posAttr.setZ(vi, z * g);
            }
            posAttr.needsUpdate = true;
            scene.add(m);
        }

        // 5. Mushrooms (Instanced)
        const mushStemMatInst = new THREE.MeshStandardMaterial({color: 0xFFE0B2});
        const mushCapMatInst = new THREE.MeshStandardMaterial({color: 0xE57373});
        const mushStemGeo = new THREE.CylinderGeometry(0.03, 0.05, 0.15, 8);
        const mushCapGeo = new THREE.SphereGeometry(0.15, 16, 8, 0, Math.PI*2, 0, Math.PI/2);
        
        const mushCount = 10;
        const mushStemMesh = new THREE.InstancedMesh(mushStemGeo, mushStemMatInst, mushCount);
        const mushCapMesh = new THREE.InstancedMesh(mushCapGeo, mushCapMatInst, mushCount);
        scene.add(mushStemMesh); scene.add(mushCapMesh);
        
        let mushIdx = 0;
        const dummyMush = new THREE.Group();
        const dMStem = new THREE.Mesh(mushStemGeo); dMStem.position.y = 0.07; dummyMush.add(dMStem);
        const dMCap = new THREE.Mesh(mushCapGeo); dMCap.position.y = 0.15; dummyMush.add(dMCap);

        for(let i=0; i<mushCount; i++) {
             const x=(Math.random()-0.5)*80, z=(Math.random()-0.5)*80;
             if(Math.abs(x)<5 && Math.abs(z)<5) continue;
             
             dummyMush.position.set(x, 0, z);
             dummyMush.scale.setScalar(0.3 + Math.random()*0.3);
             dummyMush.updateMatrixWorld(true);
             
             mushStemMesh.setMatrixAt(mushIdx, dMStem.matrixWorld);
             mushCapMesh.setMatrixAt(mushIdx, dMCap.matrixWorld);
             mushIdx++;
             mushrooms.push({ position: new THREE.Vector3(x, 0, z) });
        }
        mushStemMesh.count = mushIdx; mushCapMesh.count = mushIdx;
        mushStemMesh.instanceMatrix.needsUpdate = true; mushCapMesh.instanceMatrix.needsUpdate = true;

        // 6. Flowers (Instanced)
        const flowerCount = 60; 
        const petalGeo = new THREE.CircleGeometry(0.08, 5);
        const centerGeo = new THREE.CircleGeometry(0.04, 8);
        const stemGeo = new THREE.CylinderGeometry(0.02, 0.02, 1, 8); // Base height 1

        const petalMat = new THREE.MeshBasicMaterial({side: THREE.DoubleSide, vertexColors: true}); 
        const centerMat = new THREE.MeshBasicMaterial({color:0xFFEB3B});
        const stemMat = new THREE.MeshStandardMaterial({color:0x4CAF50, roughness:0.8});

        flowerStemMesh = new THREE.InstancedMesh(stemGeo, stemMat, flowerCount);
        flowerPetalMesh = new THREE.InstancedMesh(petalGeo, petalMat, flowerCount * 5);
        flowerCenterMesh = new THREE.InstancedMesh(centerGeo, centerMat, flowerCount);

        scene.add(flowerStemMesh); scene.add(flowerPetalMesh); scene.add(flowerCenterMesh);
        
        const fColors = [0xFFFFFF, 0xFFC0CB, 0xFFB6C1]; 
        const _fColor = new THREE.Color();
        const fDummy = new THREE.Object3D();
        
        let fIdx = 0;
        let fPetalIdx = 0;
        
        for(let i=0; i<flowerCount; i++) {
            const x=(Math.random()-0.5)*80, z=(Math.random()-0.5)*80;
            if(Math.abs(x)<3 && Math.abs(z)<3) continue;
            let nearPond=false; for(let p of ponds){ if(new THREE.Vector3(x,0,z).distanceTo(p.position) < p.radius + 0.5){ nearPond=true; break; } }
            if(nearPond) continue;

            const stemH = 0.18 + Math.random()*0.12;
            const colorHex = fColors[Math.floor(Math.random()*fColors.length)];
            
            flowerInstances.push({
                position: new THREE.Vector3(x, 0, z),
                phi: Math.random()*Math.PI*2,
                theta: (Math.PI/6) + Math.random()*(Math.PI/3),
                stemH: stemH,
                color: colorHex
            });
            
            // Stem (Static)
            fDummy.position.set(x, stemH/2, z);
            fDummy.rotation.set(0,0,0);
            fDummy.scale.set(1, stemH, 1);
            fDummy.updateMatrix();
            flowerStemMesh.setMatrixAt(fIdx, fDummy.matrix);
            
            // Petals Color
            _fColor.setHex(colorHex);
            for(let p=0; p<5; p++) {
                flowerPetalMesh.setColorAt(fPetalIdx + p, _fColor);
            }
            
            fIdx++;
            fPetalIdx += 5;
        }
        
        flowerStemMesh.count = fIdx;
        flowerCenterMesh.count = fIdx;
        flowerPetalMesh.count = fPetalIdx;
        
        flowerStemMesh.instanceMatrix.needsUpdate = true;
        if (flowerPetalMesh.instanceColor) flowerPetalMesh.instanceColor.needsUpdate = true;
    }

    createNature();

    // --- å…‰ç…§ & Fog (Cyan-Green Atmosphere) ---
    const hemiLight = new THREE.HemisphereLight(0xE0F2F1, 0x1B5E20, 0.6); scene.add(hemiLight); // Cyan Sky, Green Ground
    const dirLight = new THREE.DirectionalLight(0xFFF176, 1.2); 
    dirLight.position.set(50, 80, 30); dirLight.castShadow = true; 
    dirLight.shadow.mapSize.set(512, 512);
        const d=80; dirLight.shadow.camera.left=-d; dirLight.shadow.camera.right=d; dirLight.shadow.camera.top=d; dirLight.shadow.camera.bottom=-d;
        dirLight.shadow.mapSize.set(512, 512);
    scene.add(dirLight);

    // Fog for "Fading Distance"
    // Fog extended to match new camera far plane for smoother fade
    scene.fog = new THREE.Fog(0xE0F7FA, 200, 1500);
    scene.background = new THREE.Color(0xE0F7FA);

    window.setWeather = function(type) {
        // Overridden by new static style for now, or adapt
        if(type==='sunny') { 
            scene.background.set(0xE0F7FA); 
            scene.fog.color.set(0xE0F7FA);
            dirLight.color.set(0xFFF176); 
            dirLight.intensity=1.2;
        }
        // ... (other weathers can be adapted later)
    }

    // --- Visual Effects & Time System ---
    let stars, fireflies, dust, rainSystem;
    const fishes = [];
    let envCounter = 0;
    
    function createVisualEffects() {
        // 1. Stars (Night only)
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1000; i++) {
            starPos.push((Math.random()-0.5)*600, 300 + Math.random()*300, (Math.random()-0.5)*600);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xFFFFFF, size: 0.35, transparent: true, opacity: 0, depthTest: true}));
        scene.add(stars);

        // 2. Fireflies (Night only)
        const fireflyGeo = new THREE.BufferGeometry();
        const fireflyPos = [];
        for(let i=0; i<50; i++) {
            fireflyPos.push((Math.random()-0.5)*100, 0.5+Math.random()*2, (Math.random()-0.5)*100);
        }
        fireflyGeo.setAttribute('position', new THREE.Float32BufferAttribute(fireflyPos, 3));
        // Store initial positions for animation
        fireflyGeo.userData = { initPos: [...fireflyPos] }; 
        fireflies = new THREE.Points(fireflyGeo, new THREE.PointsMaterial({color: 0xCCFF00, size: 0.15, transparent: true, opacity: 0}));
        scene.add(fireflies);

        // 3. Floating Dust (Day/Evening)
        const dustGeo = new THREE.BufferGeometry();
        const dustPos = [];
        for(let i=0; i<120; i++) {
            dustPos.push((Math.random()-0.5)*100, Math.random()*10, (Math.random()-0.5)*100);
        }
        dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
        dust = new THREE.Points(dustGeo, new THREE.PointsMaterial({color: 0xFFFFFF, size: 0.06, transparent: true, opacity: 0.6}));
        scene.add(dust);

        // 4. Rain (Occasional Light Rain) - Replaces God Rays
        const rainGeo = new THREE.BufferGeometry();
        const rainPos = [];
        for(let i=0; i<400; i++) { // Reduced from 1200 to 400
            rainPos.push((Math.random()-0.5)*150, Math.random()*100, (Math.random()-0.5)*150);
        }
        rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPos, 3));
        rainSystem = new THREE.Points(rainGeo, new THREE.PointsMaterial({
            color: 0xAAAAAA, 
            size: 0.1, 
            transparent: true, 
            opacity: 0
        }));
        scene.add(rainSystem);

        // 5. Fishes (Jumping)
        const fishGeo = new THREE.SphereGeometry(0.2, 8, 8); // Simple fish body
        const fishMat = new THREE.MeshStandardMaterial({color: 0xFF5722});
        
        ponds.forEach(pond => {
            const fish = new THREE.Group();
            const body = new THREE.Mesh(fishGeo, fishMat);
            body.scale.set(1, 0.4, 0.2);
            fish.add(body);
            
            // Tail
            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.2, 4), fishMat);
            tail.rotation.z = -Math.PI/2;
            tail.position.x = -0.25;
            fish.add(tail);

            fish.visible = false;
            fish.position.copy(pond.position);
            fish.userData = { 
                home: pond.position.clone(), 
                jumping: false, 
                velocity: new THREE.Vector3(),
                timer: 0 
            };
            
            scene.add(fish);
            fishes.push(fish);
        });
    }
    createVisualEffects();

    // --- Time & Environment Control ---
    // Real-time sync
    let gameTime = 0; 
    
    function updateEnvironment(dt) {
        envCounter++;
        // Sync with Real Time
        const now = new Date();
        const currentSeconds = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
        gameTime = currentSeconds / 86400; // 0.0 to 1.0

        // Shift time to match lighting phases
        // Current Phases: 0.0-0.2 (Sunrise), 0.2-0.6 (Day), 0.6-0.75 (Sunset), 0.75-1.0 (Night)
        // Real Time: 0.0 (Midnight). We want Night at Midnight.
        // So we need to map:
        // 6am (0.25) -> Sunrise Start (0.0)
        // 12pm (0.5) -> Day (0.4)
        // 6pm (0.75) -> Sunset Start (0.6)
        // 
        // Let's adjust the phases to match Real Time (0.0 = Midnight)
        // 0.0 - 0.25: Night
        // 0.25 - 0.35: Sunrise (6am-8am)
        // 0.35 - 0.7: Day
        // 0.7 - 0.8: Sunset (5pm-7pm)
        // 0.8 - 1.0: Night
        
        let t = gameTime;
        const hours = now.getHours();
        if(hours >= 17 && hours < 19) {
            t = 0.75; // Ensure sunset lighting at local 18:00
        }
        
        // Light Colors
        let skyColor, groundColor, sunColor, sunIntensity, fogColor;
        
        if(t >= 0.25 && t < 0.35) { // Sunrise (6am-8am)
            const p = (t-0.25)/0.1;
            skyColor = new THREE.Color().lerpColors(new THREE.Color(0x1A237E), new THREE.Color(0xFFCC80), p);
            groundColor = new THREE.Color(0x81C784);
            sunColor = new THREE.Color(0xFFE0B2);
            sunIntensity = 0.3 + p*0.7;
            fogColor = new THREE.Color().lerpColors(new THREE.Color(0x1A237E), new THREE.Color(0xFFE0B2), p);
            if(stars) stars.material.opacity = 1 - p;
        } else if(t >= 0.35 && t < 0.7) { // Day (8am-5pm)
            skyColor = new THREE.Color(0xE0F2F1);
            groundColor = new THREE.Color(0x1B5E20);
            sunColor = new THREE.Color(0xFFC107); // Golden Light
            sunIntensity = 1.3;
            fogColor = new THREE.Color(0xE0F7FA);
            if(stars) stars.material.opacity = 0;
        } else if(t >= 0.7 && t < 0.8) { // Sunset (5pm-7pm)
            const p = (t-0.7)/0.1;
            skyColor = new THREE.Color().lerpColors(new THREE.Color(0xE0F2F1), new THREE.Color(0xFFAB91), p);
            groundColor = new THREE.Color(0x33691E);
            sunColor = new THREE.Color(0xFF9800);
            sunIntensity = 1.0 - p*0.5;
            fogColor = new THREE.Color().lerpColors(new THREE.Color(0xE0F7FA), new THREE.Color(0xFFCC80), p);
            if(stars) stars.material.opacity = p;
        } else { // Night (7pm-6am)
            skyColor = new THREE.Color(0x1A237E);
            groundColor = new THREE.Color(0x000000);
            sunColor = new THREE.Color(0x5C6BC0); // Moon
            sunIntensity = 0.3;
            fogColor = new THREE.Color(0x1A237E);
            if(stars) stars.material.opacity = 0.8;
        }

        hemiLight.color.copy(skyColor);
        // hemiLight.groundColor.copy(groundColor); // Keep ground green-ish but darker? No, use calculated.
        // Actually ground material is fixed color 0xAED581. We should not change it or it looks weird.
        // But we can change light intensity.
        
        dirLight.color.copy(sunColor);
        dirLight.intensity = sunIntensity;
        scene.fog.color.copy(fogColor);
        scene.background.copy(fogColor);

        // Fireflies (Only at night)
        if(fireflies) {
             fireflies.material.opacity = (t > 0.75 || t < 0.1) ? 1 : 0;
             if(fireflies.material.opacity > 0 && envCounter % 6 === 0) { // Reduced update frequency
                 const time = Date.now() * 0.001;
                 const pos = fireflies.geometry.attributes.position;
                 const init = fireflies.geometry.userData.initPos;
                 for(let i=0; i<pos.count; i++) {
                     pos.setY(i, init[i*3+1] + Math.sin(time*2 + i)*0.5);
                     pos.setX(i, init[i*3] + Math.sin(time*0.5 + i)*0.5);
                 }
                 pos.needsUpdate = true;
             }
        }
        
        // Dust (Always visible but subtle)
        if(dust && envCounter % 5 === 0) { // Reduced update frequency
            const pos = dust.geometry.attributes.position;
            for(let i=0; i<pos.count; i++) {
                let y = pos.getY(i);
                y -= dt * 0.5; // Fall slowly
                if(y < 0) y = 10;
                pos.setY(i, y);
            }
            pos.needsUpdate = true;
        }
        
        // Rain (Occasional Light Rain)
        if(rainSystem && envCounter % 4 === 0) { // Reduced update frequency
             const pos = rainSystem.geometry.attributes.position;
             for(let i=0; i<pos.count; i++) {
                 let y = pos.getY(i);
                 y -= dt * 20; // Fast fall
                 if(y < 0) y = 100;
                 pos.setY(i, y);
             }
             pos.needsUpdate = true;
             
             // Simple weather cycle: Rain every 30s for 10s?
             // For now, just keep it light and constant for atmosphere
             rainSystem.material.opacity = 0.2; 
        }

        // Flower Sway (Instanced)
        if(flowerInstances && flowerInstances.length) {
            const time = Date.now() * 0.001;
            const dummy = new THREE.Object3D();
            const dummyPetal = new THREE.Object3D();
            
            let pIdx = 0;
            flowerInstances.forEach((f, i) => {
                const sway = Math.sin(time*1.5 + i) * 0.05;
                const currentTheta = f.theta + sway;
                
                // Head matrix
                dummy.position.set(f.position.x, f.stemH, f.position.z);
                dummy.rotation.set(Math.sin(f.phi) * currentTheta, 0, Math.cos(f.phi) * currentTheta);
                dummy.updateMatrix();
                
                // Update Center (child of Head)
                dummyPetal.position.set(0, 0.01, 0);
                dummyPetal.rotation.set(-Math.PI/2, 0, 0);
                dummyPetal.scale.set(1,1,1);
                dummyPetal.updateMatrix();
                
                const centerMat = dummy.matrix.clone().multiply(dummyPetal.matrix);
                flowerCenterMesh.setMatrixAt(i, centerMat);
                
                // Update Petals
                for(let p=0; p<5; p++) {
                    const ang = p*Math.PI*2/5;
                    dummyPetal.position.set(Math.cos(ang)*0.08, 0, Math.sin(ang)*0.08);
                    dummyPetal.rotation.set(-Math.PI/2, 0, 0);
                    dummyPetal.updateMatrix();
                    
                    const pMat = dummy.matrix.clone().multiply(dummyPetal.matrix);
                    flowerPetalMesh.setMatrixAt(pIdx++, pMat);
                }
            });
            flowerCenterMesh.instanceMatrix.needsUpdate = true;
            flowerPetalMesh.instanceMatrix.needsUpdate = true;
        }

        // Fish Jumping
        fishes.forEach(fish => {
            if(fish.userData.jumping) {
                // Physics
                fish.position.add(fish.userData.velocity.clone().multiplyScalar(dt));
                fish.userData.velocity.y -= 9.8 * dt; // Gravity
                
                // Rotate
                fish.rotation.z -= 2 * dt;

                if(fish.position.y < 0) {
                    fish.userData.jumping = false;
                    fish.visible = false;
                    fish.position.copy(fish.userData.home);
                }
            } else {
                // Random jump
                if(Math.random() < 0.002) { // Low chance per frame
                    fish.userData.jumping = true;
                    fish.visible = true;
                    fish.position.copy(fish.userData.home);
                    fish.userData.velocity.set((Math.random()-0.5)*2, 4, (Math.random()-0.5)*2);
                    fish.rotation.z = Math.PI/4;
                }
            }
        });
    }

    // --- åŠ¨ç”»å¾ªç¯ ---
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const dt = clock.getDelta();
        const ownerIdle = (time - lastOwnerInteractionTime) > OWNER_IDLE_THRESHOLD;

        updateEnvironment(dt);

        // æ›´æ–°è‡ªä¸»è¡Œä¸º
        updatePetBehavior(time);

        if(currentState === STATE.RUN) {
            const dist = dogPos.distanceTo(targetPos);
            
            // Stop if close enough (prevents spinning)
            if (dist < 0.3) {
                currentState = STATE.IDLE; targetRing.visible = false;
                legs.forEach(l=>l.rotation.x=0); corgiBody.position.y=0;
                runStateStart = 0; lastRunDist = Infinity; lastDistDecreaseTime = 0;
                return;
            }

            // 1. è½¬å‘é˜¶æ®µ (Turn Phase)
            const dx = targetPos.x - dogPos.x;
            const dz = targetPos.z - dogPos.z;
            const targetAngle = Math.atan2(dx, dz);

            let diff = targetAngle - corgiGroup.rotation.y;
            while(diff > Math.PI) diff -= Math.PI*2; 
            while(diff < -Math.PI) diff += Math.PI*2;
            
            // Turn if angle difference is significant
            if (Math.abs(diff) > 0.05) { 
                 const rotSpeed = 0.15; // Increased turn speed
                 corgiGroup.rotation.y += Math.sign(diff) * Math.min(Math.abs(diff), rotSpeed);
                 
                 // åŸåœ°è¸æ­¥åŠ¨ç”» (Stepping in place while turning)
                 const turnPhase = time * 15;
                 legs.forEach((leg, i) => {
                    leg.rotation.x = Math.sin(turnPhase + (i % 2 === 0 ? 0 : Math.PI)) * 0.3;
                 });
            } 
                // 2. ç§»åŠ¨é˜¶æ®µ (Move Phase) - STRICTLY only when aligned
            else if(dist > 0.1 && Math.abs(diff) <= 0.1) {
                // corgiGroup.rotation.y = targetAngle; // Smooth turn handles this, no snap needed
                
                let currentSpeed = dogSpeed;
                // Further reduced speeds per request
                if(currentPet === 'rabbit') currentSpeed *= 0.5; 
                else if(currentPet === 'cat') currentSpeed *= 0.6; 
                else currentSpeed *= 0.7;

                // Ensure we move in the direction we are FACING
                const forward = new THREE.Vector3(Math.sin(corgiGroup.rotation.y), 0, Math.cos(corgiGroup.rotation.y));
                const desired = targetPos.clone().sub(dogPos).normalize();
                const align = forward.dot(desired);
                // progress tracking to avoid getting stuck
                if(runStateStart === 0){
                    runStateStart = time;
                    lastRunDist = dist;
                    lastDistDecreaseTime = time;
                } else {
                    if(dist < lastRunDist - 0.01){ // progress epsilon
                        lastDistDecreaseTime = time;
                    }
                    lastRunDist = dist;
                }

                let alignThresh = 0.999;
                if(time - lastDistDecreaseTime > 3) { // stuck fallback
                    alignThresh = 0.95;
                    currentSpeed *= 0.8;
                }
                if(align < alignThresh) { 
                    // Not aligned enough: keep turning, do not move
                    return;
                }
                // Prevent backward/sideways drift: clamp step to positive projection
                const step = forward.clone().multiplyScalar(currentSpeed);
                if(step.dot(desired) <= 0) return;
                const nextPos = dogPos.clone().add(step);

                // Collision (Trees & Ponds)
                let collision = false;
                for(let tree of trees) {
                    const dx = nextPos.x - tree.position.x;
                    const dz = nextPos.z - tree.position.z;
                    if(Math.abs(dx) > 2.5 || Math.abs(dz) > 2.5) continue;
                    if(dx*dx + dz*dz < (tree.radius + 0.2)*(tree.radius + 0.2)) {
                        collision = true; break;
                    }
                }
                if(!collision) {
                    for(let pond of ponds) {
                        // Increased margin to prevent stepping over (Water + Stones)
                        if(nextPos.distanceTo(pond.position) < pond.radius + 0.8) {
                            collision = true; break;
                        }
                    }
                }

                // World boundary: prevent moving into far ocean/plain
                if(!collision && nextPos.length() > WORLD_RADIUS) {
                    collision = true;
                }

                if (collision) {
                    currentState = STATE.IDLE;
                    showThought("(è¿‡ä¸å»...)");
                    targetRing.visible = false;
                    // Bounce back slightly
                    const bounce = dogPos.clone().sub(nextPos).normalize().multiplyScalar(0.5);
                    dogPos.add(bounce);
                } else {
                    dogPos.copy(nextPos);
                    
                    // --- ä¸“å±è¡Œèµ°åŠ¨ç”» ---
                    if(currentPet === 'rabbit') {
                        // å…”å­: è·³è·ƒå¼å‰è¿›
                        const hopPhase = time * 15;
                        corgiBody.position.y = Math.abs(Math.sin(hopPhase)) * 0.25; 
                        // è€³æœµåå€’
                        if(corgiGroup.userData.ears) {
                             const earRot = -Math.abs(Math.sin(hopPhase)) * 0.5;
                             corgiGroup.userData.ears.forEach(e => e.rotation.x = earRot);
                        }
                        // Fixed: Legs stay attached to body
                        // legs.forEach(l => l.position.y = -0.1 + Math.abs(Math.sin(hopPhase))*0.08);

                    } else if(currentPet === 'cat') {
                        const walkPhase = time * 8;
                        const stepAmp = Math.min(0.5, Math.max(0.4, currentSpeed * 10));
                        legs.forEach((leg, i) => {
                            leg.rotation.x = Math.sin(walkPhase + (i%2===0?0:Math.PI)) * stepAmp;
                        });
                        corgiBody.position.y = Math.abs(Math.sin(walkPhase)) * Math.min(0.05, currentSpeed * 2.0);
                        corgiBody.rotation.y += Math.sin(walkPhase)*Math.min(0.005, currentSpeed * 0.3);
                        if(tail) {
                            tail.rotation.y = Math.sin(walkPhase * 0.5) * Math.min(0.3, currentSpeed * 10);
                            tail.rotation.x = 0.25;
                        }

            } else {
                // æŸ¯åŸº: æ¬¢å¿«å°è·‘ï¼ˆå§‹ç»ˆæ­£å‘ï¼‰
                const runPhase = time * 20;
                legs.forEach((leg, i) => {
                    leg.rotation.x = Math.sin(runPhase + (i%2===0?0:Math.PI)) * 0.8;
                });
                corgiBody.position.y = Math.abs(Math.sin(runPhase)) * 0.05;
                corgiBody.rotation.z = Math.sin(runPhase * 0.5) * 0.1; // å±è‚¡æ‰­
                headGroup.rotation.x = 0.1 + Math.abs(Math.sin(runPhase))*0.04;
                if(tail) tail.rotation.z = Math.sin(runPhase) * 0.8; // æ‘‡å°¾å·´
            }
                }
            }

        } else {
            // Idle State Logic - Short Range Exploration
            if (ownerIdle && Math.random() < 0.002) {
                const center = new THREE.Vector3(camera.position.x, 0, camera.position.z);
                const angle = Math.random() * Math.PI * 2;
                const dist = 0.5 + Math.random() * 2.0;
                const dest = center.clone().add(new THREE.Vector3(Math.cos(angle)*dist, 0, Math.sin(angle)*dist));
                
                // Ensure we don't go too far from center/camera focus if needed, 
                // but here we just check validity.
                if(isValidPos(dest)) {
                    targetPos.copy(dest);
                    currentState = STATE.RUN;
                    if(Math.random() < 0.3) showThought("(åˆ°å¤„çœ‹çœ‹...)");
                    return;
                }
            }

            // Idle Animations (Sit, Beg, Sniff)
            corgiBody.scale.y = 1;
            if(tail) tail.rotation.z = Math.sin(time*5)*0.2;
            
            // Ear Wiggle (Idle)
            if(corgiGroup.userData.ears && Math.random() < 0.02) {
                corgiGroup.userData.ears.forEach(ear => {
                     ear.rotation.z += (Math.random()-0.5)*0.2; 
                     setTimeout(()=> ear.rotation.z = 0, 200); 
                });
            }
        }

        corgiGroup.position.copy(dogPos);
        if(corgiBody.position.y < 0) corgiBody.position.y = 0;
        
        // ç›¸æœºè·Ÿéš & è·ç¦»ä¿æŒ
        const targetCam = dogPos.clone().add(new THREE.Vector3(0, 0.6, 0));
        controls.target.lerp(targetCam, 0.6);
        
        const camDist = camera.position.distanceTo(controls.target);
        let minCamDist = 1.5; 
        let maxCamDist = 3.0;
        
        // Limit Camera Height (Tree top max)
        if (camera.position.y > maxTrunkTop) camera.position.y = maxTrunkTop;
        if (camera.position.y < 0.5) camera.position.y = 0.5;

        // Limit Camera Angle (Pitch)
        controls.minPolarAngle = 0.1; // Don't look from directly above/below
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Don't go below ground

        // äº¤äº’æ—¶æ‹‰è¿‘é•œå¤´
        if (currentState === STATE.BUSY) {
            minCamDist = 1.5;
            maxCamDist = 3.0;
        }
        
        if(camDist < minCamDist) {
             const dir = camera.position.clone().sub(controls.target).normalize();
             camera.position.lerp(controls.target.clone().add(dir.multiplyScalar(minCamDist)), 0.5);
        } else if(camDist > maxCamDist) {
             const dir = camera.position.clone().sub(controls.target).normalize();
             camera.position.lerp(controls.target.clone().add(dir.multiplyScalar(maxCamDist)), 0.5);
        }
        
        {
            let nearest=null, minD=Infinity;
            for(let i=0;i<ponds.length;i++){
                const p=ponds[i];
                const d=controls.target.distanceTo(p.position);
                if(d<minD){minD=d;nearest=p;}
            }
            if(nearest){
                const angleToPond=Math.atan2(nearest.position.x - controls.target.x, nearest.position.z - controls.target.z);
                if(typeof controls.getAzimuthalAngle==='function' && typeof controls.rotateLeft==='function'){
                    let az=controls.getAzimuthalAngle();
                    let diff=angleToPond - az;
                    while(diff>Math.PI) diff-=Math.PI*2;
                    while(diff<-Math.PI) diff+=Math.PI*2;
                    const avoid=0.25;
                    if(Math.abs(diff)<avoid){
                        controls.rotateLeft(Math.sign(diff)*(avoid - Math.abs(diff)));
                    }
                }
                const camVec=new THREE.Vector3(camera.position.x - nearest.position.x, 0, camera.position.z - nearest.position.z);
                const distCam=camVec.length();
                const minDist=nearest.radius + 1.2;
                if(distCam<minDist){
                    camVec.normalize().multiplyScalar(minDist);
                    camera.position.x = nearest.position.x + camVec.x;
                    camera.position.z = nearest.position.z + camVec.z;
                }
            }
        }
        controls.update();

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    }
    window.initThreeScene = initThreeScene;
    if (window.THREE) { initThreeScene(); }
</script>
</body>
</html>
