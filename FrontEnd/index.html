<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>æ­å­è®¡åˆ’</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #87CEEB; 
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif; 
            user-select: none; -webkit-user-select: none;
        }

        /* --- å·¦ä¸Šè§’ï¼šæ—¥ç¨‹ä¸å¤©æ°” (é«˜é€æ˜ç£¨ç ‚) --- */
        #sidebar {
            position: absolute; top: 20px; left: 20px; width: 240px;
            display: flex; flex-direction: column; gap: 10px; z-index: 10;
            pointer-events: none; /* å®¹å™¨ç©¿é€ */
        }

        .glass-panel {
            /* æé«˜é€æ˜åº¦ */
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px; padding: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            pointer-events: auto; transition: transform 0.2s, background 0.3s;
            color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .glass-panel:hover { transform: translateY(-2px); background: rgba(255, 255, 255, 0.35); }

        /* å¤©æ°”æ  */
        .weather-row { display: flex; justify-content: space-around; font-size: 18px; }
        .weather-icon { cursor: pointer; opacity: 0.6; transition: 0.3s; }
        .weather-icon:hover, .weather-icon.active { opacity: 1; transform: scale(1.2); text-shadow: 0 0 10px yellow; }

        /* æ—¥ç¨‹åˆ—è¡¨ */
        .panel-header { font-size: 13px; font-weight: 800; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 4px; display: flex; justify-content: space-between;}
        #schedule-list { list-style: none; padding: 0; margin: 0; max-height: 200px; overflow-y: auto; }
        #schedule-list::-webkit-scrollbar { display: none; }
        #schedule-list li { 
            font-size: 11px; color: #fff; margin-bottom: 5px; padding: 6px; 
            background: rgba(0,0,0,0.2); border-radius: 8px; 
            border-left: 3px solid #81D4FA; display: flex; flex-direction: column;
            position: relative; animation: slideIn 0.3s ease;
        }
        .time-badge { font-weight: bold; color: #81D4FA; font-size: 10px; margin-bottom: 2px; }
        .del-btn { position: absolute; right: 5px; top: 5px; color: rgba(255,255,255,0.6); cursor: pointer; font-size: 10px; }
        .del-btn:hover { color: #FF5252; }

        /* --- åº•éƒ¨ï¼šç”Ÿæˆå¼å¯¹è¯ UI --- */
        #chat-layer {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 500px;
            display: flex; flex-direction: column; justify-content: flex-end;
            gap: 10px; z-index: 20; pointer-events: none;
        }

        /* èŠå¤©æµ (æç®€é€æ˜) */
        #chat-history {
            display: flex; flex-direction: column; gap: 8px; 
            margin-bottom: 10px; padding-right: 5px;
            align-items: center; /* å±…ä¸­æ˜¾ç¤º */
        }
        
        .msg {
            max-width: 90%; padding: 8px 16px; border-radius: 20px; font-size: 13px; line-height: 1.5;
            backdrop-filter: blur(4px); pointer-events: auto; 
            animation: slideUp 0.4s ease;
            text-align: center;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            transition: opacity 1s, transform 1s; /* æ·¡å‡ºåŠ¨ç”» */
        }
        
        .msg-user { background: rgba(33, 150, 243, 0.4); color: white; border: 1px solid rgba(255,255,255,0.2); }
        .msg-ai { background: rgba(255, 255, 255, 0.25); color: white; border: 1px solid rgba(255,255,255,0.3); }
        
        /* æ­£åœ¨æ¶ˆå¤±çš„ç±» */
        .fading-out { opacity: 0; transform: translateY(-10px) scale(0.9); }

        /* ç”Ÿæˆå¼å¡ç‰‡å®¹å™¨ */
        #card-deck {
            display: flex; gap: 10px; overflow-x: auto; padding: 5px; pointer-events: auto;
            justify-content: center; min-height: 5px;
        }
        #card-deck::-webkit-scrollbar { display: none; }

        .activity-card {
            min-width: 140px; 
            background: rgba(255,255,255,0.2); backdrop-filter: blur(10px);
            border-radius: 12px; padding: 10px; border: 1px solid rgba(255,255,255,0.4);
            display: flex; flex-direction: column; gap: 4px;
            cursor: pointer; transition: 0.2s; animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .activity-card:hover { transform: translateY(-5px); background: rgba(255,255,255,0.4); }
        .act-time { font-size: 10px; color: #FFD54F; font-weight: bold; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 4px; align-self: flex-start;}
        .act-title { font-size: 13px; font-weight: bold; }
        .act-desc { font-size: 11px; opacity: 0.9; }
        .act-add { 
            margin-top: 5px; background: rgba(76, 175, 80, 0.6); color: white; border: 1px solid rgba(255,255,255,0.3); 
            padding: 4px; border-radius: 6px; font-size: 11px; cursor: pointer; text-align: center;
            transition: 0.2s;
        }
        .act-add:hover { background: rgba(76, 175, 80, 0.9); }

        /* è¾“å…¥æ¡† (æé€æ˜) */
        .input-box {
            background: rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px);
            border-radius: 25px; padding: 5px 5px 5px 15px;
            display: flex; align-items: center; pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.2);
        }
        input { 
            flex: 1; border: none; background: transparent; outline: none; font-size: 14px; color: white; 
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        input::placeholder { color: rgba(255,255,255,0.6); }
        .btn-send {
            width: 36px; height: 36px; border-radius: 50%; border: none;
            background: rgba(255, 255, 255, 0.2); color: white; font-size: 16px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: 0.2s;
        }
        .btn-send:hover { transform: scale(1.1); background: rgba(255, 255, 255, 0.4); }
        .btn-send.loading { animation: spin 1s infinite linear; content: 'â³'; }

        @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes popIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* è­¦å‘Šå¼¹çª— */
        .toast {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            color: white; padding: 10px 20px; border-radius: 8px;
            font-size: 14px; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 200;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.35);
            backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 300;
        }
        .modal-content {
            width: 90%; max-width: 360px; border-radius: 16px; padding: 16px;
            background: rgba(255,255,255,0.25); color: white; border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .modal-title { font-size: 16px; font-weight: 800; }
        .modal-close { cursor: pointer; font-size: 18px; opacity: 0.8; }
        .modal-close:hover { opacity: 1; }
        .modal-time { font-size: 12px; color: #FFD54F; margin-bottom: 6px; }
        .modal-desc { font-size: 12px; opacity: 0.9; }
        .modal-actions { display: flex; gap: 8px; margin-top: 12px; }
        .btn-primary { flex: 1; text-align: center; padding: 8px; border-radius: 10px; cursor: pointer; background: rgba(76,175,80,0.7); border: 1px solid rgba(255,255,255,0.3); }
        .btn-primary:hover { background: rgba(76,175,80,0.9); }
        .btn-secondary { flex: 1; text-align: center; padding: 8px; border-radius: 10px; cursor: pointer; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); }
        .btn-secondary:hover { background: rgba(255,255,255,0.35); }

        /* --- å® ç‰©é€‰æ‹©å™¨ --- */
        #pet-selector {
            position: absolute; top: 20px; right: 20px;
            display: flex; gap: 10px; z-index: 100;
        }
        .pet-option {
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(255,255,255,0.3); border: 2px solid rgba(255,255,255,0.5);
            backdrop-filter: blur(4px); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; transition: 0.3s; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .pet-option:hover, .pet-option.active {
            background: rgba(255,255,255,0.8); transform: scale(1.1); border-color: #fff;
        }

        /* --- å® ç‰©çŠ¶æ€é¢æ¿ (New) --- */
    #pet-status-panel {
        position: absolute; top: 20px; left: 270px; /* ä½äºå·¦ä¾§è¾¹æ å³ä¾§ */
        width: 200px; z-index: 10;
        display: flex; flex-direction: column; gap: 8px;
    }
    .status-bar-row {
        display: flex; align-items: center; gap: 8px; font-size: 12px; color: #fff;
    }
    .status-label { width: 40px; text-align: right; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
    .progress-bg {
        flex: 1; height: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;
        border: 1px solid rgba(255,255,255,0.2);
    }
    .progress-fill { height: 100%; transition: width 0.5s, background-color 0.5s; }
    
    /* äº¤äº’æŒ‰é’®ç»„ */
    #interaction-panel {
        position: absolute; bottom: 180px; right: 20px;
        display: flex; flex-direction: column; gap: 10px; z-index: 50;
    }
    .interact-btn {
        width: 50px; height: 50px; border-radius: 50%;
        background: rgba(255,255,255,0.3); backdrop-filter: blur(5px);
        border: 2px solid rgba(255,255,255,0.6);
        font-size: 24px; cursor: pointer;
        display: flex; align-items: center; justify-content: center;
        transition: 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    .interact-btn:hover { transform: scale(1.1); background: rgba(255,255,255,0.8); }
    .interact-btn:active { transform: scale(0.95); }
    /* å® ç‰©æƒ³æ³•æ°”æ³¡ (ä½äºå¤©ç©ºä¸­å¤®) */
    #pet-thoughts {
        position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
        z-index: 80; pointer-events: none;
        display: flex; flex-direction: column; align-items: center;
        opacity: 0; transition: opacity 0.5s;
    }
    .thought-bubble {
        background: rgba(255, 255, 255, 0.9); padding: 10px 20px;
        border-radius: 20px; font-size: 14px; color: #333;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        position: relative;
    }
    .thought-bubble::after {
        content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
        border-width: 8px 8px 0; border-style: solid;
        border-color: rgba(255, 255, 255, 0.9) transparent transparent transparent;
    }
    </style>
    <style>
        /* Pet Selection Modal */
        .pet-select-container {
            display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;
        }
        .pet-select-card {
            background: rgba(255,255,255,0.9); padding: 20px; border-radius: 16px;
            width: 120px; text-align: center; cursor: pointer;
            border: 2px solid transparent; transition: all 0.3s;
        }
        .pet-select-card:hover { transform: translateY(-5px); box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .pet-select-card.selected { border-color: #7E57C2; background: #EDE7F6; }
        .pet-select-icon { font-size: 40px; margin-bottom: 10px; }
        .pet-select-name { font-weight: bold; color: #555; }
    </style>
</head>
<body oncontextmenu="return false;">

<!-- è­¦å‘Š/æç¤ºå¼¹çª— -->
<div id="login-modal" class="modal-overlay" style="display:flex; z-index: 1000;">
    <div class="modal-content" style="text-align:center; width: 340px;">
        <h2 id="auth-title" style="margin-bottom:10px;">æ¬¢è¿æ¥åˆ°ç–—æ„ˆç©ºé—´</h2>
        <p id="auth-subtitle" style="margin-bottom: 20px; font-size: 13px; opacity: 0.8;">è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç å¼€å¯æ‚¨çš„ä¸“å±æ—…ç¨‹</p>
        
        <input type="email" id="login-email" placeholder="your@email.com" list="email-history" style="width:85%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.5); background:rgba(255,255,255,0.2); color:white; margin-bottom:10px; outline:none;">
        <datalist id="email-history"></datalist>

        <input type="password" id="login-pass" placeholder="Password" style="width:85%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.5); background:rgba(255,255,255,0.2); color:white; margin-bottom:20px; outline:none;">
        
        <div class="btn-primary" id="btn-auth" onclick="handleAuth()" style="margin: 0 auto; width: 120px; margin-bottom: 15px;">è¿›å…¥ç©ºé—´</div>
        
        <div style="font-size: 12px; opacity: 0.9;">
            <span id="toggle-text">è¿˜æ²¡æœ‰è´¦å·ï¼Ÿ</span>
            <span id="toggle-btn" onclick="toggleAuthMode()" style="text-decoration: underline; cursor: pointer; font-weight: bold; color: #E0F2F1;">ç«‹å³æ³¨å†Œ</span>
        </div>
    </div>
</div>

<div id="pet-selection-modal" class="modal-overlay" style="z-index: 600;">
    <div class="modal-content" style="max-width: 500px; text-align: center;">
        <div class="modal-header" style="justify-content: center;">
            <div class="modal-title">é€‰æ‹©ä½ çš„ä¼™ä¼´</div>
        </div>
        <div style="margin: 20px 0; color: #666;">æ¯ä¸ªä¼™ä¼´éƒ½æ˜¯ç‹¬ä¸€æ— äºŒçš„ï¼Œå®ƒå°†å’Œä½ ä¸€èµ·æˆé•¿ã€‚</div>
        <div class="pet-select-container">
            <div class="pet-select-card" onclick="selectInitialPet('corgi', this)">
                <div class="pet-select-icon">ğŸ¶</div>
                <div class="pet-select-name">æŸ¯åŸº</div>
            </div>
            <div class="pet-select-card" onclick="selectInitialPet('cat', this)">
                <div class="pet-select-icon">ğŸ±</div>
                <div class="pet-select-name">å°èŠ±çŒ«</div>
            </div>
            <div class="pet-select-card" onclick="selectInitialPet('rabbit', this)">
                <div class="pet-select-icon">ğŸ°</div>
                <div class="pet-select-name">å°ç™½å…”</div>
            </div>
        </div>
        <div id="confirm-pet-btn" class="btn-primary" style="margin: 20px auto 0; width: 150px; opacity: 0.5; pointer-events: none;" onclick="confirmInitialPet()">ç¡®å®šé€‰æ‹©</div>
    </div>
</div>

<div id="message-modal" class="modal-overlay" style="z-index: 500;">
    <div class="modal-content" style="text-align: center;">
        <div class="modal-header" style="justify-content: center;">
            <div id="msg-title" class="modal-title">æç¤º</div>
            <div class="modal-close" style="position: absolute; right: 20px;" onclick="closeMessageModal()">Ã—</div>
        </div>
        <div id="msg-content" class="modal-desc" style="font-size: 14px; margin: 15px 0;">å†…å®¹</div>
        <div class="btn-primary" onclick="closeMessageModal()" style="margin: 0 auto; width: 100px;">ç¡®å®š</div>
    </div>
</div>

<!-- å® ç‰©é€‰æ‹©å™¨ -->
<div id="pet-selector">
    <div class="pet-option active" onclick="selectPet('corgi')" title="æŸ¯åŸº">ğŸ¶</div>
    <div class="pet-option" onclick="selectPet('rabbit')" title="å°ç™½å…”">ğŸ°</div>
    <div class="pet-option" onclick="selectPet('cat')" title="å°èŠ±çŒ«">ğŸ±</div>
</div>

<!-- å® ç‰©çŠ¶æ€é¢æ¿ -->
<div id="pet-status-panel">
    <div class="status-bar-row">
        <div class="status-label">å¿ƒæƒ…</div>
        <div class="progress-bg"><div id="bar-mood" class="progress-fill" style="width: 80%; background: #FFB74D;"></div></div>
    </div>
    <div class="status-bar-row">
        <div class="status-label">å¥åº·</div>
        <div class="progress-bg"><div id="bar-health" class="progress-fill" style="width: 90%; background: #81C784;"></div></div>
    </div>
    <div class="status-bar-row">
        <div class="status-label">é“ä¸½</div>
        <div class="progress-bg"><div id="bar-gloss" class="progress-fill" style="width: 70%; background: #64B5F6;"></div></div>
    </div>
</div>

<!-- äº¤äº’æŒ‰é’®ç»„ -->
<div id="interaction-panel">
    <div class="interact-btn" onclick="interact('feed')" title="å–‚é£Ÿ">ğŸ–</div>
    <div class="interact-btn" onclick="interact('groom')" title="æ¢³æ¯›">ğŸ§¶</div>
    <div class="interact-btn" onclick="interact('play')" title="ç©è€">ğŸ¥</div>
</div>

<!-- å® ç‰©æƒ³æ³•æ°”æ³¡ (ä½äºèŠå¤©çª—å£ä¸Šæ–¹) -->
<div id="pet-thoughts">
    <div id="thought-text" class="thought-bubble">...</div>
</div>

<!-- å·¦ä¾§è¾¹æ  -->
<div id="sidebar">
    <!-- å¤©æ°”æ§åˆ¶ (Removed per user request) -->
    <!-- <div class="glass-panel weather-row"> ... </div> -->

    <!-- æ—¥ç¨‹è¡¨ -->
    <div class="glass-panel">
        <div class="panel-header">
            <span>ğŸ“… æ­å­è®¡åˆ’</span>
            <span style="font-weight:normal; font-size:10px; opacity:0.8" id="task-count">0/5</span>
        </div>
        <div id="empty-hint" style="font-size:11px; opacity:0.7; text-align:center; padding:10px;">å‘Šè¯‰æˆ‘ä½ çš„å¿ƒæƒ…...</div>
        <ul id="schedule-list"></ul>
    </div>
</div>

<!-- åº•éƒ¨ç”Ÿæˆå¼ UI -->
<div id="chat-layer">
    <div id="chat-history">
        <!-- æ¶ˆæ¯ä¼šåœ¨è¿™é‡Œç”Ÿæˆï¼Œå¹¶è‡ªåŠ¨æ¶ˆå¤± -->
        <div class="msg msg-ai" id="intro-msg">å—¨ï¼æˆ‘æ˜¯ä½ çš„ç–—æ„ˆå°ç‹—ã€‚ä»Šå¤©æ„Ÿè§‰æ€ä¹ˆæ ·ï¼Ÿ</div>
    </div>
    
    <!-- åŠ¨æ€ç”Ÿæˆçš„å¡ç‰‡æµ -->
    <div id="card-deck"></div>

    <div class="input-box">
        <input type="text" id="user-input" placeholder="è¾“å…¥æƒ³æ³• (å¦‚: æœ‰ç‚¹ç´¯)..." autocomplete="off">
        <button class="btn-send" onclick="sendMessage()">â¤</button>
    </div>
</div>

<div id="logout-btn" style="position: absolute; top: 20px; right: 20px; z-index: 400; background: rgba(255,255,255,0.4); padding: 8px 15px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(5px); font-size: 13px; color: #555; transition: all 0.3s;" onclick="logout()">
    é€€å‡ºç™»å½•
</div>
<div id="wallet-btn" style="position: absolute; top: 20px; right: 110px; z-index: 400; background: rgba(255,255,255,0.4); padding: 8px 15px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(5px); font-size: 13px; color: #555; transition: all 0.3s;" onclick="connectWallet()">
    è¿æ¥é’±åŒ…
</div>
<style>
    #logout-btn:hover { background: rgba(255,255,255,0.8); transform: translateY(-2px); }
    #wallet-btn:hover { background: rgba(255,255,255,0.8); transform: translateY(-2px); }
</style>

<div id="activity-modal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
        <div id="modal-title" class="modal-title"></div>
            <div class="modal-close" onclick="closeActivityModal()">Ã—</div>
        </div>
        <div id="modal-time" class="modal-time"></div>
        <div id="modal-time-picker" class="modal-time-picker" style="display:none;">
            <div id="modal-duration-row" style="display:flex; flex-direction:column; gap:8px;">
                <div style="font-size:12px; opacity:0.9;">ä½ æƒ³å®‰æ’å¤šä¹…ï¼Ÿ</div>
                <div id="modal-duration-options" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
            </div>
            <div id="modal-time-options-row" style="display:none; flex-direction:column; gap:8px; margin-top:10px;">
                <div style="font-size:12px; opacity:0.9;">ç»™ä½ ä¸€äº›ç©ºé—²æ—¶é—´é€‰é¡¹ï¼š</div>
                <div id="modal-time-options" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
            </div>
        </div>
        <div id="modal-desc" class="modal-desc"></div>
        <div class="modal-actions">
            <div id="modal-add" class="btn-primary">æ·»åŠ åˆ°æ—¥ç¨‹</div>
            <div class="btn-secondary" onclick="closeActivityModal()">ç¨å</div>
        </div>
    </div>
</div>

<script>
    (function(){
        function loadScript(src){
            return new Promise(function(resolve){
                var s=document.createElement('script');
                s.src=src; s.async=true;
                s.onload=function(){ resolve(true); };
                s.onerror=function(){ resolve(false); };
                document.head.appendChild(s);
            });
        }
        async function ensureSolanaWeb3(){
            if(window.solanaWeb3) return true;
            const cdns = [
                'https://unpkg.com/@solana/web3.js@1.95.4/lib/index.iife.min.js',
                'https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.4/lib/index.iife.min.js'
            ];
            for(let src of cdns){
                const ok = await loadScript(src);
                if(ok && window.solanaWeb3) return true;
            }
            return false;
        }
        async function ensureThree(){
            if(window.THREE) return true;
            let loaded=false;
            // Prefer local first (no HEAD probing to avoid abort logs)
            if(await loadScript('./lib/three.min.js')){ loaded=!!window.THREE; }
            if(!loaded){
                const threeCDNs = [
                    'https://unpkg.com/three@0.128.0/build/three.min.js',
                    'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js'
                ];
                for(let src of threeCDNs){
                    const ok = await loadScript(src);
                    if(ok && window.THREE){ loaded=true; break; }
                }
            }
            if(!loaded){ console.warn('Three.js not loaded, running in text-only mode'); return false; }
            let ctrlLoaded=false;
            if(await loadScript('./lib/OrbitControls.js')){ ctrlLoaded=!!THREE.OrbitControls; }
            if(!ctrlLoaded){
                const ctrlCDNs = [
                    'https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js',
                    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js'
                ];
                for(let src of ctrlCDNs){
                    const ok = await loadScript(src);
                    if(ok && THREE.OrbitControls){ ctrlLoaded=true; break; }
                }
            }
            return loaded && ctrlLoaded;
        }
        window.__ensureThree = ensureThree;
        window.__ensureSolanaWeb3 = ensureSolanaWeb3;
    })();
</script>

<script>
    if(!window.THREE){
        try{ document.getElementById('intro-msg').innerText = 'ä¸‰ç»´åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'; }catch(e){}
    }
    // è‡ªåŠ¨æ¸…ç†åˆå§‹æ¶ˆæ¯
    setTimeout(() => {
        const intro = document.getElementById('intro-msg');
        if(intro) {
            intro.classList.add('fading-out');
            setTimeout(() => intro.remove(), 1000);
        }
    }, 5000);

    // ==========================================
    // 1. é€»è¾‘æ ¸å¿ƒ (æ—¥ç¨‹ & Gemini API)
    // ==========================================
    
    // --- æ—¥ç¨‹ç®¡ç† ---
    const schedule = []; 

    function timeToMin(timeStr) {
        const [h, m] = timeStr.split(':').map(Number);
        return h * 60 + m;
    }

    function checkConflict(newStart, newEnd) {
        for (let item of schedule) {
            if (newStart < item.end && newEnd > item.start) {
                return true;
            }
        }
        return false;
    }

    function addScheduleItem(title, timeStr, type) {
        const times = timeStr.split('-');
        if (times.length !== 2) return;
        
        const startMin = timeToMin(times[0]);
        const endMin = timeToMin(times[1]);

        if (checkConflict(startMin, endMin)) {
            showToast(`âš ï¸ å†²çªï¼æ—¶æ®µ ${timeStr} å·²å ç”¨`);
            return false;
        }

        schedule.push({ title, start: startMin, end: endMin, timeStr, type });
        schedule.sort((a, b) => a.start - b.start); 
        
        renderScheduleUI();
        showToast("âœ… å·²æ·»åŠ : " + title);
        
        // Do NOT clear cards here, per user request
        // document.getElementById('card-deck').innerHTML = '';
        
        return true;
    }

    function minToTime(min) {
        const h = Math.floor(min / 60) % 24;
        const m = min % 60;
        return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
    }

    function buildFreeSlots(fromMin) {
        const dayStart = 8 * 60;
        const dayEnd = 23 * 60;
        const start = Math.max(dayStart, Math.min(fromMin, dayEnd));
        const busy = schedule.slice().sort((a, b) => a.start - b.start);
        const slots = [];
        let cursor = start;
        for (const b of busy) {
            if (b.end <= cursor) continue;
            if (b.start > cursor) {
                const s = cursor;
                const e = Math.min(b.start, dayEnd);
                if (e - s >= 15) slots.push({ start: s, end: e });
            }
            cursor = Math.max(cursor, b.end);
            if (cursor >= dayEnd) break;
        }
        if (cursor < dayEnd && dayEnd - cursor >= 15) {
            slots.push({ start: cursor, end: dayEnd });
        }
        return slots;
    }

    function summarizeFreeSlots(slots) {
        if (!slots.length) return 'æˆ‘çœ‹ä½ ä»Šå¤©å‰©ä½™çš„ç©ºé—²æ—¶é—´ä¸å¤šäº†ã€‚';
        const shown = slots.slice(0, 3).map(s => `${minToTime(s.start)}-${minToTime(s.end)}`).join('ï¼Œ');
        return `æˆ‘çœ‹åˆ°ä½ ç›®å‰ç©ºé—²ï¼š${shown}${slots.length > 3 ? 'â€¦' : ''}`;
    }

    function getSuggestedDurations(act) {
        const t = ((act && act.title) ? act.title : '') + ' ' + ((act && act.desc) ? act.desc : '');
        if (/(ç”µå½±|å½±ç‰‡|è§‚å½±)/.test(t)) return [90, 120];
        if (/(è¿åŠ¨|å¼€åˆè·³|è·‘æ­¥|å¥èº«)/.test(t)) return [20, 30, 45];
        if (/(å†¥æƒ³|å‘¼å¸|ç™½å™ªéŸ³)/.test(t)) return [10, 15, 20];
        if (/(æ´—æ¾¡|çƒ­æ°´æ¾¡)/.test(t)) return [20, 30, 40];
        if (/(æ•´ç†|æ¡Œé¢|æ–­èˆç¦»)/.test(t)) return [15, 30, 45];
        if (/(è¯»ä¹¦|è¯»å‡ é¡µ|ä¹¦åº—|ä¹¦)/.test(t)) return [10, 20, 30];
        if (/(æ¶ˆæ¯|æœ‹å‹|è”ç³»|å‘ä¿¡æ¯)/.test(t)) return [5, 10, 15];
        if (/(è®°å½•|å†™ä¸‹|æ—¥è®°|ä¹¦å†™)/.test(t)) return [10, 15, 20];
        if (/(å’–å•¡|æ•£æ­¥|å¥–åŠ±|åƒç‚¹)/.test(t)) return [30, 45, 60];
        return [15, 30, 45];
    }

    function proposeTimeOptions(slots, durationMin, limit = 8) {
        const opts = [];
        const step = 15;
        for (const slot of slots) {
            for (let s = slot.start; s + durationMin <= slot.end; s += step) {
                const e = s + durationMin;
                opts.push(`${minToTime(s)}-${minToTime(e)}`);
                if (opts.length >= limit) return opts;
            }
        }
        return opts;
    }

    function suggestFreeTimeAfterActivities(activities) {
        const now = new Date();
        const nowMin = now.getHours() * 60 + now.getMinutes();
        const slots = buildFreeSlots(nowMin + 5);
        const summary = summarizeFreeSlots(slots);
        const first = activities && activities.length ? activities[0] : null;
        const durs = getSuggestedDurations(first);
        const hint = durs && durs.length ? `ä½ æƒ³å®‰æ’å¤šä¹…æ¯”è¾ƒåˆé€‚ï¼Ÿæ¯”å¦‚ ${durs.join('/')} åˆ†é’Ÿã€‚` : 'ä½ æƒ³å®‰æ’å¤šä¹…æ¯”è¾ƒåˆé€‚ï¼Ÿ';
        addMessage(`${summary}ã€‚${hint}`, 'ai', false);
    }

    function hasValidTimeStr(timeStr) {
        if (!timeStr || typeof timeStr !== 'string') return false;
        const parts = timeStr.split('-');
        if (parts.length !== 2) return false;
        const parse = (t) => {
            const seg = t.split(':');
            if (seg.length !== 2) return NaN;
            const h = Number(seg[0]);
            const m = Number(seg[1]);
            if (!Number.isFinite(h) || !Number.isFinite(m)) return NaN;
            if (h < 0 || h > 23 || m < 0 || m > 59) return NaN;
            return h * 60 + m;
        };
        const s = parse(parts[0]);
        const e = parse(parts[1]);
        if (!Number.isFinite(s) || !Number.isFinite(e)) return false;
        return e > s;
    }

    // --- Pet Traits & Persistence ---
    function generatePetTraits() {
        return {
            bodyScale: 0.95 + Math.random() * 0.1,
            headScale: 0.9 + Math.random() * 0.2,
            earScale: 0.85 + Math.random() * 0.3,
            legLen: 0.9 + Math.random() * 0.2
        };
    }

    // --- Pet Selection System ---
    let selectedPetType = null;
    window.selectInitialPet = function(type, el) {
        selectedPetType = type;
        document.querySelectorAll('.pet-select-card').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
        const btn = document.getElementById('confirm-pet-btn');
        btn.style.opacity = '1';
        btn.style.pointerEvents = 'auto';
    }

    window.confirmInitialPet = async function() {
        if(!selectedPetType || !currentUser) return;
        
        let updates = {};

        // Check if user selected the SAME pet type as saved
        if(currentUser.petConfig && currentUser.petConfig.type === selectedPetType) {
            // Restore saved pet (Keep growth)
            restorePet(currentUser.petConfig);
            document.getElementById('pet-selection-modal').style.display = 'none';
            showToast(`æ¬¢è¿å›æ¥ï¼Œä½ çš„${selectedPetType==='corgi'?'æŸ¯åŸº':selectedPetType==='cat'?'å°çŒ«':'å…”å­'}ä¸€ç›´åœ¨ç­‰ä½ ã€‚`);
            return; // No DB update needed
        } else {
            // New Pet Type Selected -> Reset Growth & Traits
            // Randomize initial size (0.8 ~ 1.2)
            const sizeMult = 0.8 + Math.random() * 0.4;
            updates = {
                petConfig: { type: selectedPetType, traits: generatePetTraits() },
                petGrowth: { level: 1, exp: 0, sizeMultiplier: sizeMult }
            };
        }

        try {
            const res = await fetch(`${API_BASE}/user/update`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ email: currentUser.email, updates })
            });
            if(res.ok) {
                currentUser = { ...currentUser, ...updates };
                document.getElementById('pet-selection-modal').style.display = 'none';
                restorePet(currentUser.petConfig);
                showToast(`é¢†å…»æˆåŠŸï¼ä½ çš„${selectedPetType==='corgi'?'æŸ¯åŸº':selectedPetType==='cat'?'å°çŒ«':'å…”å­'}æ¥äº†ã€‚`);
            } else {
                showToast("ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•");
            }
        } catch(e) {
            console.error(e);
            showToast("ç½‘ç»œé”™è¯¯");
        }
    }

    window.restorePet = function(config) {
        if(!config || !config.type) return;
        
        // Hide selector if fixed pet
        if(currentUser && currentUser.petConfig) {
             const selector = document.getElementById('pet-selector');
             if(selector) selector.style.display = 'none';
        }

        const allowed = ['corgi','rabbit','cat'];
        currentPet = allowed.includes(config.type) ? config.type : 'corgi';
        if(!window.THREE || !window.corgiGroup){
            window.pendingPetConfig = config;
            const btn = document.querySelector(`.pet-option[onclick="selectPet('${currentPet}')"]`);
            if(btn){
                document.querySelectorAll('.pet-option').forEach(el => el.classList.remove('active'));
                btn.classList.add('active');
            }
            return;
        }
        window.corgiGroup.userData.traits = config.traits || generatePetTraits();
        document.querySelectorAll('.pet-option').forEach(el => el.classList.remove('active'));
        const btn = document.querySelector(`.pet-option[onclick="selectPet('${currentPet}')"]`);
        if(btn) btn.classList.add('active');
        rebuildPet();
    }

    function rebuildPet() {
        if(!window.THREE || !window.corgiGroup) return;
        const type = currentPet;
        let baseScale = 1;
        if(type === 'corgi') baseScale = 0.525; 
        else baseScale = 0.6;

        if(currentUser && currentUser.petGrowth && currentUser.petGrowth.sizeMultiplier) {
             baseScale *= currentUser.petGrowth.sizeMultiplier;
        }

        const traits = window.corgiGroup.userData.traits || generatePetTraits();
        window.corgiGroup.scale.setScalar(baseScale * traits.bodyScale);

        if(type === 'corgi' && window.createCorgi) window.createCorgi();
        else if(type === 'rabbit' && window.createRabbit) window.createRabbit();
        else if(type === 'cat' && window.createCat) window.createCat();
        else if(window.createCorgi) window.createCorgi();
        
        window.dogPos.set(0,0,0);
        window.corgiGroup.position.set(0,0,0);
        window.corgiBody.position.set(0,0,0);
        window.corgiBody.rotation.set(0,0,0);
        
        // Force center position for now (User request)
        /*
        if(currentUser && currentUser.lastPosition) {
            const lp = currentUser.lastPosition;
            if(typeof lp.x === 'number' && typeof lp.z === 'number') {
                const px = lp.x;
                const py = typeof lp.y === 'number' ? lp.y : 0;
                const pz = lp.z;
                window.dogPos.set(px, py, pz);
                window.corgiGroup.position.set(px, py, pz);
                if(typeof lp.rot === 'number') {
                    if(typeof window.setPetYaw === 'function') window.setPetYaw(lp.rot);
                    else window.__pendingPetYaw = lp.rot;
                }
                if(window.camera && window.controls && window.THREE) {
                    const ty = py + 0.6;
                    window.controls.target.set(px, ty, pz);
                    const angle = typeof lp.rot === 'number' ? lp.rot : 0;
                    const dir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                    const camBase = new THREE.Vector3(px, ty + 2.5, pz);
                    const camPos = camBase.add(dir.multiplyScalar(-4));
                    window.camera.position.copy(camPos);
                }
            }
        }
        */

        if(typeof attachPropsToPet === 'function') attachPropsToPet();
    }

    function removeScheduleItem(index) {
        schedule.splice(index, 1);
        renderScheduleUI();
    }

    function renderScheduleUI() {
        const list = document.getElementById('schedule-list');
        const empty = document.getElementById('empty-hint');
        const count = document.getElementById('task-count');
        
        list.innerHTML = '';
        if(schedule.length === 0) empty.style.display = 'block';
        else empty.style.display = 'none';

        schedule.forEach((item, index) => {
            const li = document.createElement('li');
            li.innerHTML = `
                <div class="time-badge">${item.timeStr}</div>
                <div>${item.title}</div>
                <span class="del-btn" onclick="removeScheduleItem(${index})">Ã—</span>
            `;
            list.appendChild(li);
        });
        count.innerText = `${schedule.length}/8`;
    }

    function showToast(msg, title="æç¤º") {
        const m = document.getElementById('message-modal');
        document.getElementById('msg-title').innerText = title;
        document.getElementById('msg-content').innerText = msg;
        m.style.display = 'flex';
    }
    
    function closeMessageModal() {
        document.getElementById('message-modal').style.display = 'none';
    }

    if(!window.petStatus){ window.petStatus = { mood: 80, health: 90, gloss: 75 }; }
    var petStatus = window.petStatus;
    if(typeof updateStatusUI !== 'function'){
        function updateStatusUI(){
            var m=document.getElementById('bar-mood'); if(m) m.style.width = window.petStatus.mood + '%';
            var h=document.getElementById('bar-health'); if(h) h.style.width = window.petStatus.health + '%';
            var g=document.getElementById('bar-gloss'); if(g) g.style.width = window.petStatus.gloss + '%';
        }
    }

    function __getQueryParam(name){
        try{
            const u = new URL(window.location.href);
            const v = u.searchParams.get(name);
            return v ? String(v) : '';
        } catch(e) { return ''; }
    }

    function __shortKey(pkStr){
        if(!pkStr || pkStr.length < 8) return pkStr || '';
        return pkStr.slice(0, 4) + 'â€¦' + pkStr.slice(-4);
    }

    async function __ensureSolanaReady(){
        if(window.solanaWeb3) return true;
        if(window.__ensureSolanaWeb3) return await window.__ensureSolanaWeb3();
        return false;
    }

    function __getSolanaRpcUrl(){
        const cluster = (__getQueryParam('cluster') || '').toLowerCase();
        if(cluster === 'localnet') return 'http://127.0.0.1:8899';
        if(cluster === 'mainnet') return 'https://api.mainnet-beta.solana.com';
        return 'https://api.devnet.solana.com';
    }

    function __getProgramIdStr(){
        const fromQuery = __getQueryParam('programId');
        if(fromQuery) return fromQuery;
        try{
            const v = localStorage.getItem('iri_program_id');
            return v ? String(v) : '';
        } catch(e) { return ''; }
    }

    function __setWalletBtnText(text){
        const b = document.getElementById('wallet-btn');
        if(b) b.innerText = text;
    }

    window.connectWallet = async function(){
        const ok = await __ensureSolanaReady();
        if(!ok){
            showToast('æ— æ³•åŠ è½½ Solana SDKï¼Œè¯·æ£€æŸ¥ç½‘ç»œ', 'é’±åŒ…');
            return;
        }
        if(!window.solana || !window.solana.isPhantom){
            showToast('æœªæ£€æµ‹åˆ° Phantom é’±åŒ…æ‰©å±•', 'é’±åŒ…');
            return;
        }
        try{
            const resp = await window.solana.connect();
            window.__walletPubkeyStr = resp && resp.publicKey ? resp.publicKey.toBase58() : '';
            if(!window.__walletPubkeyStr) throw new Error('No publicKey');
            __setWalletBtnText('é’±åŒ… ' + __shortKey(window.__walletPubkeyStr));
            if(typeof window.__refreshOnchainPetStatus === 'function') window.__refreshOnchainPetStatus(true);
        } catch(e){
            showToast('è¿æ¥é’±åŒ…å¤±è´¥', 'é’±åŒ…');
        }
    };

    // --- Backend Integration ---
    const API_BASE = window.location.protocol === 'file:' ? 'http://localhost:3000/api' : '/api';
    let currentUser = null;

    // Auth Logic
    let isRegister = false;

    window.logout = async function() {
        if(!confirm('ç¡®å®šè¦é€€å‡ºç™»å½•å—ï¼Ÿ')) return;
        
        // Save current position state before logout
        if(currentUser && window.corgiGroup) {
            try {
                const pos = window.dogPos || window.corgiGroup.position;
                const rot = window.corgiGroup.rotation.y;
                await fetch(`${API_BASE}/user/update`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        email: currentUser.email, 
                        updates: { 
                            lastPosition: { x: pos.x, y: pos.y, z: pos.z, rot: rot } 
                        } 
                    })
                });
            } catch(e) { console.error("Save pos failed", e); }
        }

        currentUser = null;
        document.getElementById('login-modal').style.display = 'flex';
        // Clear scene or just reset?
        // Resetting schedule and chat
        document.getElementById('chat-history').innerHTML = '';
        schedule.length = 0;
        renderScheduleUI();
        // Hide UI
        document.getElementById('pet-selection-modal').style.display = 'none';
        showToast("å·²é€€å‡ºç™»å½•");
    }
    
    function toggleAuthMode() {
        isRegister = !isRegister;
        const title = document.getElementById('auth-title');
        const sub = document.getElementById('auth-subtitle');
        const btn = document.getElementById('btn-auth');
        const txt = document.getElementById('toggle-text');
        const tBtn = document.getElementById('toggle-btn');
        
        if(isRegister) {
            title.innerText = "æ³¨å†Œæ–°è´¦å·";
            sub.innerText = "åˆ›å»ºæ‚¨çš„ä¸“å±ç–—æ„ˆç©ºé—´";
            btn.innerText = "ç«‹å³æ³¨å†Œ";
            txt.innerText = "å·²æœ‰è´¦å·ï¼Ÿ";
            tBtn.innerText = "ç›´æ¥ç™»å½•";
        } else {
            title.innerText = "æ¬¢è¿æ¥åˆ°ç–—æ„ˆç©ºé—´";
            sub.innerText = "è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç å¼€å¯æ‚¨çš„ä¸“å±æ—…ç¨‹";
            btn.innerText = "è¿›å…¥ç©ºé—´";
            txt.innerText = "è¿˜æ²¡æœ‰è´¦å·ï¼Ÿ";
            tBtn.innerText = "ç«‹å³æ³¨å†Œ";
        }
    }

    function loadAuthHistory() {
        const history = JSON.parse(localStorage.getItem('auth_history') || '[]');
        const dl = document.getElementById('email-history');
        if(dl) {
            dl.innerHTML = '';
            history.forEach(email => {
                const op = document.createElement('option');
                op.value = email;
                dl.appendChild(op);
            });
            if(history.length > 0) {
                const input = document.getElementById('login-email');
                if(input) input.value = history[0];
            }
        }
    }
    setTimeout(loadAuthHistory, 500); // Wait for DOM

    if(!window.handleAuth){ window.handleAuth = function(){ alert('æ­£åœ¨åŠ è½½ï¼Œè¯·ç¨å€™'); }; }

    async function handleAuth() {
        const email = document.getElementById('login-email').value.trim();
        const password = document.getElementById('login-pass').value.trim();
        if(!email || !password) return alert('è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ');
        
        const endpoint = isRegister ? '/auth/register' : '/auth/login';

        try {
            const res = await fetch(`${API_BASE}${endpoint}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ email, password })
            });
            const data = await res.json();
            if(!res.ok) throw new Error(data.error || 'æ“ä½œå¤±è´¥');

            // Save history
            let history = JSON.parse(localStorage.getItem('auth_history') || '[]');
            history = history.filter(e => e !== email);
            history.unshift(email);
            if(history.length > 5) history.pop();
            localStorage.setItem('auth_history', JSON.stringify(history));

            currentUser = data.user;
            document.getElementById('login-modal').style.display = 'none';
            
            // Session Reset: Clear Chat & Mood
            document.getElementById('chat-history').innerHTML = ''; 
            addMessage(`æ¬¢è¿å›æ¥, ${currentUser.email}ã€‚ä»Šå¤©æƒ³èŠç‚¹ä»€ä¹ˆï¼Ÿ`, 'ai', false);
            showToast(`æ¬¢è¿å›æ¥, ${currentUser.email}`);

            // Reset Mood/Status to defaults for new session
            petStatus.mood = 80; 
            petStatus.health = 90;
            petStatus.gloss = 75;
            updateStatusUI();

            if(window.THREE && typeof restorePet==='function'){
                if(currentUser.petConfig && currentUser.petConfig.type) {
                    // User has a pet -> Restore directly
                    restorePet(currentUser.petConfig);
                } else {
                    // User has NO pet (New User) -> Show Selection Modal
                    const m = document.getElementById('pet-selection-modal');
                    if(m) m.style.display = 'flex';
                }
            } else if(window.THREE && typeof selectPet==='function'){
                selectPet('corgi');
            }

            if(currentUser.schedule) {
                schedule.length = 0;
                currentUser.schedule.forEach(s => schedule.push(s));
                renderScheduleUI();
            }

        } catch(e) {
            console.error(e);
            alert((isRegister ? 'æ³¨å†Œå¤±è´¥: ' : 'ç™»å½•å¤±è´¥: ') + e.message);
        }
    }

    async function loadChatHistory() {
        if(!currentUser) return;
        try {
            const res = await fetch(`${API_BASE}/chat/history?email=${currentUser.email}`);
            const chats = await res.json();
            const recent = chats.slice(-5); 
            document.getElementById('chat-history').innerHTML = ''; // Clear first
            recent.forEach(msg => {
                addMessage(msg.text, msg.sender === 'user' ? 'user' : 'ai', false);
            });
        } catch(e) { console.error(e); }
    }

    async function saveUserData(updates) {
        if(!currentUser) return;
        try {
            await fetch(`${API_BASE}/user/update`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ email: currentUser.email, updates })
            });
            currentUser = { ...currentUser, ...updates };
        } catch(e) { console.error("Save failed", e); }
    }

    function addMessage(text, type, autoFade=false) {
        const container = document.getElementById('chat-history');
        const div = document.createElement('div');
        div.className = `msg msg-${type}`;
        div.innerText = text;
        container.appendChild(div);

        // Keep only last 5 messages visible
        while(container.children.length > 5) {
            container.removeChild(container.firstChild);
        }
    }
    let currentPet = 'corgi';
    const PET_BEHAVIOR_TEXT = {
        corgi: { 
            idle: ["åˆ°å¤„é—»é—»...", "è¿½å°¾å·´...", "æ±ªï¼Ÿ"],
            click: ["(ç–¯ç‹‚æ‘‡å°¾å·´)", "æ±ªæ±ªï¼æŠ±æŠ±ï¼", "(åœ¨åœ°ä¸Šæ‰“æ»š)"],
            move: "å“’å“’å“’è·‘è¿‡å»ï¼"
        },
        rabbit: { 
            idle: ["åŠ¨åŠ¨è€³æœµ...", "æ¸…ç†æ¯›å‘...", "å‘å‘†..."],
            click: ["(æŠ–åŠ¨é¼»å­)", "å˜¤å˜¤...", "(å¾€ä½ æ€€é‡Œé’»)"],
            move: "è¹¦è¹¦è·³è·³ï¼"
        },
        cat: { 
            idle: ["èˆ”çˆªå­...", "ä¼¸æ‡’è…°...", "ç›¯ç€æŸå¤„..."],
            click: ["å–µ~ (å‘¼å™œå£°)", "åˆ«çƒ¦æˆ‘... (ä½†æ²¡èµ°å¼€)", "(è¹­è¹­ä½ çš„è…¿)"],
            move: "ä¼˜é›…åœ°èµ°å¼€..."
        }
    };

    const PET_PERSONALITY = {
        corgi: { type: "energetic", sniffChance: 0.016, probeChance: 0.012 }, 
        rabbit: { type: "timid", sniffChance: 0.01, probeChance: 0.01 }, 
        cat: { type: "arrogant", sniffChance: 0.012, probeChance: 0.016 } 
    };

    // --- æ¶ˆæ¯å¤„ç† ---
    async function sendMessage() {
        const input = document.getElementById('user-input');
        const btn = document.querySelector('.btn-send');
        const text = input.value.trim();
        if (!text) return;
        lastOwnerInteractionTime = Date.now() * 0.001;
        didWanderAfterOwnerIdle = false;

        // 1. æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
        addMessage(text, 'user');
        input.value = '';
        btn.classList.add('loading');
        btn.innerText = '';

        // 2. è°ƒç”¨ Backend AI
        try {
            let data;
            if (currentUser && API_BASE) {
                const res = await fetch(`${API_BASE}/chat/message`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        email: currentUser.email, 
                        message: text,
                        petType: currentPet
                    })
                });
                data = await res.json();
            } else {
                data = await mockResponse(text);
            }
            
            // 3. å¤„ç†è¿”å›
            btn.classList.remove('loading');
            btn.innerText = 'â¤';
            addMessage(data.reply, 'ai');
            
            if (data.activities && data.activities.length > 0) {
                renderCards(data.activities);
            }
            if (data.weather) setWeather(data.weather);

        } catch(e) {
            console.error(e);
            btn.classList.remove('loading');
            btn.innerText = 'â¤';
            addMessage("(æœåŠ¡è¿æ¥å¤±è´¥...)", 'ai');
        }
    }

    function mockResponse(text) {
         return Promise.resolve().then(() => {
            let reply = "æˆ‘å¬åˆ°äº†ä½ çš„å¿ƒå£°ã€‚ç”Ÿæ´»æ€»ä¼šæœ‰èµ·ä¼ï¼Œè¯•ç€æ·±å‘¼å¸ï¼Œæ„Ÿå—å½“ä¸‹çš„å¹³é™ã€‚";
            let weather = "sunset";
            let activities = [];
            
            const petNames = { corgi: "æŸ¯åŸº", rabbit: "å°ç™½å…”", cat: "å°çŒ«" };
            const pName = petNames[currentPet] || "å® ç‰©";

            if (text.includes("å®ƒ") || text.includes("å® ç‰©") || text.includes("ç‹—") || text.includes("å…”") || text.includes("çŒ«")) {
                if(text.includes("å–œæ¬¢")) {
                    reply = `${pName}æœ€å–œæ¬¢ä½ çš„é™ªä¼´äº†ï¼Œå½“ç„¶è¿˜æœ‰ç¾å‘³çš„é›¶é£Ÿå’Œèˆ’æœçš„æŠšæ‘¸ã€‚`;
                } else if(text.includes("å¹²ä»€ä¹ˆ") || text.includes("åœ¨åš")) {
                    reply = `${pName}æ­£äº«å—ç€æ‚ é—²çš„æ—¶å…‰å‘¢ï¼Œå¯èƒ½åœ¨å‘å‘†ï¼Œä¹Ÿå¯èƒ½åœ¨æƒ³ä½ ã€‚`;
                } else {
                    reply = `${pName}ä¼¼ä¹å¾ˆåœ¨æ„ä½ ï¼Œå®ƒä¼šä¸€ç›´é™é™åœ°é™ªç€ä½ ã€‚`;
                }
                weather = "sunny";
            }
            else if (text.includes("ç´¯") || text.includes("çƒ¦") || text.includes("éš¾è¿‡") || text.includes("å‹åŠ›")) {
                reply = "çœ‹èµ·æ¥ä½ æœ€è¿‘æ‰¿æ‹…äº†å¾ˆå¤šã€‚è¯·å…è®¸è‡ªå·±åœä¸‹æ¥ä¼‘æ¯ä¸€ä¼šå„¿ï¼Œä½ å·²ç»åšå¾—å¾ˆå¥½äº†ã€‚æŠ±æŠ±è‡ªå·±ã€‚";
                weather = "night";
            } else if (text.includes("å¼€å¿ƒ") || text.includes("å¥½") || text.includes("æ£’") || text.includes("é¡º")) {
                reply = "çœŸä¸ºä½ æ„Ÿåˆ°é«˜å…´ï¼ä¿æŒè¿™ç§ç§¯æçš„çŠ¶æ€ï¼Œä¸–ç•Œä¹Ÿä¼šå˜å¾—æ˜äº®èµ·æ¥ã€‚";
                weather = "sunny";
                activities = [{ title: "è®°å½•ç¾å¥½", time: "Now", desc: "å†™ä¸‹æ­¤åˆ»çš„å¼€å¿ƒç¬é—´ã€‚" }];
            }

            return { reply, activities, weather };
        });
    }

    function addMessage(text, type, autoFade=true) {
        const container = document.getElementById('chat-history');
        const div = document.createElement('div');
        div.className = `msg msg-${type}`;
        div.innerText = text;
        container.appendChild(div);

        if(autoFade) {
            setTimeout(() => {
                div.classList.add('fading-out');
                setTimeout(() => div.remove(), 1000); 
            }, 5000);
        } else {
             setTimeout(() => {
                div.classList.add('fading-out');
                setTimeout(() => div.remove(), 1000); 
            }, 8000); 
        }
    }

    function renderCards(activities) {
        const deck = document.getElementById('card-deck');
        deck.innerHTML = '';
        
        activities.forEach(act => {
            const timeDisplay = hasValidTimeStr(act.time) ? act.time : 'æ—¶é—´å¾…å®š';
            const card = document.createElement('div');
            card.className = 'activity-card';
            card.innerHTML = `
                <div class="act-time">${timeDisplay}</div>
                <div class="act-title">${act.title}</div>
                <div class="act-desc">${act.desc}</div>
                <div class="act-add">ï¼‹</div>
            `;
            card.onclick = () => {
                openActivityModal(act, card);
            };
            const addBtn = card.querySelector('.act-add');
            addBtn.onclick = (e) => {
                e.stopPropagation();
                if (hasValidTimeStr(act.time)) {
                    const success = addScheduleItem(act.title, act.time, 'TODO');
                    if (success) {
                        card.style.transform = 'scale(0)';
                        setTimeout(() => card.remove(), 300);
                    }
                } else {
                    openActivityModal(act, card);
                }
            };
            deck.appendChild(card);
        });
        suggestFreeTimeAfterActivities(activities);
    }

    function openActivityModal(act, cardElement = null) {
        const overlay = document.getElementById('activity-modal');
        const titleEl = document.getElementById('modal-title');
        const timeEl = document.getElementById('modal-time');
        const descEl = document.getElementById('modal-desc');
        const timePicker = document.getElementById('modal-time-picker');
        const durationRow = document.getElementById('modal-duration-row');
        const durationOptions = document.getElementById('modal-duration-options');
        const timeOptionsRow = document.getElementById('modal-time-options-row');
        const timeOptions = document.getElementById('modal-time-options');
        titleEl.innerText = act.title || '';
        descEl.innerText = act.desc || '';

        const hasTime = hasValidTimeStr(act.time);
        let selectedTimeStr = hasTime ? act.time : null;
        if (hasTime) {
            timeEl.innerText = act.time;
            if (timePicker) timePicker.style.display = 'none';
        } else {
            timeEl.innerText = 'æˆ‘å¸®ä½ ä»ç©ºé—²æ—¶é—´é‡Œé€‰';
            if (timePicker) timePicker.style.display = 'block';
            if (durationRow) durationRow.style.display = 'flex';
            if (durationOptions) durationOptions.innerHTML = '';
            if (timeOptionsRow) timeOptionsRow.style.display = 'none';
            if (timeOptions) timeOptions.innerHTML = '';

            const now = new Date();
            const nowMin = now.getHours() * 60 + now.getMinutes();
            const freeSlots = buildFreeSlots(nowMin + 5);
            const durations = getSuggestedDurations(act);
            let selectedDuration = null;

            const renderTimeChoices = (durationMin) => {
                if (!timeOptionsRow || !timeOptions) return;
                timeOptionsRow.style.display = 'flex';
                timeOptions.innerHTML = '';
                selectedTimeStr = null;
                const options = proposeTimeOptions(freeSlots, durationMin, 10);
                if (!options.length) {
                    const b = document.createElement('div');
                    b.className = 'btn-secondary';
                    b.style.flex = '1';
                    b.style.opacity = '0.9';
                    b.innerText = 'æ²¡æœ‰è¶³å¤Ÿçš„ç©ºé—²æ—¶é—´';
                    timeOptions.appendChild(b);
                    return;
                }
                options.forEach(opt => {
                    const b = document.createElement('div');
                    b.className = 'btn-secondary';
                    b.style.padding = '6px 10px';
                    b.style.borderRadius = '10px';
                    b.style.cursor = 'pointer';
                    b.innerText = opt;
                    b.onclick = () => {
                        selectedTimeStr = opt;
                        Array.from(timeOptions.children).forEach(x => x.style.borderColor = 'rgba(255,255,255,0.3)');
                        b.style.borderColor = 'rgba(255,255,255,0.9)';
                    };
                    timeOptions.appendChild(b);
                });
            };

            if (durationOptions) {
                durations.forEach(d => {
                    const b = document.createElement('div');
                    b.className = 'btn-secondary';
                    b.style.padding = '6px 10px';
                    b.style.borderRadius = '10px';
                    b.style.cursor = 'pointer';
                    b.innerText = `${d}åˆ†é’Ÿ`;
                    b.onclick = () => {
                        selectedDuration = d;
                        Array.from(durationOptions.children).forEach(x => x.style.borderColor = 'rgba(255,255,255,0.3)');
                        b.style.borderColor = 'rgba(255,255,255,0.9)';
                        renderTimeChoices(d);
                    };
                    durationOptions.appendChild(b);
                });
            }
        }
        const add = document.getElementById('modal-add');
        add.onclick = () => {
            let timeStr = hasValidTimeStr(act.time) ? act.time : selectedTimeStr;
            if (!timeStr || !hasValidTimeStr(timeStr)) {
                showToast('è¯·å…ˆé€‰æ‹©æ—¶é•¿å’Œç©ºé—²æ—¶é—´');
                return;
            }
            const success = addScheduleItem(act.title, timeStr, 'TODO');
            if (!success) return;
            closeActivityModal();
            if (cardElement) {
                cardElement.style.transform = 'scale(0)';
                setTimeout(() => cardElement.remove(), 300);
            }
        };
        overlay.style.display = 'flex';
    }

    function closeActivityModal() {
        const overlay = document.getElementById('activity-modal');
        overlay.style.display = 'none';
    }
    
    document.getElementById('user-input').addEventListener('keypress', (e) => {
        if(e.key === 'Enter') sendMessage();
    });

    if(typeof window.setWeather !== 'function'){
        window.setWeather = function(type){};
    }
    if(typeof window.selectPet !== 'function'){
        window.selectPet = function(type){
            currentPet = type;
            document.querySelectorAll('.pet-option').forEach(el => el.classList.remove('active'));
            const btn = document.querySelector(`.pet-option[onclick="selectPet('${type}')"]`);
            if(btn) btn.classList.add('active');
        };
    }

    // ==========================================
    // 2. 3D åœºæ™¯ (Original Corgi)
    // ==========================================
    
    if(!window.THREE){
        document.body.style.background = 'linear-gradient(180deg,#1A237E,#E0F7FA)';
        try{
            const warn = document.createElement('div');
            warn.id = 'runtime-warning';
            warn.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:9999;background:rgba(255,255,255,0.9);color:#333;padding:10px 16px;border-radius:10px;border:1px solid rgba(0,0,0,0.1);font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.15)';
            warn.innerText = 'ä¸‰ç»´åº“æœªåŠ è½½ï¼Œæ­£åœ¨å°è¯•å¤‡ç”¨æ¥æº...';
            document.body.appendChild(warn);
            const ps=document.getElementById('pet-selector'); if(ps) ps.style.display='none';
            const ip=document.getElementById('interaction-panel'); if(ip) ip.style.display='none';
            addMessage('ä¸‰ç»´åº“æœªåŠ è½½ï¼Œå½“å‰ä¸ºçº¯æ–‡å­—æ¨¡å¼','ai', false);
            if(typeof window.__ensureThree==='function'){
                window.__ensureThree().then(function(ok){
                    if(ok){ try{ document.getElementById('runtime-warning').remove(); }catch(e){}
                        if(typeof window.initThreeScene==='function'){ window.initThreeScene(); }
                    } else {
                        warn.innerText = 'ä¸‰ç»´åº“æœªåŠ è½½ï¼Œå»ºè®®ç”¨ç³»ç»Ÿæµè§ˆå™¨æ‰“å¼€ http://localhost:8080/ æˆ–æ£€æŸ¥ç½‘ç»œ';
                    }
                });
            }
        }catch(e){}
    }
    function initThreeScene() {
    if (!window.THREE || !THREE.OrbitControls) return;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); 

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 8000);
    camera.position.set(0, 4, 6); 
    window.camera = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
    document.body.appendChild(renderer.domElement); 

    var psReady=document.getElementById('pet-selector'); if(psReady) psReady.style.display='flex';
    var ipReady=document.getElementById('interaction-panel'); if(ipReady) ipReady.style.display='flex';

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.minDistance = 2; controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2 - 0.05; 
    controls.target.set(0, 0.5, 0);
    // Right-click rotation fix: OrbitControls needs enableRotate to be true for right mouse button to work.
    // By default mouseButtons.RIGHT is THREE.MOUSE.PAN if not set, but we set it to ROTATE.
    // The manual listener was toggling enableRotate which might conflict or be redundant.
    // OrbitControls usually handles this automatically if mouseButtons are set correctly.
    controls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };
    controls.enableRotate = true; // Always enabled, let mouseButtons control mapping
    window.controls = controls;
    
    // renderer.domElement.addEventListener('mousedown', (e) => { if(e.button===2) controls.enableRotate = true; });
    // window.addEventListener('mouseup', (e) => { if(e.button===2) controls.enableRotate = false; });

    // --- åœºæ™¯ç‰©ä½“æ„å»º ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const targetRing = new THREE.Mesh(new THREE.RingGeometry(0.25, 0.35, 32), new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.7, side: THREE.DoubleSide }));
    targetRing.rotation.x = -Math.PI / 2; targetRing.visible = false; scene.add(targetRing);

    const STATE = { IDLE: 0, RUN: 1, BELLY: 2, BUSY: 3, SLEEP: 4 };
    let currentState = STATE.IDLE;
    const targetPos = new THREE.Vector3();
    window.dogPos = new THREE.Vector3(0, 0, 0);
    const dogPos = window.dogPos;
    
    // Global Speed Control
    window.lastClickTime = 0;
    const BASE_MOVE_SPEED = 1.1; // Default Walk
    const SPEED_RUN = 7.0; // Fast Run
    window.moveSpeed = BASE_MOVE_SPEED;
    
    const BASE_TURN_SPEED = 6.0;
    const WORLD_RADIUS = 60; // Reduced from 90

    // --- å® ç‰©æ„å»ºç³»ç»Ÿ ---
    const corgiGroup = new THREE.Group();
    window.corgiGroup = corgiGroup;
    const corgiBody = new THREE.Group(); 
    window.corgiBody = corgiBody;
    const headGroup = new THREE.Group(); 
    corgiGroup.add(corgiBody); scene.add(corgiGroup);
    let legs = []; let tail;
    let petYaw = 0;
    let lastSleepNoticeTime = 0;

    function normalizeAngleRad(a) {
        while (a > Math.PI) a -= Math.PI * 2;
        while (a < -Math.PI) a += Math.PI * 2;
        return a;
    }

    function angleDeltaRad(from, to) {
        return normalizeAngleRad(to - from);
    }

    function setPetYaw(yaw) {
        petYaw = normalizeAngleRad(yaw);
        corgiGroup.rotation.set(0, petYaw, 0);
    }
    window.setPetYaw = setPetYaw;
    if(typeof window.__pendingPetYaw === 'number') {
        setPetYaw(window.__pendingPetYaw);
        window.__pendingPetYaw = null;
    }

    function rotatePetTowardsYaw(targetYaw, maxDelta) {
        const delta = angleDeltaRad(petYaw, targetYaw);
        const step = Math.sign(delta) * Math.min(Math.abs(delta), maxDelta);
        setPetYaw(petYaw + step);
        return delta;
    }

    function clearPet() {
        corgiBody.clear();
        headGroup.clear();
        corgiBody.add(headGroup); // Re-add head group structure
        legs = [];
    }

    // 1. å‘†èŒæ°´ç‰› (Buffalo) - Removed per user request


    // 2. æŸ¯åŸº (Corgi) - Redesigned (Fluffy, Cute, Short Legs)
    function createCorgi() {
        clearPet();
        const traits = corgiGroup.userData.traits || { bodyScale:1, headScale:1, earScale:1 };
        
        const matOrange = new THREE.MeshStandardMaterial({ color: 0xF57C00, roughness: 0.6 });
        const matWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.6 });
        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });

        // Body (Capsule-like using merged spheres for fluffiness)
        const bodyR = 0.35 * traits.bodyScale;
        const bodyGroup = new THREE.Group();
        bodyGroup.position.y = 0.4;
        corgiBody.add(bodyGroup);

        // Main Body
        const b1 = new THREE.Mesh(new THREE.SphereGeometry(bodyR, 32, 32), matOrange);
        b1.scale.set(1, 0.9, 1.2);
        bodyGroup.add(b1);
        
        // White Belly/Chest
        const chest = new THREE.Mesh(new THREE.SphereGeometry(bodyR*0.9, 32, 32), matWhite);
        chest.position.set(0, -0.05, 0.2);
        chest.scale.set(0.9, 0.8, 1);
        bodyGroup.add(chest);

        // Butt (Heart shaped-ish)
        const buttL = new THREE.Mesh(new THREE.SphereGeometry(bodyR*0.6, 32, 32), matOrange);
        buttL.position.set(0.12, 0.03, -0.25);
        bodyGroup.add(buttL);
        const buttR = new THREE.Mesh(new THREE.SphereGeometry(bodyR*0.6, 32, 32), matOrange);
        buttR.position.set(-0.12, 0.03, -0.25);
        bodyGroup.add(buttR);

        // Tail (Nub)
        tail = new THREE.Group(); 
        tail.position.set(0, 0.4, -0.45);
        const tMesh = new THREE.Mesh(new THREE.SphereGeometry(0.08), matOrange);
        tail.add(tMesh);
        corgiBody.add(tail);

        // Head
        corgiBody.add(headGroup);
        headGroup.position.set(0, 0.75, 0.45);

        const headR = 0.32 * traits.headScale;
        const head = new THREE.Mesh(new THREE.SphereGeometry(headR, 32, 32), matOrange);
        head.castShadow = true; 
        headGroup.add(head);

        // Snout
        const snoutGeo = new THREE.SphereGeometry(0.14, 32, 32);
        const snoutM = new THREE.Mesh(snoutGeo, matWhite);
        snoutM.scale.set(1, 0.7, 1.2);
        snoutM.position.set(0, -0.12, 0.25);
        headGroup.add(snoutM);

        const nose = new THREE.Mesh(new THREE.SphereGeometry(0.05), matBlack);
        nose.position.set(0, -0.05, 0.4);
        headGroup.add(nose);

        // Ears (Big Triangles)
        const earGeo = new THREE.ConeGeometry(0.15 * traits.earScale, 0.3 * traits.earScale, 32);
        const earL = new THREE.Group(); earL.position.set(0.22, 0.20, 0);
        const elM = new THREE.Mesh(earGeo, matOrange); elM.position.y=0.12;
        earL.add(elM); 
        earL.rotation.set(0, 0, -0.4);
        headGroup.add(earL);

        const earR = new THREE.Group(); earR.position.set(-0.22, 0.20, 0);
        const erM = new THREE.Mesh(earGeo, matOrange); erM.position.y=0.12;
        earR.add(erM); 
        earR.rotation.set(0, 0, 0.4);
        headGroup.add(earR);
        corgiGroup.userData.ears = [earL, earR];

        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.05, 32, 32);
        const eyeL = new THREE.Mesh(eyeGeo, matBlack); 
        eyeL.position.set(0.14, 0.05, 0.29); 
        headGroup.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, matBlack); 
        eyeR.position.set(-0.14, 0.05, 0.29); 
        headGroup.add(eyeR);

        // Legs (Short & Stubby)
        const legGeo = new THREE.CylinderGeometry(0.09, 0.07, 0.3, 32);
        const legPos = [{x:0.2, z:0.25}, {x:-0.2, z:0.25}, {x:0.2, z:-0.25}, {x:-0.2, z:-0.25}];
        legPos.forEach(p => {
            const legG = new THREE.Group(); 
            legG.position.set(p.x, 0.38, p.z); 
            corgiBody.add(legG);
            
            const l = new THREE.Mesh(legGeo, matWhite); 
            l.position.y = -0.15; 
            l.castShadow = true; 
            legG.add(l);
            
            // Paws
            const paw = new THREE.Mesh(new THREE.SphereGeometry(0.08), matWhite);
            paw.position.set(0, -0.15, 0.05);
            l.add(paw);

            legs.push(legG);
        });
    }

    // 3. å°ç™½å…” (Rabbit) - Fixed (Visuals & Structure)
    function createRabbit() {
        clearPet();
        const traits = corgiGroup.userData.traits || { bodyScale:1, headScale:1, earScale:1 };
        
        const matWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.8 });
        const matPink = new THREE.MeshStandardMaterial({ color: 0xF8BBD0, roughness: 0.8 });
        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });

        // Body - Rounder
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.32 * traits.bodyScale, 32, 32), matWhite);
        body.position.y = 0.38; 
        body.scale.set(0.95, 0.85, 1.05); 
        body.castShadow = true;
        corgiBody.add(body);

        // Tail (Tiny fluffy ball)
        tail = new THREE.Group(); tail.position.set(0, 0.3, -0.42);
        const tMesh = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), matWhite);
        tail.add(tMesh); corgiBody.add(tail);

        // Head - Distinctly forward
        corgiBody.add(headGroup);
        headGroup.position.set(0, 0.6, 0.35);
        headGroup.rotation.set(0, 0, 0);

        const headR = 0.25 * traits.headScale;
        const head = new THREE.Mesh(new THREE.SphereGeometry(headR, 32, 32), matWhite);
        head.castShadow = true; headGroup.add(head);

        // Chest fluff
        const chestFluff = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), matWhite);
        chestFluff.position.set(0, 0.32, 0.18);
        corgiBody.add(chestFluff);

        // Snout
        const snout = new THREE.Mesh(new THREE.SphereGeometry(headR * 0.4, 16, 16), matWhite);
        snout.position.set(0, -0.05, 0.2); headGroup.add(snout);
        const nose = new THREE.Mesh(new THREE.SphereGeometry(0.03), matPink);
        nose.position.set(0, 0.02, 0.12); snout.add(nose);

        // Ears (Long and upright)
        const earGeo = new THREE.CylinderGeometry(0.05 * traits.earScale, 0.04 * traits.earScale, 0.45 * traits.earScale, 16);
        const eL = new THREE.Group(); eL.position.set(0.12, 0.2, 0);
        const elMesh = new THREE.Mesh(earGeo, matWhite); elMesh.position.y = 0.2; elMesh.rotation.x = -0.1;
        eL.add(elMesh); headGroup.add(eL);
        
        const eR = new THREE.Group(); eR.position.set(-0.12, 0.2, 0);
        const erMesh = new THREE.Mesh(earGeo, matWhite); erMesh.position.y = 0.2; erMesh.rotation.x = -0.1;
        eR.add(erMesh); headGroup.add(eR);

        corgiGroup.userData.ears = [eL, eR];

        // Eyes
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.03), matBlack); eyeL.position.set(0.1, 0.05, 0.22); headGroup.add(eyeL);
        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.03), matBlack); eyeR.position.set(-0.1, 0.05, 0.22); headGroup.add(eyeR);

        // Legs - Attached to body, moving with it
        const legGeo = new THREE.CylinderGeometry(0.05, 0.04, 0.18, 16);
        const legPos = [{x:0.15, z:0.2}, {x:-0.15, z:0.2}, {x:0.15, z:-0.2}, {x:-0.15, z:-0.2}];
        legPos.forEach(p => {
            const legG = new THREE.Group(); 
            legG.position.set(p.x, 0.28, p.z); // Embed deeper into body (Was 0.18)
            corgiBody.add(legG);
            
            const l = new THREE.Mesh(legGeo, matWhite); 
            l.position.y = -0.16; 
            l.castShadow = true; 
            legG.add(l);
            const paw = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), matPink);
            paw.position.set(0, -0.06, 0.06);
            l.add(paw);
            legs.push(legG);
        });
    }

    // 4. å°èŠ±çŒ« (Cat) - Fixed (Legs & Structure)
    function createCat() {
        clearPet();
        const traits = corgiGroup.userData.traits || { bodyScale:1, headScale:1, earScale:1 };
        
        const matGrey = new THREE.MeshStandardMaterial({ color: 0x9E9E9E, roughness: 0.7 });
        const matWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.7 });
        const matPink = new THREE.MeshStandardMaterial({ color: 0xF48FB1 });
        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });

        // Body - Slimmer and longer
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.35 * traits.bodyScale, 32, 32), matGrey);
        // Reduced width (x) and height (y) scale for slimness, increased length (z)
        // Shortened Z from 1.4 to 1.1 per request
        body.position.y = 0.42; body.scale.set(0.55, 0.7, 1.1); body.castShadow = true;
        corgiBody.add(body);
        
        // Belly patch - Adjusted for slimmer body
        const belly = new THREE.Mesh(new THREE.SphereGeometry(0.26 * traits.bodyScale, 32, 32), matWhite);
        // Adjusted belly scale Z from 1.1 to 0.9
        belly.position.set(0, 0.30, 0.05); belly.scale.set(0.8, 0.5, 0.9);
        corgiBody.add(belly);

        // Tail (Long)
        // Moved tail forward from -0.5 to -0.4 to match shorter body
        tail = new THREE.Group(); tail.position.set(0, 0.5, -0.4); 
        const tMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.015, 0.6, 16), matGrey); // Thinner tail
        tMesh.rotation.x = 0.5; tMesh.position.set(0, 0.25, -0.1);
        tail.add(tMesh); corgiBody.add(tail);

        // Head
        corgiBody.add(headGroup); // Ensure headGroup is added!
        const headR = 0.22 * traits.headScale; // Slightly smaller head
        headGroup.position.set(0, 0.65, 0.4); // Adjusted position
        const head = new THREE.Mesh(new THREE.SphereGeometry(headR, 32, 32), matGrey);
        head.castShadow = true; headGroup.add(head);

        // Chest fluff (white)
        const chestFluffCat = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), matWhite);
        chestFluffCat.position.set(0, 0.38, 0.22);
        corgiBody.add(chestFluffCat);

        // Ears (Pointy)
        const earGeo = new THREE.ConeGeometry(0.07 * traits.earScale, 0.18 * traits.earScale, 4);
        const eL = new THREE.Mesh(earGeo, matGrey); eL.position.set(0.15, 0.25, 0); eL.rotation.set(0, 0, -0.3); headGroup.add(eL);
        const eR = new THREE.Mesh(earGeo, matGrey); eR.position.set(-0.15, 0.25, 0); eR.rotation.set(0, 0, 0.3); headGroup.add(eR);
        corgiGroup.userData.ears = [eL, eR];

        // Eyes (Vertical Slit)
        const eyeGeo = new THREE.BoxGeometry(0.02, 0.08, 0.02);
        const eyeL = new THREE.Mesh(eyeGeo, matBlack); eyeL.position.set(0.1, 0.05, 0.24); headGroup.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, matBlack); eyeR.position.set(-0.1, 0.05, 0.24); headGroup.add(eyeR);

        // Nose
        const noseMesh = new THREE.Mesh(new THREE.ConeGeometry(0.02, 0.02, 4), matPink);
        noseMesh.rotation.x = Math.PI/2; noseMesh.rotation.y = Math.PI/4;
        noseMesh.position.set(0, -0.02, 0.24); headGroup.add(noseMesh);

        // Mouth (8-petal / 'w' shape)
        const mouthGroup = new THREE.Group();
        mouthGroup.position.set(0, -0.05, 0.24);
        headGroup.add(mouthGroup);
        const mouthCurve = new THREE.TorusGeometry(0.03, 0.006, 8, 16, Math.PI);
        const mL = new THREE.Mesh(mouthCurve, matBlack);
        mL.position.set(0.03, 0, 0); mL.rotation.z = Math.PI;
        mouthGroup.add(mL);
        const mR = new THREE.Mesh(mouthCurve, matBlack);
        mR.position.set(-0.03, 0, 0); mR.rotation.z = Math.PI;
        mouthGroup.add(mR);

        // Legs
        const legGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.28, 16);
        const legPos = [{x:0.15, z:0.2}, {x:-0.15, z:0.2}, {x:0.15, z:-0.2}, {x:-0.15, z:-0.2}];
        legPos.forEach(p => {
            const legG = new THREE.Group(); legG.position.set(p.x, 0.2, p.z); // Raised to body height
            corgiBody.add(legG); // Ensure added to body
            const l = new THREE.Mesh(legGeo, matWhite); l.position.y = -0.1; l.castShadow = true; 
            legG.add(l);
            const paw = new THREE.Mesh(new THREE.SphereGeometry(0.045, 16, 16), matPink);
            paw.position.set(0, -0.10, 0.06);
            l.add(paw);
            legs.push(legG);
        });
    }

    window.createCorgi = createCorgi;
    window.createRabbit = createRabbit;
    window.createCat = createCat;

    // --- å® ç‰©çŠ¶æ€ç³»ç»Ÿ ---
    const petStatus = {
        mood: 80,
        health: 90,
        gloss: 75
    };

    function updateStatusUI() {
        document.getElementById('bar-mood').style.width = petStatus.mood + '%';
        document.getElementById('bar-health').style.width = petStatus.health + '%';
        document.getElementById('bar-gloss').style.width = petStatus.gloss + '%';
    }

    function __decodePetAccount(data){
        try{
            const u8 = (data instanceof Uint8Array) ? data : new Uint8Array(data);
            if(u8.length < 47) return null;
            const ownerBytes = u8.slice(0, 32);
            const owner = new solanaWeb3.PublicKey(ownerBytes);
            const view = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
            const mood = view.getUint16(32, true);
            const health = view.getUint16(34, true);
            const gloss = view.getUint16(36, true);
            const bump = view.getUint8(38);
            const lastTs = Number(view.getBigInt64(39, true));
            return { owner, mood, health, gloss, bump, lastTs };
        } catch(e) { return null; }
    }

    async function __getSolanaConnection(){
        const rpc = (typeof __getSolanaRpcUrl === 'function') ? __getSolanaRpcUrl() : 'https://api.devnet.solana.com';
        return new solanaWeb3.Connection(rpc, 'confirmed');
    }

    function __getProgramId(){
        const s = (typeof __getProgramIdStr === 'function') ? __getProgramIdStr() : '';
        if(!s) return null;
        try{ return new solanaWeb3.PublicKey(s); } catch(e) { return null; }
    }

    function __getOwnerPubkey(){
        const s = window.__walletPubkeyStr || '';
        if(!s) return null;
        try{ return new solanaWeb3.PublicKey(s); } catch(e) { return null; }
    }

    function __getPetPda(programId, ownerPk){
        return solanaWeb3.PublicKey.findProgramAddressSync(
            [new TextEncoder().encode('pet'), ownerPk.toBuffer()],
            programId
        );
    }

    async function __fetchPetAccount(){
        const programId = __getProgramId();
        const ownerPk = __getOwnerPubkey();
        if(!programId || !ownerPk) return null;
        const [petPda] = __getPetPda(programId, ownerPk);
        const conn = await __getSolanaConnection();
        const info = await conn.getAccountInfo(petPda, 'confirmed');
        if(!info || !info.data) return null;
        const decoded = __decodePetAccount(info.data);
        if(!decoded) return null;
        return { petPda, decoded };
    }

    async function __initPet(){
        const programId = __getProgramId();
        const ownerPk = __getOwnerPubkey();
        if(!programId){
            showToast('æœªé…ç½® programIdï¼Œå¯ç”¨ ?programId=... ä¼ å…¥', 'é“¾ä¸Š');
            return false;
        }
        if(!ownerPk){
            showToast('è¯·å…ˆè¿æ¥é’±åŒ…', 'é“¾ä¸Š');
            return false;
        }
        const conn = await __getSolanaConnection();
        const [petPda] = __getPetPda(programId, ownerPk);
        const keys = [
            { pubkey: ownerPk, isSigner: true, isWritable: true },
            { pubkey: petPda, isSigner: false, isWritable: true },
            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false }
        ];
        const data = new Uint8Array([0]);
        const ix = new solanaWeb3.TransactionInstruction({ programId, keys, data });
        const tx = new solanaWeb3.Transaction().add(ix);
        tx.feePayer = ownerPk;
        const { blockhash } = await conn.getLatestBlockhash('confirmed');
        tx.recentBlockhash = blockhash;
        const signed = await window.solana.signTransaction(tx);
        const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight: false, preflightCommitment: 'confirmed' });
        await conn.confirmTransaction(sig, 'confirmed');
        return true;
    }

    async function __sendInteract(kind){
        const programId = __getProgramId();
        const ownerPk = __getOwnerPubkey();
        if(!programId){
            showToast('æœªé…ç½® programIdï¼Œå¯ç”¨ ?programId=... ä¼ å…¥', 'é“¾ä¸Š');
            return false;
        }
        if(!ownerPk){
            showToast('è¯·å…ˆè¿æ¥é’±åŒ…', 'é“¾ä¸Š');
            return false;
        }
        const conn = await __getSolanaConnection();
        const [petPda] = __getPetPda(programId, ownerPk);
        const keys = [
            { pubkey: ownerPk, isSigner: true, isWritable: false },
            { pubkey: petPda, isSigner: false, isWritable: true },
            { pubkey: solanaWeb3.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false }
        ];
        const data = new Uint8Array([1, kind & 0xff]);
        const ix = new solanaWeb3.TransactionInstruction({ programId, keys, data });
        const tx = new solanaWeb3.Transaction().add(ix);
        tx.feePayer = ownerPk;
        const { blockhash } = await conn.getLatestBlockhash('confirmed');
        tx.recentBlockhash = blockhash;
        const signed = await window.solana.signTransaction(tx);
        const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight: false, preflightCommitment: 'confirmed' });
        await conn.confirmTransaction(sig, 'confirmed');
        return true;
    }

    async function __refreshOnchainPetStatus(allowInit){
        if(!window.solanaWeb3) return;
        const ownerPk = __getOwnerPubkey();
        if(!ownerPk) return;
        const programId = __getProgramId();
        if(!programId) return;
        try{
            const existing = await __fetchPetAccount();
            if(!existing){
                if(allowInit){
                    const ok = await __initPet();
                    if(!ok) return;
                } else {
                    return;
                }
            }
            const fresh = await __fetchPetAccount();
            if(!fresh) return;
            petStatus.mood = Math.max(0, Math.min(100, Math.round(fresh.decoded.mood / 100)));
            petStatus.health = Math.max(0, Math.min(100, Math.round(fresh.decoded.health / 100)));
            petStatus.gloss = Math.max(0, Math.min(100, Math.round(fresh.decoded.gloss / 100)));
            updateStatusUI();
        } catch(e) {}
    }

    window.__refreshOnchainPetStatus = __refreshOnchainPetStatus;

    setInterval(() => {
        if(typeof __refreshOnchainPetStatus === 'function') __refreshOnchainPetStatus(false);
    }, 12000);

    window.interact = async function(type) {
        lastOwnerInteractionTime = Date.now() * 0.001;
        didWanderAfterOwnerIdle = false;
        
        // Force interrupt any current state
        currentState = STATE.BUSY; 
        targetRing.visible = false;
        runStateStart = 0;

        // 1. é“¾ä¸Šäº¤äº’ & æç¤º
        if (type === 'feed') {
            showThought("å§å”§å§å”§... å¥½åƒï¼");
        } else if (type === 'groom') {
            showThought("å‘¼å™œå‘¼å™œ... èˆ’æœ~");
        } else if (type === 'play') {
            showThought("å¥½è€¶ï¼å†æ¥ï¼");
        }
        if(typeof __ensureSolanaReady === 'function') await __ensureSolanaReady();
        if(!window.__walletPubkeyStr){
            showToast('è¯·å…ˆç‚¹å‡»å³ä¸Šè§’ã€Œè¿æ¥é’±åŒ…ã€', 'é“¾ä¸Š');
        } else {
            try{
                let kind = 0;
                if(type === 'groom') kind = 1;
                if(type === 'play') kind = 2;
                const ok = await __sendInteract(kind);
                if(ok) await __refreshOnchainPetStatus(false);
            } catch(e){
                showToast('é“¾ä¸Šäº¤æ˜“å¤±è´¥ï¼Œè¯·ç¨åå†è¯•', 'é“¾ä¸Š');
            }
        }

        // 2. æ‰§è¡Œä¸“å±åŠ¨ç”»
        let startTime = Date.now();
        
        // Show Props
        if(type === 'feed' && propFood) propFood.visible = true;
        if(type === 'groom' && propComb) propComb.visible = true;
        if(type === 'play' && propToy) propToy.visible = true;

        const animLoop = () => {
            const now = Date.now();
            const t = (now - startTime) / 1000; // elapsed seconds
            let finished = false;
            const duration = 2.0; // é»˜è®¤åŠ¨ç”»æ—¶é•¿

            // é‡ç½®åŸºç¡€å§¿æ€ (æ¯å¸§è¦†ç›–ï¼Œé¿å…ç´¯ç§¯è¯¯å·®)
            corgiBody.rotation.set(0,0,0);
            corgiBody.position.set(0,0,0);
            headGroup.rotation.set(0,0,0);
            if(tail) tail.rotation.set(0,0,0);

            if (type === 'feed') {
                if (currentPet === 'corgi') {
                    // æŸ¯åŸº: å¼€å¿ƒè·³è·ƒ
                    corgiBody.position.y = Math.abs(Math.sin(t * 15)) * 0.2; 
                    corgiBody.rotation.z = Math.sin(t * 20) * 0.1;
                } else if (currentPet === 'rabbit') {
                    // å…”å­: å¿«é€Ÿå’€åš¼
                    headGroup.rotation.x = Math.sin(t * 25) * 0.15 + 0.15;
                    corgiBody.rotation.x = 0.15;
                } else if (currentPet === 'cat') {
                    // çŒ«å’ª: åŸ‹å¤´åƒ
                    headGroup.rotation.x = 0.6 + Math.sin(t * 8) * 0.1; 
                    corgiBody.position.y = -0.1; 
                }
            } else if (type === 'groom') {
                if (currentPet === 'corgi') {
                    // æŸ¯åŸº: å±è‚¡å·¦å³æ‘†åŠ¨ (No yaw spin)
                    corgiBody.rotation.z = Math.sin(t * 12) * 0.12; 
                    if(tail) tail.rotation.z = Math.sin(t * 20) * 1.0;
                } else if (currentPet === 'rabbit') {
                    // å…”å­: èˆ’æœé¢¤æŠ–
                    corgiBody.position.x = Math.sin(t * 40) * 0.02;
                    headGroup.rotation.z = Math.sin(t * 6) * 0.15;
                } else if (currentPet === 'cat') {
                    // çŒ«å’ª: é«˜é«˜æ‹±èƒŒ
                    corgiBody.rotation.x = -0.5; 
                    headGroup.rotation.x = 0.6;
                    corgiBody.position.y = 0.15;
                }
            } else if (type === 'play') {
                if (currentPet === 'corgi') {
                    // æŸ¯åŸº: æ¬¢å¿«è·³è·ƒ (No spinning)
                    corgiBody.rotation.z = Math.sin(t * 15) * 0.1; // Wiggle
                    corgiBody.position.y = Math.abs(Math.sin(t * 15)) * 0.15;
                } else if (currentPet === 'rabbit') {
                    // å…”å­: è¶…çº§å¤§è·³
                    corgiBody.position.y = Math.abs(Math.sin(t * 8)) * 0.8;
                    corgiBody.rotation.x = -Math.sin(t * 8) * 0.4;
                } else if (currentPet === 'cat') {
                    // çŒ«å’ª: æ‰‘æ€
                    corgiBody.position.z = Math.sin(t * 10) * 0.8;
                    corgiBody.position.y = Math.abs(Math.sin(t * 10)) * 0.3;
                }
            }

            if (t > duration) {
                // ç»“æŸåŠ¨ç”»ï¼Œå¤ä½
                corgiBody.rotation.set(0,0,0);
                corgiBody.position.set(0,0,0);
                headGroup.rotation.set(0,0,0);
                if(tail) tail.rotation.set(0,0,0);
                
                // Hide Props
                if(propFood) propFood.visible = false;
                if(propComb) propComb.visible = false;
                if(propToy) propToy.visible = false;

                currentState = STATE.IDLE;
            } else {
                requestAnimationFrame(animLoop);
            }
        };
        animLoop();
    }



    // --- å® ç‰©è‡ªä¸»è¡Œä¸ºç³»ç»Ÿ ---
    let lastBehaviorTime = 0;
    let behaviorTimer = null;
    let runLookAtCooldown = 0;
    let runStateStart = 0;
    let lastRunDist = Infinity;
    let lastDistDecreaseTime = 0;
    let lastOwnerInteractionTime = 0;
    const OWNER_IDLE_THRESHOLD = 60; // seconds
    let didWanderAfterOwnerIdle = false;
    let lastAttentionTime = 0;

    // --- åˆ‡æ¢ä¸åˆå§‹åŒ– ---
    window.selectPet = function(type) {
        document.querySelectorAll('.pet-option').forEach(el => el.classList.remove('active'));
        document.querySelector(`.pet-option[onclick="selectPet('${type}')"]`).classList.add('active');
        
        currentPet = type;
        lastBehaviorTime = Date.now() * 0.001;
        
        // New traits for new selection
        corgiGroup.userData.traits = generatePetTraits();
        
        rebuildPet();

        // Save to backend
        if(currentUser) {
            const config = { type: currentPet, traits: corgiGroup.userData.traits };
            saveUserData({ petConfig: config });
        }
    }

        // Default startup pet
    selectPet(currentPet);
    if(window.pendingPetConfig){
        restorePet(window.pendingPetConfig);
        window.pendingPetConfig = null;
    }
    
    function showThought(text) {
        const bubble = document.getElementById('pet-thoughts');
        const txt = document.getElementById('thought-text');
        txt.innerText = text;
        bubble.style.opacity = 1;
        
        if(behaviorTimer) clearTimeout(behaviorTimer);
        behaviorTimer = setTimeout(() => {
            bubble.style.opacity = 0;
        }, 3000);
    }

    // Helper to check position validity (Avoid Ponds)
    function isValidPos(pos) {
        for(let p of ponds) {
            if(pos.distanceTo(p.position) < p.radius + 1.5) return false;
        }
        return true;
    }

    function isForcedSleepTime() {
        const h = new Date().getHours();
        return h >= 2 && h < 6;
    }

    function applySleepPose(dt) {
        const k = Math.min(1, dt * 6);
        const bodyTilt = currentPet === 'cat' ? Math.PI / 12 : Math.PI / 10;
        corgiBody.rotation.x = THREE.MathUtils.lerp(corgiBody.rotation.x, bodyTilt, k);
        corgiBody.rotation.z = THREE.MathUtils.lerp(corgiBody.rotation.z, 0, k);
        corgiBody.position.y = THREE.MathUtils.lerp(corgiBody.position.y, 0, k);
        if(headGroup) {
            headGroup.rotation.x = THREE.MathUtils.lerp(headGroup.rotation.x, -0.28, k);
            headGroup.rotation.z = THREE.MathUtils.lerp(headGroup.rotation.z, 0, k);
        }
        if(legs && legs.length) {
            const legRot = currentPet === 'rabbit' ? -0.7 : -0.85;
            legs.forEach(l => {
                l.rotation.x = THREE.MathUtils.lerp(l.rotation.x, legRot, k);
                const legRestY = currentPet === 'rabbit' ? 0.28 : currentPet === 'corgi' ? 0.38 : 0.2;
                const targetY = currentPet === 'rabbit' ? 0.22 : currentPet === 'corgi' ? (legRestY - 0.06) : 0.16;
                l.position.y = THREE.MathUtils.lerp(l.position.y, targetY, k);
            });
        }
        if(tail) {
            tail.rotation.z = THREE.MathUtils.lerp(tail.rotation.z, 0, k);
            tail.rotation.y = THREE.MathUtils.lerp(tail.rotation.y, 0, k);
            tail.rotation.x = THREE.MathUtils.lerp(tail.rotation.x, currentPet === 'cat' ? 0.25 : 0, k);
        }
    }

    function updatePetBehavior(time) {
        // åªæœ‰åœ¨ IDLE çŠ¶æ€ä¸‹æ‰è§¦å‘è‡ªä¸»è¡Œä¸º
        if (currentState !== STATE.IDLE) return;
        if (isForcedSleepTime()) return;
        const ownerIdle = (time - lastOwnerInteractionTime) > OWNER_IDLE_THRESHOLD;

        if (time - lastBehaviorTime > 100 + Math.random() * 125) {
            lastBehaviorTime = time;
            const texts = PET_BEHAVIOR_TEXT[currentPet];
            let personality = PET_PERSONALITY[currentPet];
            if(!personality) personality = { type:'energetic', sniffChance:0.5, probeChance:0.5 };
            const rand = Math.random();
            if (!ownerIdle || Math.random() < 0.95) {
                if (Math.random() < 0.6) {
                    const camPos = camera.position.clone();
                    camPos.y = corgiGroup.position.y;
                    const dx = camPos.x - corgiGroup.position.x;
                    const dz = camPos.z - corgiGroup.position.z;
                    setPetYaw(Math.atan2(dx, dz));
                    headGroup.rotation.z = (Math.random()<0.5?1:-1) * 0.25;
                    setTimeout(()=> headGroup.rotation.z = 0, 1200);
                    showThought("(çœ‹ç€ä½ ...)");
                } else {
                    // è‡ªæˆ‘ç…§æ–™ (åŸåœ°)
                    if (currentPet === 'cat') {
                        showThought("(èˆ”çˆªå­...)");
                        headGroup.rotation.x = 0.25;
                        setTimeout(()=> headGroup.rotation.x = 0, 1500);
                    } else if (currentPet === 'rabbit') {
                        showThought("(æŠ–åŠ¨é¼»å­...)");
                        let c=0; const s=setInterval(()=>{ headGroup.position.y = 0.65 + Math.sin(c)*0.02; c+=0.5; if(c>10){clearInterval(s); headGroup.position.y=0.65;} }, 50);
                    } else {
                        showThought("(æ¢³ç†æ¯›å‘...)");
                        if(tail) { let c=0; const w=setInterval(()=>{ tail.rotation.z = Math.sin(c)*0.8; c+=0.3; if(c>Math.PI*2){ clearInterval(w); tail.rotation.z=0; }}, 50); }
                    }
                }
                return;
            }

            // Helper to check position validity (Avoid Ponds)
            const isValidPos = (pos) => {
                for(let p of ponds) {
                    if(pos.distanceTo(p.position) < p.radius + 1.5) return false;
                }
                return true;
            };

            // --- 1. ä¸ç”¨æˆ·äº’åŠ¨ (é—»å—…/è¯•æ¢) ---
            const distToCam = dogPos.distanceTo(camera.position);
            // å¦‚æœè·ç¦»ç›¸æœºè¾ƒè¿œä¸”è§¦å‘æ¦‚ç‡ï¼Œåˆ™é è¿‘
            if (ownerIdle && !didWanderAfterOwnerIdle && distToCam > 4.0 && distToCam < 15.0 && Math.random() < personality.sniffChance) {
                const camPosXZ = new THREE.Vector3(camera.position.x, 0, camera.position.z);
                const dir = camPosXZ.clone().sub(dogPos).normalize();
                const stopDist = 3.5; // åœåœ¨ç›¸æœºå‰
                
                const target = camPosXZ.sub(dir.multiplyScalar(stopDist));
                if(isValidPos(target)) {
                    targetPos.copy(target);
                    currentState = STATE.RUN;
                    
                    const approachTexts = ["(å¥½å¥‡åœ°èµ°è¿‡æ¥...)", "(æƒ³è¦é è¿‘ä½ ...)", "(å—…å—…ä½ çš„å‘³é“...)"];
                    showThought(approachTexts[Math.floor(Math.random()*approachTexts.length)]);
                    return;
                }
            }

            // å¦‚æœå·²ç»åœ¨ç›¸æœºé™„è¿‘ (Sniff/Probe Animation)
            if (distToCam <= 4.5 && Math.random() < personality.probeChance) {
                 // Face camera
                 const camPos = camera.position.clone();
                 const dx = camPos.x - corgiGroup.position.x;
                 const dz = camPos.z - corgiGroup.position.z;
                 setPetYaw(Math.atan2(dx, dz));

                 if (currentPet === 'corgi') {
                     showThought("(æ­ªå¤´æ€~)");
                     headGroup.rotation.z = 0.5;
                     setTimeout(()=>headGroup.rotation.z=0, 1000);
                 } else if (currentPet === 'cat') {
                     showThought("(ç›¯ç€ä½ çœ‹...)");
                     // åä¸‹å‡è§†
                     corgiBody.rotation.x = -Math.PI/6;
                     corgiBody.position.y = -0.1;
                     setTimeout(()=>{ corgiBody.rotation.x=0; corgiBody.position.y=0; }, 2000);
                 } else {
                     showThought("(åŠ¨åŠ¨é¼»å­å—…å—…)");
                     // Rabbit sniff
                     let count=0;
                     const s = setInterval(()=>{ headGroup.position.y = 0.65 + Math.sin(count)*0.02; count+=0.5; if(count>10) clearInterval(s); }, 50);
                 }
                 return;
            }

            // --- 1.5 Environmental Attraction (Ponds, Mushrooms, Bushes, Flowers) ---
            const attractions = [...flowerInstances, ...bushes, ...ponds, ...mushrooms, ...stones];
            // Filter attractions within 5m
            const nearby = attractions.filter(a => a.position.distanceTo(dogPos) < 5.0);
            
            if (ownerIdle && !didWanderAfterOwnerIdle && nearby.length > 0 && Math.random() < 0.03) {
                 const target = nearby[Math.floor(Math.random() * nearby.length)];
                 
                 // Calculate safe stopping point
                 const dir = dogPos.clone().sub(target.position).normalize();
                 // If target is pond, stop further away
                 let stopDist = 0.5;
                 // Check if target is in 'ponds' array (by reference or property)
                 // We constructed attractions array, so we can't easily check type.
                 // But we can check if it has 'radius'.
                 if(target.radius && target.radius > 3) stopDist = target.radius + 1.0; // Pond

                 const dest = target.position.clone().add(dir.multiplyScalar(stopDist));
                 
                 if(isValidPos(dest)) {
                     targetPos.copy(dest);
                     currentState = STATE.RUN;
                     didWanderAfterOwnerIdle = true;
                     showThought("(è¢«ä»€ä¹ˆå¸å¼•äº†...)");
                     return;
                 }
            }

            // --- 2. æ„å›¾è¡¨è¾¾ (Intention) ---
            if (ownerIdle && !didWanderAfterOwnerIdle && Math.random() < 0.18) {
                const intentions = [
                    { text: "æƒ³å»é‚£è¾¹çœ‹çœ‹...", action: "wander" },
                    { text: "è‚šå­æœ‰ç‚¹é¥¿äº†...", action: "food" },
                    { text: "å¥½æƒ³ç©çƒå•Š...", action: "play" },
                    { text: "é‚£æ£µæ ‘çœ‹èµ·æ¥ä¸é”™...", action: "tree" },
                    { text: "ä»Šå¤©å¤©æ°”çœŸå¥½~", action: "idle" }
                ];
                // æ ¹æ®æ€§æ ¼è°ƒæ•´
                if(personality.type === 'energetic') intentions.push({ text: "å¿«é™ªæˆ‘ç©ï¼", action: "play_beg" });
                if(personality.type === 'timid') intentions.push({ text: "æœ‰ç‚¹å®³æ€•...", action: "hide" });

                const intent = intentions[Math.floor(Math.random() * intentions.length)];
                showThought(intent.text);
                
                if(intent.action === "wander" || intent.action === "tree") {
                    let targetTree = null;
                    if(intent.action === "tree" && trees.length > 0) {
                        // Filter trees within 5m (slightly larger range for trees)
                        const nearbyTrees = trees.filter(t => t.position.distanceTo(dogPos) < 5.0);
                        if (nearbyTrees.length > 0) {
                            targetTree = nearbyTrees[Math.floor(Math.random() * nearbyTrees.length)];
                        }
                    }

                    if(targetTree) {
                         const dir = dogPos.clone().sub(targetTree.position).normalize();
                         const dest = targetTree.position.clone().add(dir.multiplyScalar(2.0));
                         if(isValidPos(dest)) {
                             targetPos.copy(dest);
                             currentState = STATE.RUN;
                             didWanderAfterOwnerIdle = true;
                         }
                    } else {
                         // Fallback to short wander
                         // Try up to 3 times to find valid pos
                         for(let k=0; k<3; k++) {
                             const angle = Math.random() * Math.PI * 2;
                             const dist = 0.3 + Math.random() * 1.0;
                             let tx = dogPos.x + Math.cos(angle)*dist;
                             let tz = dogPos.z + Math.sin(angle)*dist;
                             const dest = new THREE.Vector3(tx, 0, tz);
                             if(isValidPos(dest)) {
                                 targetPos.copy(dest);
                                 currentState = STATE.RUN;
                                 didWanderAfterOwnerIdle = true;
                                 break;
                             }
                         }
                    }
                } else if (intent.action === "play_beg") {
                     // Jump
                     corgiBody.position.y = 0.3;
                     setTimeout(()=>corgiBody.position.y=0, 300);
                }
                return;
            }


            // --- 3. ç¯å¢ƒäº¤äº’æ£€æµ‹ (æ ‘æœ¨, èŠ±æœµ, çŒæœ¨, çŸ³å¤´, è˜‘è‡) ---
            
            // A. Trees (Climb/Rub)
            let nearbyTree = trees.find(t => dogPos.distanceTo(t.position) < 3.5);
            if (nearbyTree && Math.random() < 0.03) {
                const treeDir = nearbyTree.position.clone().sub(dogPos).normalize();
                setPetYaw(Math.atan2(treeDir.x, treeDir.z));
                
                if(currentPet === 'corgi') {
                    showThought("(é—»é—»æ ‘æ ¹...)");
                    corgiBody.rotation.x = 0.2;
                    setTimeout(()=>corgiBody.rotation.x=0, 1000);
                } else if(currentPet === 'cat') {
                    showThought("(æƒ³è¦çˆ¬æ ‘...)"); 
                    // Climb animation (Vertical jump & hold)
                    let count = 0;
                    const climbAnim = setInterval(() => {
                        if(count < 15) corgiBody.position.y += 0.08; // Up
                        else if(count < 40) corgiBody.rotation.x = -0.6; // Hold & Look up
                        else corgiBody.position.y -= 0.08; // Down
                        
                        count++;
                        if(count > 55 || corgiBody.position.y < 0) { 
                            clearInterval(climbAnim); 
                            corgiBody.position.y = 0; 
                            corgiBody.rotation.x = 0; 
                        }
                    }, 30);
                } else {
                     showThought("(ç»•ç€æ ‘è·‘...)");
                     let count = 0;
                     const hop = setInterval(() => {
                        corgiBody.position.y = Math.abs(Math.sin(count)) * 0.3;
                        count += 0.3;
                        if(count > Math.PI*4) { clearInterval(hop); corgiBody.position.y = 0; }
                     }, 30);
                }
                return;
            }

            // B. Flowers (Sniff)
            let nearbyFlower = flowerInstances.find(f => dogPos.distanceTo(f.position) < 2.5);
            if (nearbyFlower && Math.random() < 0.04) {
                const dir = nearbyFlower.position.clone().sub(dogPos).normalize();
                setPetYaw(Math.atan2(dir.x, dir.z));
                showThought("(é—»é—»èŠ±é¦™...)");
                
                // Sniff animation
                corgiBody.rotation.x = 0.3; 
                headGroup.rotation.x = 0.2;
                
                let count = 0;
                const sniff = setInterval(() => {
                    headGroup.position.z = 0.35 + Math.sin(count*20)*0.02; 
                    count += 0.1;
                    if(count > 2) { 
                        clearInterval(sniff); 
                        corgiBody.rotation.x = 0; 
                        headGroup.rotation.x = 0; 
                        headGroup.position.z = 0.35; 
                        
                        showThought("å¥½é¦™å•Š~");
                        if(currentPet === 'rabbit' || currentPet === 'corgi') {
                            corgiBody.position.y = 0.2; 
                            setTimeout(()=>corgiBody.position.y=0, 200);
                        }
                    }
                }, 30);
                return;
            }

            // C. Bushes (Bounce/Hide/Find Berries)
            let nearbyBush = bushes.find(b => dogPos.distanceTo(b.position) < 2.5);
            if (nearbyBush && Math.random() < 0.04) {
                const dir = nearbyBush.position.clone().sub(dogPos).normalize();
                setPetYaw(Math.atan2(dir.x, dir.z));
                
                const randAction = Math.random();
                
                if (randAction < 0.3) { // 30% Find Berries
                     showThought("(å‘ç°é‡æœï¼)");
                     corgiBody.rotation.x = 0.35; 
                     headGroup.rotation.x = 0.25;
                     if(propFood) propFood.visible = true;
                     
                     setTimeout(() => { showThought("é…¸é…¸ç”œç”œ~"); }, 1000);
                     setTimeout(() => {
                        corgiBody.rotation.x = 0;
                        headGroup.rotation.x = 0;
                        if(propFood) propFood.visible = false;
                        petStatus.health = Math.min(100, petStatus.health + 2);
                        updateStatusUI();
                     }, 2500);
                     
                } else if (currentPet === 'rabbit' || currentPet === 'cat') {
                    showThought("(é’»è¿›çŒæœ¨ä¸›...)");
                    corgiBody.scale.setScalar(0.5); 
                    corgiBody.position.y = -0.2;
                    setTimeout(() => {
                        showThought("(çªç„¶è·³å‡ºæ¥ï¼)");
                        corgiBody.scale.setScalar(1);
                        corgiBody.position.y = 0.5; 
                        setTimeout(()=>corgiBody.position.y=0, 300);
                    }, 2000);
                } else {
                    showThought("(å¼¹è·³çŒæœ¨ä¸›ï¼)");
                    let count = 0;
                    const bounce = setInterval(() => {
                        corgiBody.position.y = Math.abs(Math.sin(count)) * 0.4;
                        count += 0.2;
                        if(count > Math.PI*4) { clearInterval(bounce); corgiBody.position.y = 0; }
                    }, 30);
                }
                return;
            }

            // D. Mushrooms (Find Food)
            let nearbyMush = mushrooms.find(m => dogPos.distanceTo(m.position) < 2.0);
            if (nearbyMush && Math.random() < 0.04) {
                const dir = nearbyMush.position.clone().sub(dogPos).normalize();
                setPetYaw(Math.atan2(dir.x, dir.z));
                showThought("(å‘ç°å°è˜‘è‡ï¼)");
                
                // Eating animation
                corgiBody.rotation.x = 0.35; 
                headGroup.rotation.x = 0.25;
                if(propFood) propFood.visible = true;

                setTimeout(() => {
                    showThought("å§å”§å§å”§...");
                }, 1000);

                setTimeout(() => {
                    corgiBody.rotation.x = 0;
                    headGroup.rotation.x = 0;
                    if(propFood) propFood.visible = false;
                    showThought("å‘³é“çœŸä¸é”™~");
                    petStatus.health = Math.min(100, petStatus.health + 3);
                    updateStatusUI();
                }, 3000);
                return;
            }

            // E. Stones (Jump)
            let nearbyStone = stones.find(s => dogPos.distanceTo(s.position) < 2.0);
            if (nearbyStone && Math.random() < 0.02) {
                const dir = nearbyStone.position.clone().sub(dogPos).normalize();
                setPetYaw(Math.atan2(dir.x, dir.z));
                let count = 0;
                const jump = setInterval(() => {
                    corgiBody.position.y = Math.abs(Math.sin(count)) * 0.35;
                    count += 0.25;
                    if(count > Math.PI*4) { clearInterval(jump); corgiBody.position.y = 0; }
                }, 30);
                showThought("(è·³ä¸ŠçŸ³å¤´ï¼)");
                return;
            }

            const wanderRoll = Math.random();
            if (wanderRoll < 0.1) {
                let moved = false;
                for(let k=0; k<4; k++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 0.5 + Math.random() * 1.5;
                    let tx = dogPos.x + Math.cos(angle) * dist;
                    let tz = dogPos.z + Math.sin(angle) * dist;
                    if(tx > 30) tx = 30; if(tx < -30) tx = -30;
                    if(tz > 30) tz = 30; if(tz < -30) tz = -30;
                    const dest = new THREE.Vector3(tx, 0, tz);
                    let inPond = false;
                    for(let p of ponds) {
                        if(dest.distanceTo(p.position) < p.radius + 1.5) { inPond = true; break; }
                    }
                    if(!inPond && isValidPos(dest)) {
                        targetPos.copy(dest);
                        currentState = STATE.RUN;
                        didWanderAfterOwnerIdle = true;
                        if(texts && texts.move) showThought(texts.move);
                        else showThought("(åˆ°å¤„èµ°èµ°...)");
                        moved = true;
                        break;
                    }
                }
                if(moved) return;
            }

            const idleRoll = Math.random();
            if (idleRoll < 0.33) {
                showThought("(åä¸€ä¼š...)");
                const origX = corgiBody.rotation.x;
                corgiBody.rotation.x = -Math.PI / 12;
                setTimeout(() => {
                    corgiBody.rotation.x = origX;
                }, 3000);
            } else if (idleRoll < 0.66) {
                showThought("(è¶´ä¸€ä¼š...)");
                const origX = corgiBody.rotation.x;
                corgiBody.rotation.x = Math.PI / 16;
                setTimeout(() => {
                    corgiBody.rotation.x = origX;
                }, 3000);
            } else {
                if (currentPet === 'cat') showThought("åœ¨èˆ”æ¯›...");
                else showThought("(æ•´ç†ä¸€ä¸‹æ¯›å‘...)");
                let c = 0;
                const g = setInterval(() => {
                    headGroup.rotation.x = 0.25 + Math.sin(c) * 0.15;
                    c += 0.4;
                    if(c > Math.PI * 2) {
                        clearInterval(g);
                        headGroup.rotation.x = 0;
                    }
                }, 50);
            }
        }
    }

    // --- äº¤äº’ç‚¹å‡» ---
    window.addEventListener('pointerup', (e) => {
        if(e.button !== 0 || e.target.closest('.glass-panel') || e.target.closest('#chat-layer') || e.target.closest('#interaction-panel') || e.target.closest('#pet-selector') || e.target.closest('.modal-overlay')) return;
        if (isForcedSleepTime()) {
            currentState = STATE.SLEEP;
            if(targetRing) targetRing.visible = false;
            showThought("Zzz...");
            return;
        }

        mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse, camera);

        // 1. ä¼˜å…ˆæ£€æµ‹ç‚¹å‡»å® ç‰©
        const petHits = raycaster.intersectObjects(corgiGroup.children, true);
        if(petHits.length > 0) {
            const texts = PET_BEHAVIOR_TEXT[currentPet];
            showThought(texts.click[Math.floor(Math.random() * texts.click.length)]);
            
            // æ’’å¨‡åŠ¨ç”»
            corgiBody.position.y = 0.3;
            setTimeout(() => corgiBody.position.y = 0, 200);
            setTimeout(() => corgiBody.position.y = 0.3, 300);
            setTimeout(() => corgiBody.position.y = 0, 500);
            return;
        }

        // 2. ç‚¹å‡»åœ°é¢ç§»åŠ¨ (ä»…å½“æ²¡ç‚¹åˆ°å® ç‰©æ—¶)
        const hits = raycaster.intersectObject(ground);
        if(hits.length > 0) {
            let p = hits[0].point.clone();
            if(p.length() > WORLD_RADIUS - 1) { p.normalize().multiplyScalar(WORLD_RADIUS - 1); }
            for(let pond of ponds){
                const d = p.distanceTo(pond.position);
                if(d < pond.radius + 0.8){
                    const dir = p.clone().sub(pond.position).normalize();
                    p = pond.position.clone().add(dir.multiplyScalar(pond.radius + 1.2));
                }
            }
            targetPos.copy(p);
            targetRing.position.set(p.x, 0.05, p.z);
            targetRing.visible = true; targetRing.scale.set(0,0,0);
            if(targetRing.userData.anim) clearInterval(targetRing.userData.anim);
            let s=0; targetRing.userData.anim = setInterval(()=>{ s+=0.2; targetRing.scale.set(s,s,s); if(s>=1)clearInterval(targetRing.userData.anim);},16);
            currentState = STATE.RUN;
            // é‡ç½®è‡ªä¸»è¡Œä¸ºè®¡æ—¶ï¼Œé¿å…ç§»åŠ¨ä¸­è§¦å‘
            lastBehaviorTime = Date.now() * 0.001;
            lastOwnerInteractionTime = lastBehaviorTime;
            didWanderAfterOwnerIdle = false;
        }
    });

    // --- äº¤äº’é“å…· (Props) ---
    const propGroup = new THREE.Group();
    corgiGroup.add(propGroup);
    
    let propFood, propComb, propToy;
    
    function createProps() {
        // Food (Bone/Carrot)
        propFood = new THREE.Group();
        const fMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8), new THREE.MeshStandardMaterial({color: 0xFF5722}));
        fMesh.rotation.z = Math.PI/2;
        propFood.add(fMesh);
        const fBoneL = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshStandardMaterial({color: 0xFFCCBC}));
        fBoneL.position.x = -0.15; propFood.add(fBoneL);
        const fBoneR = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshStandardMaterial({color: 0xFFCCBC}));
        fBoneR.position.x = 0.15; propFood.add(fBoneR);
        propFood.visible = false; 
        // propFood will be attached to headGroup in attachPropsToPet

        // Comb
        propComb = new THREE.Group();
        const cHandle = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.1), new THREE.MeshStandardMaterial({color: 0x8D6E63}));
        propComb.add(cHandle);
        for(let i=0; i<6; i++) {
            const t = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.1, 0.02), new THREE.MeshStandardMaterial({color: 0xD7CCC8}));
            t.position.set(-0.1 + i*0.04, -0.08, 0);
            propComb.add(t);
        }
        propComb.visible = false;
        // propComb will be attached to corgiBody in attachPropsToPet

        // Toy (Ball)
        propToy = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), new THREE.MeshStandardMaterial({color: 0xFDD835}));
        propToy.visible = false;
        // propToy will be attached to headGroup in attachPropsToPet
    }
    createProps();

    // --- ç¯å¢ƒç”Ÿæˆ (Refined for Reference Image & User Requests) ---
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x50C878, roughness: 1, flatShading: true })); // Emerald Green
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    const trees = []; 
    const bushes = [];
    var flowerInstances = [];
    var flowerStemMesh, flowerPetalMesh, flowerCenterMesh, flowerLeafMesh;
    const ponds = []; 
    const mushrooms = []; 
    
    // Helper to attach props after pet rebuild
    function attachPropsToPet() {
        if(!headGroup || !corgiBody) return;
        
        // Detach from previous parent if any
        if(propFood.parent) propFood.parent.remove(propFood);
        if(propComb.parent) propComb.parent.remove(propComb);
        if(propToy.parent) propToy.parent.remove(propToy);

        // Attach Food (Mouth) & Toy (Head Top) to Head
        headGroup.add(propFood);
        headGroup.add(propToy);
        
        // Attach Comb (Body) to Body
        corgiBody.add(propComb);

        // Set Positions based on Pet Type
        if(currentPet === 'corgi') {
            propFood.position.set(0, -0.2, 0.5);
            propToy.position.set(0, 0.45, 0);
            propComb.position.set(0, 0.5, 0);
        } else if(currentPet === 'rabbit') {
            propFood.position.set(0, -0.1, 0.3);
            propToy.position.set(0, 0.5, 0); // Between ears
            propComb.position.set(0, 0.4, 0);
        } else if(currentPet === 'cat') {
            propFood.position.set(0, -0.15, 0.35);
            propToy.position.set(0, 0.4, 0);
            propComb.position.set(0, 0.45, 0);
        }
        
        // Reset visibility (controlled by interact)
        propFood.visible = false;
        propComb.visible = false;
        propToy.visible = false;
    }

    var stones = [];
var maxTrunkTop = 2.5;
    function createNature() {
        const treeMat = new THREE.MeshStandardMaterial({color: 0x795548, flatShading:true});
        const leafMat = new THREE.MeshStandardMaterial({color: 0xA5D6A7, flatShading: true});
        const leafMat2 = new THREE.MeshStandardMaterial({color: 0x9CCC65, flatShading: true});
        const bushMat = new THREE.MeshStandardMaterial({color: 0x7CB342, flatShading:true});
        const pondMat = new THREE.MeshStandardMaterial({color: 0x29B6F6, roughness: 0.1, metalness: 0.1, opacity: 0.8, transparent: true});
        const mushStemMat = new THREE.MeshStandardMaterial({color: 0xFFE0B2});
        const mushCapMat = new THREE.MeshStandardMaterial({color: 0xE57373});

        // Audio Setup (Moved to top)
        const listener = window.__audioListener || new THREE.AudioListener();
        if(!window.__audioListener) {
            camera.add(listener);
            window.__audioListener = listener;
        }
        const audioCtx = listener.context;
        if(window.__ambientIntervals && window.__ambientIntervals.length) {
            window.__ambientIntervals.forEach(id => { try{ clearInterval(id); }catch(e){} });
        }
        window.__ambientIntervals = [];
        if(window.__ambientSounds && window.__ambientSounds.length) {
            window.__ambientSounds.forEach(s => { try{ s.stop(); }catch(e){} });
        }
        window.__ambientSounds = [];

        if(!window.__bilibiliAmbientAdded) {
            const startBilibiliAmbient = () => {
                if(window.__bilibiliAmbientIframe) return;
                const iframe = document.createElement('iframe');
                iframe.src = 'https://player.bilibili.com/player.html?bvid=BV1wE2GBQETT&page=1&autoplay=1&danmaku=0&high_quality=1';
                iframe.allow = 'autoplay; fullscreen; encrypted-media';
                iframe.referrerPolicy = 'no-referrer';
                iframe.style.position = 'fixed';
                iframe.style.left = '0';
                iframe.style.top = '0';
                iframe.style.width = '1px';
                iframe.style.height = '1px';
                iframe.style.opacity = '0';
                iframe.style.border = '0';
                iframe.style.pointerEvents = 'none';
                iframe.style.zIndex = '-1';
                document.body.appendChild(iframe);
                window.__bilibiliAmbientIframe = iframe;
            };
            document.addEventListener('pointerdown', startBilibiliAmbient, { once: true });
            document.addEventListener('touchstart', startBilibiliAmbient, { once: true });
            document.addEventListener('keydown', startBilibiliAmbient, { once: true });
            document.addEventListener('click', startBilibiliAmbient, { once: true });
            window.__bilibiliAmbientAdded = true;
        }

        // 4. Ponds (Generated first)
        let lakeMesh = null;
        let lakeCubeCamera = null;
        const pondGeo = new THREE.CircleGeometry(4, 32);
        for(let i=0; i<5; i++) {
            const x=(Math.random()-0.5)*100, z=(Math.random()-0.5)*100; // Reduced from 120
            if(Math.abs(x)<10 && Math.abs(z)<10) continue;
            
            const pond = new THREE.Mesh(pondGeo, pondMat);
            pond.rotation.x = -Math.PI/2;
            pond.position.set(x, 0.02, z);
            pond.scale.set(1+Math.random(), 0.8+Math.random(), 1);
            
            if(!lakeMesh) {
                pond.scale.set(3.2, 3.2, 1);
                pond.position.y = 0.018;

                const lakeRT = new THREE.WebGLCubeRenderTarget(256, {
                    format: THREE.RGBAFormat,
                    generateMipmaps: true,
                    minFilter: THREE.LinearMipmapLinearFilter
                });
                lakeRT.texture.encoding = THREE.sRGBEncoding;

                const lakeMat = new THREE.MeshStandardMaterial({
                    color: 0x0b2a3a,
                    roughness: 0.035,
                    metalness: 0.95,
                    envMap: lakeRT.texture,
                    envMapIntensity: 1.15,
                    transparent: true,
                    opacity: 0.92
                });
                pond.material = lakeMat;

                lakeCubeCamera = new THREE.CubeCamera(0.1, 5000, lakeRT);
                lakeCubeCamera.position.copy(pond.position);
                scene.add(lakeCubeCamera);

                lakeMesh = pond;
                window.lakeMesh = lakeMesh;
                window.lakeCubeCamera = lakeCubeCamera;
                window.lakeUpdateTick = 0;
            }

            scene.add(pond);
            const pondRadius = 4 * (lakeMesh === pond ? Math.max(pond.scale.x, pond.scale.y) : pond.scale.x);
            ponds.push({ position: new THREE.Vector3(x, 0, z), radius: pondRadius });
            
            // Stones (Outside pond - Fixed position)
            for(let k=0; k<6; k++) {
                const stone = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3, 0), new THREE.MeshStandardMaterial({color:0x9E9E9E}));
                const a = (k/6)*Math.PI*2 + (Math.random()-0.5)*0.2;
                // Use ellipse radii to ensure outside
                const rx = 4 * pond.scale.x + 0.35;
                const rz = 4 * pond.scale.y + 0.35;
                
                stone.position.set(x + Math.cos(a)*rx, 0.05, z + Math.sin(a)*rz);
                stone.rotation.set(Math.random(), Math.random(), Math.random());
                scene.add(stone);
                stones.push({ position: stone.position.clone(), radius: 0.35 });
            }
        }

        // 7. Streams (Winding Brooks & Sounds) - Moved here for collision
        window.streamCurves = [];
        const flowCanvas = document.createElement('canvas');
        flowCanvas.width = 256;
        flowCanvas.height = 32;
        const flowCtx = flowCanvas.getContext('2d');
        flowCtx.fillStyle = '#1b8cff';
        flowCtx.fillRect(0, 0, flowCanvas.width, flowCanvas.height);
        for(let i=0; i<60; i++) {
            const x = Math.random() * flowCanvas.width;
            const y = Math.random() * flowCanvas.height;
            const w = 12 + Math.random() * 60;
            const h = 1 + Math.random() * 2;
            flowCtx.fillStyle = `rgba(255,255,255,${0.06 + Math.random() * 0.12})`;
            flowCtx.fillRect(x, y, w, h);
        }
        const streamFlowTex = new THREE.CanvasTexture(flowCanvas);
        streamFlowTex.wrapS = THREE.RepeatWrapping;
        streamFlowTex.wrapT = THREE.RepeatWrapping;
        streamFlowTex.repeat.set(18, 1);
        streamFlowTex.offset.set(0, 0);
        window.streamFlowTex = streamFlowTex;
        const streamMat = new THREE.MeshStandardMaterial({
            color: 0x1b8cff,
            map: streamFlowTex,
            roughness: 0.02,
            metalness: 0.0,
            emissive: new THREE.Color(0x107bb0),
            emissiveIntensity: 1.2,
            transparent: true,
            opacity: 0.98,
            side: THREE.DoubleSide,
            depthWrite: true,
            polygonOffset: true,
            polygonOffsetFactor: -1,
            polygonOffsetUnits: -1
        });
        
        // Rock Instanced Mesh for Streams
        const rockGeo = new THREE.DodecahedronGeometry(0.2, 0); // Low poly rock
        const rockMat = new THREE.MeshStandardMaterial({color: 0x757575, flatShading: true});
        const rockCount = 1500;
        const rockMesh = new THREE.InstancedMesh(rockGeo, rockMat, rockCount);
        scene.add(rockMesh);
        let rockIdx = 0;
        const rockDummy = new THREE.Object3D();

        const streamCount = 4;
        const streamCenters = [
            new THREE.Vector2(-42, -42),
            new THREE.Vector2(42, -42),
            new THREE.Vector2(-42, 42),
            new THREE.Vector2(42, 42)
        ];
        const streamMeshes = [];
        window.streamMeshes = streamMeshes;

        const placedStreamPoints = [];

        const createStreamFlowBuffer = () => {
            const durationSec = 6;
            const buffer = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * durationSec), audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            let brown = 0;
            let slow = 0;
            let slow2 = 0;
            let maxAbs = 1e-6;
            const p1 = Math.random() * Math.PI * 2;
            const p2 = Math.random() * Math.PI * 2;
            for(let i=0; i<data.length; i++) {
                const white = Math.random() * 2 - 1;
                brown = (brown + 0.012 * white) / 1.012;
                slow = slow * 0.9995 + white * 0.0005;
                slow2 = slow2 * 0.99975 + white * 0.00025;
                const t = i / audioCtx.sampleRate;
                const swell = 0.65 + 0.35 * Math.sin(t * Math.PI * 2 * 0.17 + p1);
                const texture = 0.75 + 0.25 * Math.tanh(2.2 * slow);
                const gurgle = 0.85 + 0.15 * Math.sin(t * Math.PI * 2 * (0.85 + 0.25 * Math.abs(slow2)) + p2);
                const splash = Math.tanh(2.0 * (white * 0.55 + slow * 0.45));
                const v = (brown * 2.4 + splash * 0.25) * swell * texture * gurgle;
                data[i] = v;
                const av = Math.abs(v);
                if(av > maxAbs) maxAbs = av;
            }
            const inv = 0.9 / maxAbs;
            for(let i=0; i<data.length; i++) data[i] *= inv;
            return buffer;
        };

        for(let i=0; i<streamCount; i++) {
            const center = streamCenters[i].clone().add(new THREE.Vector2((Math.random()-0.5)*6, (Math.random()-0.5)*6));
            if(Math.abs(center.x) < 15 && Math.abs(center.y) < 15) center.add(new THREE.Vector2(center.x < 0 ? -20 : 20, center.y < 0 ? -20 : 20));

            const points = [];
            const segs = 18;
            const a0 = Math.random() * Math.PI * 2;
            const baseR = 14 + Math.random() * 7;
            const e = 0.8 + Math.random() * 0.4;
            const wob = 1.5 + Math.random() * 2.5;
            const wobF = 2 + Math.floor(Math.random() * 3);

            for(let j=0; j<segs; j++) {
                const a = a0 + (j / segs) * Math.PI * 2;
                const r = baseR * (0.85 + Math.random() * 0.3) + Math.sin(a * wobF) * wob;
                let x = center.x + Math.cos(a) * r;
                let z = center.y + Math.sin(a) * r * e;

                for(let p of ponds) {
                    const dx = x - p.position.x;
                    const dz = z - p.position.z;
                    const d = Math.sqrt(dx*dx + dz*dz) + 1e-6;
                    const minD = p.radius + 6.0;
                    if(d < minD) {
                        const push = (minD - d);
                        x += (dx / d) * push;
                        z += (dz / d) * push;
                    }
                }

                if(center.x < 0) x = Math.min(x, -6);
                else x = Math.max(x, 6);
                if(center.y < 0) z = Math.min(z, -6);
                else z = Math.max(z, 6);

                for(let s=0; s<placedStreamPoints.length; s++) {
                    const sp = placedStreamPoints[s];
                    const dx = x - sp.x;
                    const dz = z - sp.y;
                    const d = Math.sqrt(dx*dx + dz*dz) + 1e-6;
                    const minSep = 10.5;
                    if(d < minSep) {
                        const push = (minSep - d);
                        x += (dx / d) * push;
                        z += (dz / d) * push;
                    }
                }

                const clampR = 56;
                const len = Math.sqrt(x*x + z*z);
                if(len > clampR) {
                    x = (x / len) * clampR;
                    z = (z / len) * clampR;
                }

                points.push(new THREE.Vector3(x, 0.015, z));
            }

            const mainPath = new THREE.CatmullRomCurve3(points, true);
            const radius = 1.35 + Math.random() * 0.35;
            const tube = new THREE.TubeGeometry(mainPath, 180, radius, 10, true);
            tube.scale(1, 0.075, 1);
            const mesh = new THREE.Mesh(tube, streamMat);
            scene.add(mesh);
            streamMeshes.push(mesh);

            const spacingPts = mainPath.getSpacedPoints(60);
            for(let s=0; s<spacingPts.length; s++) {
                placedStreamPoints.push(new THREE.Vector2(spacingPts[s].x, spacingPts[s].z));
            }

            const curvePoints = mainPath.getSpacedPoints(80);
            window.streamCurves.push({ curve: mainPath, radius: radius + 0.65, points: curvePoints });

            for(let k=0; k<=140; k++) {
                if(Math.random() > 0.45) continue;
                const t = k/140;
                const pos = mainPath.getPoint(t);
                const tan = mainPath.getTangent(t);
                const perp = new THREE.Vector3(-tan.z, 0, tan.x).normalize();

                const placeInside = Math.random() < 0.22;
                let side = Math.random() < 0.5 ? 1 : -1;
                let dist;
                let scale;

                if(placeInside) {
                    dist = Math.random() * (radius * 0.55);
                    scale = 0.18 + Math.random() * 0.26;
                    rockDummy.position.y = 0.05;
                } else {
                    dist = radius + 0.55 + Math.random() * 0.75;
                    scale = 0.45 + Math.random() * 0.8;
                    rockDummy.position.y = 0.1;
                }

                rockDummy.position.copy(pos).add(perp.multiplyScalar(side * dist));
                rockDummy.scale.setScalar(scale);
                rockDummy.rotation.set(Math.random(), Math.random(), Math.random());
                rockDummy.updateMatrix();
                if(rockIdx < rockCount) rockMesh.setMatrixAt(rockIdx++, rockDummy.matrix);
            }
        }
        rockMesh.count = rockIdx;
        rockMesh.instanceMatrix.needsUpdate = true;

        // --- Instanced Trees ---
        const treeCount = 300; // Increased density
        // Geometries
        const trunkGeo = new THREE.CylinderGeometry(0.18, 0.24, 1.5, 8); 
        const branchGeo = new THREE.CylinderGeometry(0.01, 0.1, 0.6, 4); // Polyhedral Cone: Small top, large bottom, 4 sides
        const crownGeo = new THREE.IcosahedronGeometry(0.8, 0);

        // Instanced Meshes
        // Max estimations: Branches=4/tree (2 main + 2 new side), Base=8/tree, Mid=1/tree
        const trunkMesh = new THREE.InstancedMesh(trunkGeo, treeMat, treeCount);
        const branchMesh = new THREE.InstancedMesh(branchGeo, treeMat, treeCount * 4);
        const crownBaseMesh = new THREE.InstancedMesh(crownGeo, leafMat2, treeCount * 9); 
        const crownMidMesh = new THREE.InstancedMesh(crownGeo, leafMat, treeCount);

        trunkMesh.castShadow = true; trunkMesh.receiveShadow = true;
        branchMesh.castShadow = true; branchMesh.receiveShadow = true;
        crownBaseMesh.castShadow = true; crownBaseMesh.receiveShadow = true;
        crownMidMesh.castShadow = true; crownMidMesh.receiveShadow = true;

        scene.add(trunkMesh); scene.add(branchMesh); scene.add(crownBaseMesh); scene.add(crownMidMesh);

        let trunkIdx=0, branchIdx=0, baseIdx=0, midIdx=0;
        const dummyTree = new THREE.Group();
        const dTrunk = new THREE.Mesh(trunkGeo); dummyTree.add(dTrunk);
        // Existing branches (dB1, dB2)
        const dB1 = new THREE.Mesh(branchGeo); dTrunk.add(dB1);
        const dB2 = new THREE.Mesh(branchGeo); dTrunk.add(dB2);
        // New side branches (dB3, dB4) - Diagonal upwards
        const dB3 = new THREE.Mesh(branchGeo); dTrunk.add(dB3);
        const dB4 = new THREE.Mesh(branchGeo); dTrunk.add(dB4);
        
        const dCrown = new THREE.Group(); dummyTree.add(dCrown);
        const dMid = new THREE.Mesh(crownGeo); dCrown.add(dMid);
        const dSubs = [];
        for(let k=0; k<9; k++) { const s=new THREE.Mesh(crownGeo); dCrown.add(s); dSubs.push(s); }

        for(let i=0; i<treeCount; i++) { 
            const x = (Math.random() - 0.5) * 160; // Widened to match streams
            const z = (Math.random() - 0.5) * 160; 
            if(Math.abs(x)<5 && Math.abs(z)<5) continue; 
            let inPond = false;
            for(let p of ponds) {
                if(new THREE.Vector3(x,0,z).distanceTo(p.position) < p.radius + 2.0) { inPond = true; break; }
            }
            if(inPond) continue;

            // Setup dummy tree hierarchy
            const scaleH = 0.8 + Math.random() * 0.8; 
            dummyTree.position.set(x, 0, z);
            dummyTree.rotation.y = Math.random() * Math.PI * 2;
            const scaleXZ = 0.85 + Math.random() * 0.55;
            dummyTree.scale.set(scaleXZ, 1, scaleXZ);
            
            // Trunk
            dTrunk.position.y = 0.75 * scaleH;
            dTrunk.scale.set(1, scaleH, 1);
            
            // Branches (Existing upper branches)
            dB1.position.set(0.12, 0.55 * scaleH, 0);
            dB1.rotation.set(-0.2, Math.random(), 0.45);
            dB2.position.set(-0.12, 0.55 * scaleH, 0);
            dB2.rotation.set(-0.2, dB1.rotation.y + Math.PI, -0.45);

            // New Side Branches (Diagonal Upwards below crown)
            // Left Branch
            // Position lowered significantly to 0.35 (lower trunk) to ensure visibility below crown
            // Angled outwards more (0.5 rad) and scaled up
            dB3.position.set(-0.3, 0.35, 0); 
            dB3.rotation.set(0, 0, 0.5); // ~30 degrees
            dB3.scale.set(0.4, 2.0, 0.4); // Thinner (Half width)
            
            // Right Branch
            dB4.position.set(0.3, 0.4, 0);
            dB4.rotation.set(0, 0, -0.5); 
            dB4.scale.set(0.4, 2.0, 0.4); // Thinner (Half width)

            // Crown
            dCrown.position.y = 1.8 * scaleH;
            
            // Randomize Crown Size (0.5x - 1.5x) -> Scaled towards 0.8x avg
            const crownScale = 0.6 + Math.random() * 0.4; // 0.6 to 1.0 
            
            // Center crown with slight random jitter
            dMid.position.set(0, 0.2, 0); 
            dMid.rotation.set(0, Math.random() * Math.PI, 0); 
            dMid.scale.setScalar(crownScale); 

            // Subs (Regular arrangement with controlled randomness)
            const baseCount = 8; 
            for(let k=0; k<9; k++) {
                if(k < baseCount) {
                    dSubs[k].visible = true;
                    
                    // Regular circle arrangement (Less jitter)
                    const ang = (k/baseCount)*Math.PI*2; 
                    const r = 0.6 * crownScale; // Scale radius too
                    
                    dSubs[k].position.set(Math.cos(ang)*r, -0.35 * crownScale, Math.sin(ang)*r); 
                    
                    // Aligned rotation (Regular look)
                    dSubs[k].rotation.set(0, ang, 0); 
                    
                    // Uniform scale
                    dSubs[k].scale.setScalar(0.85 * crownScale); 
                } else {
                    dSubs[k].visible = false;
                    dSubs[k].scale.setScalar(0); // Hide
                }
            }

            // Update matrices
            dummyTree.updateMatrixWorld(true);

            // Copy to instances
            trunkMesh.setMatrixAt(trunkIdx++, dTrunk.matrixWorld);
            branchMesh.setMatrixAt(branchIdx++, dB1.matrixWorld);
            branchMesh.setMatrixAt(branchIdx++, dB2.matrixWorld);
            branchMesh.setMatrixAt(branchIdx++, dB3.matrixWorld);
            branchMesh.setMatrixAt(branchIdx++, dB4.matrixWorld);
            crownMidMesh.setMatrixAt(midIdx++, dMid.matrixWorld);
            for(let k=0; k<baseCount; k++) {
                crownBaseMesh.setMatrixAt(baseIdx++, dSubs[k].matrixWorld);
            }

            trees.push({ position: new THREE.Vector3(x, 0, z), radius: 1.0 });
        }
        // Trim unused
        trunkMesh.count = trunkIdx;
        branchMesh.count = branchIdx;
        crownMidMesh.count = midIdx;
        crownBaseMesh.count = baseIdx;
        trunkMesh.instanceMatrix.needsUpdate = true;
        branchMesh.instanceMatrix.needsUpdate = true;
        crownMidMesh.instanceMatrix.needsUpdate = true;
        crownBaseMesh.instanceMatrix.needsUpdate = true;


        // --- Instanced Bushes ---
        const bushCount = 500; 
        
        // 3 Levels of Detail (Face counts: Low, Mid, High)
        const bushGeoLow = new THREE.IcosahedronGeometry(0.32, 0); // 20 faces
        const bushGeoMid = new THREE.IcosahedronGeometry(0.32, 1); // 80 faces
        const bushGeoHigh = new THREE.IcosahedronGeometry(0.32, 2); // 320 faces

        const bushMeshLow = new THREE.InstancedMesh(bushGeoLow, bushMat, bushCount * 8);
        const bushMeshMid = new THREE.InstancedMesh(bushGeoMid, bushMat, bushCount * 8);
        const bushMeshHigh = new THREE.InstancedMesh(bushGeoHigh, bushMat, bushCount * 8);

        bushMeshLow.castShadow = true; bushMeshLow.receiveShadow = true;
        bushMeshMid.castShadow = true; bushMeshMid.receiveShadow = true;
        bushMeshHigh.castShadow = true; bushMeshHigh.receiveShadow = true;

        scene.add(bushMeshLow); scene.add(bushMeshMid); scene.add(bushMeshHigh);
        
        let bIdxLow = 0, bIdxMid = 0, bIdxHigh = 0;
        
        const dummyBush = new THREE.Group();
        const bParts = [];
        // Geometry doesn't matter for dummy parts logic, just transforms
        for(let i=0; i<8; i++) { const p=new THREE.Mesh(bushGeoMid); dummyBush.add(p); bParts.push(p); }
        const _bMinV = new THREE.Vector3();
        const _bMat = new THREE.Matrix4();

        for(let i=0; i<bushCount; i++) {
            // More random distribution (Polar + Cartesian mix)
            let x, z;
            if(Math.random() < 0.6) { // Increased polar chance for more clusters
                // Circular cluster
                const r = 15 + Math.random() * 90; // Slightly varied range
                const theta = Math.random() * Math.PI * 2;
                x = Math.cos(theta) * r;
                z = Math.sin(theta) * r;
            } else {
                // Random scatter
                x = (Math.random()-0.5)*180; // Wider scatter
                z = (Math.random()-0.5)*180;
            }

            if(Math.abs(x)<5 && Math.abs(z)<5) continue;
            let nearPond=false; for(let p of ponds){ if(new THREE.Vector3(x,0,z).distanceTo(p.position) < p.radius + 0.5){ nearPond=true; break; } }
            if(nearPond) continue;

            let nearStream = false;
            for(let sData of window.streamCurves) {
                for(let pt of sData.points) {
                    if(new THREE.Vector3(x,0,z).distanceTo(pt) < sData.radius + 0.8) { // Stream radius + Bush radius buffer
                        nearStream = true; break; 
                    }
                }
                if(nearStream) break;
            }
            if(nearStream) continue;

            dummyBush.position.set(x, 0, z);

            // Select Detail Level (Random from small to large)
            const detailRand = Math.random();
            let targetMesh;
            if(detailRand < 0.4) { // 40% Low
                targetMesh = bushMeshLow;
            } else if(detailRand < 0.75) { // 35% Mid
                targetMesh = bushMeshMid;
            } else { // 25% High
                targetMesh = bushMeshHigh;
            }

            const partCount = 5 + Math.floor(Math.random() * 4); // 5..8
            const levels = 3 + Math.floor(Math.random() * 2); // 3..4
            const baseScale = 0.55 + Math.random() * 0.35;
            const yStep = 0.16 + Math.random() * 0.06;

            const partGeo = targetMesh.geometry;
            const posAttr = partGeo.attributes.position;
            let minBottomY = Infinity;

            for(let k=0; k<8; k++) {
                if(k >= partCount) {
                    bParts[k].position.set(0, 0, 0);
                    bParts[k].scale.setScalar(0);
                    continue;
                }

                const level = Math.min(levels - 1, Math.floor((k / partCount) * levels));
                const levelRatio = levels === 1 ? 0 : (level / (levels - 1));

                const maxR = 0.45 - level * 0.12;
                const r = Math.max(0, maxR) * (0.4 + Math.random() * 0.7);
                const ang = Math.random() * Math.PI * 2;

                const px = Math.cos(ang) * r;
                const pz = Math.sin(ang) * r;
                const py = level * yStep + (Math.random() - 0.5) * 0.03;

                const s = baseScale * (1.0 - levelRatio * 0.4) * (0.75 + Math.random() * 0.35);

                bParts[k].position.set(px, py, pz);
                bParts[k].scale.setScalar(Math.max(0.08, s));
                bParts[k].rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

                _bMat.compose(bParts[k].position, bParts[k].quaternion, bParts[k].scale);
                let partMinY = Infinity;
                for(let vi=0; vi<posAttr.count; vi++) {
                    _bMinV.fromBufferAttribute(posAttr, vi).applyMatrix4(_bMat);
                    if(_bMinV.y < partMinY) partMinY = _bMinV.y;
                }
                if(partMinY < minBottomY) minBottomY = partMinY;
            }

            if(minBottomY !== Infinity) {
                const yShift = -minBottomY;
                for(let k=0; k<partCount; k++) {
                    bParts[k].position.y += yShift;
                }
            }

            dummyBush.updateMatrixWorld(true);
            for(let k=0; k<8; k++) {
                if(targetMesh === bushMeshLow) bushMeshLow.setMatrixAt(bIdxLow++, bParts[k].matrixWorld);
                else if(targetMesh === bushMeshMid) bushMeshMid.setMatrixAt(bIdxMid++, bParts[k].matrixWorld);
                else bushMeshHigh.setMatrixAt(bIdxHigh++, bParts[k].matrixWorld);
            }
            bushes.push({ position: new THREE.Vector3(x, 0.5, z), radius: 1.0 });
        }
        
        bushMeshLow.count = bIdxLow;
        bushMeshMid.count = bIdxMid;
        bushMeshHigh.count = bIdxHigh;
        
        bushMeshLow.instanceMatrix.needsUpdate = true;
        bushMeshMid.instanceMatrix.needsUpdate = true;
        bushMeshHigh.instanceMatrix.needsUpdate = true;

        // 3. Mountains (Distant Background) - Varied Distance for Fading
        const mountainColors = [
            0x1B5E20, 0x2E7D32, 0x388E3C, 0x43A047, 0x2BAF84
        ];
        
        const generatedMountains = [];
        const mountainCount = 48; // Increased for more overlap

        for(let i=0; i<mountainCount; i++) {
            // Clustered distribution with more randomness
            const angle = (i / mountainCount) * Math.PI * 2 + (Math.random()-0.5) * 0.8; 
            const r = 1200 + Math.random() * 1500; // Pushed further away
            
            const s = (70 + Math.random() * 50) * 1.8; // Larger mountains
            
            const mMat = new THREE.MeshStandardMaterial({ 
                color: mountainColors[Math.floor(Math.random()*mountainColors.length)],
                roughness: 0.9
            });
            
            const mGeom = new THREE.SphereGeometry(s, 16, 12, 0, Math.PI*2, 0, Math.PI/2);
            const m = new THREE.Mesh(mGeom, mMat);
            const scaleY = 1.2 + Math.random()*1.0;
            m.scale.set(1 + Math.random()*0.6, scaleY, 1 + Math.random()*0.6); 
            m.position.set(Math.cos(angle)*r, -20, Math.sin(angle)*r);
            
            // Notch effect
            const posAttr = m.geometry.attributes.position;
            const notch = 0.15;
            for(let vi=0; vi<posAttr.count; vi++){
                const x = posAttr.getX(vi), y = posAttr.getY(vi), z = posAttr.getZ(vi);
                const yn = (y + s*0.0) / s;
                const g = 1 - notch * Math.exp(-((yn - 0.45)*(yn - 0.45))/0.02);
                posAttr.setX(vi, x * g);
                posAttr.setZ(vi, z * g);
            }
            posAttr.needsUpdate = true;
            scene.add(m);

            generatedMountains.push({
                mesh: m,
                x: m.position.x,
                z: m.position.z,
                radius: s * m.scale.x * 0.85 // Approx effective radius
            });
        }

        // Waterfalls at Junctions (Sound removed)
        window.waterfallUniforms = { time: { value: 0 } };
        // Add fog uniforms manually to preserve reference for animation loop
        if (THREE.UniformsLib && THREE.UniformsLib.fog) {
            const fogU = THREE.UniformsUtils.clone(THREE.UniformsLib.fog);
            Object.assign(window.waterfallUniforms, fogU);
        }

        const waterfallMat = new THREE.ShaderMaterial({
            uniforms: window.waterfallUniforms,
            fog: true,
            vertexShader: `
                varying vec2 vUv;
                varying float vDist;
                #include <fog_pars_vertex>
                void main() {
                    vUv = uv;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vDist = -mvPosition.z;
                    gl_Position = projectionMatrix * mvPosition;
                    #include <fog_vertex>
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                varying float vDist;
                
                #include <fog_pars_fragment>

                // Simple pseudo-random
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    // Flowing water effect (Downward, Fast)
                    float flow = mod((1.0 - vUv.y) * 8.0 - time * 2.5, 1.0);
                    
                    // Vertical streaks (Grand scale)
                    float streaks = sin(vUv.x * 120.0) * 0.5 + 0.5;
                    streaks += sin(vUv.x * 40.0 + flow * 5.0) * 0.4;
                    
                    // Sparkles (The "Milky Way" stars effect)
                    float noise = random(vUv * vec2(100.0, 50.0) + vec2(0.0, time * 5.0));
                    float sparkle = step(0.97, noise) * (1.0 - vUv.y); // More sparkles at top

                    // Foam/Mist
                    float foam = step(0.8, flow * streaks);
                    
                    // Soft edges
                    float alpha = smoothstep(0.0, 0.15, vUv.x) * (1.0 - smoothstep(0.85, 1.0, vUv.x));
                    // Fade out at very bottom to simulate mist
                    alpha *= smoothstep(0.0, 0.15, vUv.y); 
                    
                    // Color: Silvery White / Light Cyan (Li Bai's "Silver River")
                    vec3 deepWater = vec3(0.8, 0.9, 1.0);
                    vec3 foamColor = vec3(1.0, 1.0, 1.0);
                    vec3 waterColor = mix(deepWater, foamColor, streaks * 0.5 + foam * 0.5 + sparkle);
                    
                    // --- Custom Fog Logic ---
                    #ifdef USE_FOG
                        float fogFactor = smoothstep(fogFar, fogNear, vDist);
                    #else
                        float fogFactor = 1.0;
                    #endif

                    // Boost brightness when close (fogFactor near 1)
                    // Fade to invisible when far (fogFactor near 0)
                    float brightness = 0.5 + fogFactor * 2.5; 
                    
                    // Apply fade (simulate invisibility in fog for Additive)
                    gl_FragColor = vec4(waterColor * brightness, alpha * 0.85 * fogFactor); 
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        for(let i=0; i<generatedMountains.length; i++) {
            for(let j=i+1; j<generatedMountains.length; j++) {
                const m1 = generatedMountains[i];
                const m2 = generatedMountains[j];
                const dx = m1.x - m2.x;
                const dz = m1.z - m2.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                const overlap = (m1.radius + m2.radius) - dist;

                // Create waterfall if significant overlap
                // Relaxed conditions: Allow gaps (overlap > -50) and closer mountains for MORE waterfalls
                if(overlap > -50 && dist > 10) { 
                    const midX = (m1.x + m2.x) / 2;
                    const midZ = (m1.z + m2.z) / 2;
                    
                    // Height: "Three thousand feet" - Make them HUGE
                    const m1Top = -20 + m1.radius * 1.0; 
                    const m2Top = -20 + m2.radius * 1.0;
                    
                    // Start from HIGH up (Higher of the two or close to it)
                    // "ä»é«˜å¤„æµè½" -> Start near max height
                    const maxTop = Math.max(m1Top, m2Top);
                    const intersectY = maxTop * 0.95; // Almost at the very top peak
                    
                    // Width: "ç»†å°" (Thin/Small) - Ensure positive width even if gap exists
                    // Base width 20, plus overlap factor
                    const wfWidth = Math.min(Math.max(20, (overlap + 60) * 0.5), 80); 
                    const wfHeight = 1400 + Math.random() * 600; // Even taller to reach ground from high up
                    
                    const wfGeo = new THREE.PlaneGeometry(wfWidth, wfHeight);
                    const wf = new THREE.Mesh(wfGeo, waterfallMat);
                    
                    // Push outward perpendicular to connection
                    const perpX = -dz / dist;
                    const perpZ = dx / dist;
                    const offset = 20; // Embedded in mountain
                    
                    // Determine outward direction (away from center 0,0 approx)
                    // Use dot product with mid-point to find "outward"
                    const dot = perpX * midX + perpZ * midZ;
                    const sign = dot > 0 ? 1 : -1;
                    
                    const posX = midX + perpX * sign * offset;
                    const posZ = midZ + perpZ * sign * offset;
                    
                    wf.position.set(posX, intersectY - wfHeight/2 + 50, posZ); 
                    
                    // Orient perpendicular to the mountain axis
                    const angle = Math.atan2(dz, dx);
                    wf.rotation.y = angle + Math.PI/2;
                    
                    scene.add(wf);
                }
            }
        }

        // --- Ambient Nature Sounds (Wind, Birds, Cicadas) ---
        // 3. Removed Cicadas (High pitch sound) per request

        // 5. Mushrooms (Instanced)
        const mushStemMatInst = new THREE.MeshStandardMaterial({color: 0xFFE0B2});
        const mushCapMatInst = new THREE.MeshStandardMaterial({color: 0xE57373});
        const mushStemGeo = new THREE.CylinderGeometry(0.03, 0.05, 0.15, 8);
        const mushCapGeo = new THREE.SphereGeometry(0.15, 16, 8, 0, Math.PI*2, 0, Math.PI/2);
        
        const mushCount = 10;
        const mushStemMesh = new THREE.InstancedMesh(mushStemGeo, mushStemMatInst, mushCount);
        const mushCapMesh = new THREE.InstancedMesh(mushCapGeo, mushCapMatInst, mushCount);
        scene.add(mushStemMesh); scene.add(mushCapMesh);
        
        let mushIdx = 0;
        const dummyMush = new THREE.Group();
        const dMStem = new THREE.Mesh(mushStemGeo); dMStem.position.y = 0.07; dummyMush.add(dMStem);
        const dMCap = new THREE.Mesh(mushCapGeo); dMCap.position.y = 0.15; dummyMush.add(dMCap);

        for(let i=0; i<mushCount; i++) {
             const x=(Math.random()-0.5)*80, z=(Math.random()-0.5)*80;
             if(Math.abs(x)<5 && Math.abs(z)<5) continue;
             
             dummyMush.position.set(x, 0, z);
             dummyMush.scale.setScalar(0.3 + Math.random()*0.3);
             dummyMush.updateMatrixWorld(true);
             
             mushStemMesh.setMatrixAt(mushIdx, dMStem.matrixWorld);
             mushCapMesh.setMatrixAt(mushIdx, dMCap.matrixWorld);
             mushIdx++;
             mushrooms.push({ position: new THREE.Vector3(x, 0, z) });
        }
        mushStemMesh.count = mushIdx; mushCapMesh.count = mushIdx;
        mushStemMesh.instanceMatrix.needsUpdate = true; mushCapMesh.instanceMatrix.needsUpdate = true;

        // 6. Flowers (Instanced) - REBUILT
        // Hexagonal, Oblique Face, Swaying
        const flowerCount = 300; 
        
        // Geometries
        const stemGeo = new THREE.CylinderGeometry(0.015, 0.015, 1, 6); // Thin stem
        stemGeo.translate(0, 0.5, 0); // Pivot at base
        const headGeo = new THREE.CircleGeometry(0.09, 6); // Hexagon face
        const centerGeo = new THREE.CircleGeometry(0.03, 6); // Hexagon center
        const flowerLeafGeo = new THREE.CircleGeometry(0.08, 4); // Long leaf
        flowerLeafGeo.scale(0.4, 3, 1); 
        flowerLeafGeo.translate(0, 0.15, 0); // Pivot at base
        flowerLeafGeo.rotateX(-0.3); // Tilt out
        
        // Materials
        const stemMat = new THREE.MeshStandardMaterial({color:0x558B2F, roughness:0.8});
        const petalMat = new THREE.MeshBasicMaterial({side: THREE.DoubleSide}); 
        const centerMat = new THREE.MeshBasicMaterial({color:0xFFEB3B});
        const flowerLeafMat = new THREE.MeshStandardMaterial({color:0x558B2F, roughness:0.8, side: THREE.DoubleSide});

        flowerStemMesh = new THREE.InstancedMesh(stemGeo, stemMat, flowerCount);
        flowerPetalMesh = new THREE.InstancedMesh(headGeo, petalMat, flowerCount);
        flowerCenterMesh = new THREE.InstancedMesh(centerGeo, centerMat, flowerCount);
        flowerLeafMesh = new THREE.InstancedMesh(flowerLeafGeo, flowerLeafMat, flowerCount * 2);

        scene.add(flowerStemMesh); scene.add(flowerPetalMesh); scene.add(flowerCenterMesh); scene.add(flowerLeafMesh);
        
        const fColors = [0xFFFFFF, 0xFFC0CB, 0xFF69B4, 0xF48FB1]; 
        const _fColor = new THREE.Color();
        const fDummy = new THREE.Object3D();
        const leafDummy = new THREE.Object3D();
        
        let fIdx = 0;
        let leafIdx = 0;
        
        for(let i=0; i<flowerCount; i++) {
            const x=(Math.random()-0.5)*120, z=(Math.random()-0.5)*120; // Widened
            if(Math.abs(x)<3 && Math.abs(z)<3) continue;
            let nearPond=false; for(let p of ponds){ if(new THREE.Vector3(x,0,z).distanceTo(p.position) < p.radius + 0.5){ nearPond=true; break; } }
            if(nearPond) continue;

            let nearStream = false;
            for(let sData of window.streamCurves) {
                for(let pt of sData.points) {
                    if(new THREE.Vector3(x,0,z).distanceTo(pt) < sData.radius + 0.5) { 
                        nearStream = true; break; 
                    }
                }
                if(nearStream) break;
            }
            if(nearStream) continue;

            const stemH = 0.2 + Math.random()*0.15;
            const colorHex = fColors[Math.floor(Math.random()*fColors.length)];
            
            // Random oblique tilt for the face
            // Tilt angle: 30-60 degrees from vertical (Looking up/diagonal)
            // Geometry faces Z. Rotate X by -90 to face Up (Y).
            // Then tilt back by 30-60 degrees. 
            // Result X rotation: -60 to -30 degrees (-1.05 to -0.52 rad)
            const tiltElevation = -Math.PI/2 + (Math.PI/6 + Math.random() * Math.PI/6);
            const tiltHeading = Math.random() * Math.PI * 2; // Random direction
            
            flowerInstances.push({
                position: new THREE.Vector3(x, 0, z),
                stemH: stemH,
                color: colorHex,
                tiltElevation: tiltElevation,
                tiltHeading: tiltHeading,
                swayPhase: Math.random() * Math.PI * 2
            });
            
            // Initial Placeholders (Will be updated in loop)
            fDummy.position.set(x, 0, z);
            fDummy.updateMatrix();
            flowerStemMesh.setMatrixAt(fIdx, fDummy.matrix);
            
            // Leaves (2 per flower)
            for(let k=0; k<2; k++) {
                leafDummy.position.set(x, 0, z);
                leafDummy.rotation.set(0, Math.random()*Math.PI*2, 0);
                const s = 0.5 + Math.random()*0.5;
                leafDummy.scale.set(s, s, s);
                leafDummy.updateMatrix();
                flowerLeafMesh.setMatrixAt(leafIdx++, leafDummy.matrix);
            }
            
            // Set Color
            _fColor.setHex(colorHex);
            flowerPetalMesh.setColorAt(fIdx, _fColor);
            flowerCenterMesh.setColorAt(fIdx, _fColor); // Center same color? No, yellow usually.
            // Let's keep center yellow but we need to set color if we usedsetColorAt for others?
            // Actually centerMat is fixed yellow.
            
            fIdx++;
        }
        
        flowerStemMesh.count = fIdx;
        flowerPetalMesh.count = fIdx;
        flowerCenterMesh.count = fIdx;
        flowerLeafMesh.count = leafIdx;
        
        flowerStemMesh.instanceMatrix.needsUpdate = true;
        flowerPetalMesh.instanceMatrix.needsUpdate = true;
        flowerCenterMesh.instanceMatrix.needsUpdate = true;
        flowerLeafMesh.instanceMatrix.needsUpdate = true;
        if (flowerPetalMesh.instanceColor) flowerPetalMesh.instanceColor.needsUpdate = true;
        
        // 7. Insects (Butterflies/Bees)
        const insectCount = 40;
        const insectGeo = new THREE.PlaneGeometry(0.12, 0.12);
        const insectMat = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
        window.insectMesh = new THREE.InstancedMesh(insectGeo, insectMat, insectCount);
        scene.add(window.insectMesh);
        
        window.insects = [];
        const insectColors = [0xFFEB3B, 0xFF9800, 0xFFFFFF, 0x4FC3F7]; // Yellow, Orange, White, Blue
        
        const iDummy = new THREE.Object3D();
        for(let i=0; i<insectCount; i++) {
            const color = new THREE.Color(insectColors[Math.floor(Math.random()*insectColors.length)]);
            window.insectMesh.setColorAt(i, color);
            
            // Random start position
            const x = (Math.random()-0.5)*60;
            const z = (Math.random()-0.5)*60;
            const y = 1.0 + Math.random()*2.0;
            
            window.insects.push({
                pos: new THREE.Vector3(x, y, z),
                baseY: y,
                phase: Math.random() * Math.PI * 2,
                speed: 0.5 + Math.random() * 1.0,
                radius: 1.0 + Math.random() * 2.0,
                center: new THREE.Vector3(x, y, z) 
            });
            
            iDummy.position.set(x, y, z);
            iDummy.updateMatrix();
            window.insectMesh.setMatrixAt(i, iDummy.matrix);
        }
        window.insectMesh.instanceMatrix.needsUpdate = true;
        

    }

    createNature();

    // --- å…‰ç…§ & Fog (Cyan-Green Atmosphere) ---
    const hemiLight = new THREE.HemisphereLight(0xE0F2F1, 0x1B5E20, 0.6); scene.add(hemiLight); // Cyan Sky, Green Ground
    const dirLight = new THREE.DirectionalLight(0xFFF176, 1.2); 
    dirLight.position.set(50, 80, 30); dirLight.castShadow = true; 
    dirLight.shadow.mapSize.set(512, 512);
        const d=80; dirLight.shadow.camera.left=-d; dirLight.shadow.camera.right=d; dirLight.shadow.camera.top=d; dirLight.shadow.camera.bottom=-d;
        dirLight.shadow.mapSize.set(512, 512);
    scene.add(dirLight);

    // Fog for "Fading Distance"
    // Fog extended to match new camera far plane for smoother fade
    // Adjusted to hide distant mountains more aggressively (100-900 range)
    scene.fog = new THREE.Fog(0xE0F7FA, 100, 900);
    // scene.background = new THREE.Color(0xE0F7FA); // Replaced by SkyDome

    // --- Sky Gradient (SkyDome) ---
    const skyGeo = new THREE.SphereGeometry(1200, 32, 15);
    const skyMat = new THREE.ShaderMaterial({
        uniforms: {
            topColor: { value: new THREE.Color(0x0077ff) },
            bottomColor: { value: new THREE.Color(0xffffff) },
            offset: { value: 10 },
            exponent: { value: 0.6 }
        },
        vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize( vWorldPosition + vec3(0, offset, 0) ).y;
                gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );
            }
        `,
        side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    window.setWeather = function(type) {
        // Overridden by new static style for now, or adapt
        if(type==='sunny') { 
            scene.background.set(0xE0F7FA); 
            scene.fog.color.set(0xE0F7FA);
            dirLight.color.set(0xFFF176); 
            dirLight.intensity=1.2;
        }
        // ... (other weathers can be adapted later)
    }

    // --- Visual Effects & Time System ---
    let stars, fireflies, petStarlight, petTopLight, dust, rainSystem, spiritParticles;
    const fishes = [];
    const flyingBirds = []; // New flying birds array
    let envCounter = 0;
    
    function createVisualEffects() {
        // 0. Flying Birds (Sky Animation)
        const birdGeo = new THREE.BufferGeometry();
        // V-shape geometry
        const vertices = new Float32Array([
            0.2, 0, 0.1,  // Wing tip L
            0, 0, -0.1,   // Nose
            -0.2, 0, 0.1  // Wing tip R
        ]);
        birdGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        const birdMat = new THREE.MeshBasicMaterial({color: 0xFFFFFF, side: THREE.DoubleSide});
        
        for(let i=0; i<15; i++) {
            const bird = new THREE.Mesh(birdGeo, birdMat);
            // Random start pos high up
            bird.position.set(
                (Math.random()-0.5)*150,
                30 + Math.random()*20,
                (Math.random()-0.5)*150
            );
            bird.userData = {
                velocity: new THREE.Vector3(
                    (Math.random()-0.5)*0.2, 
                    0, 
                    (Math.random()-0.5)*0.2
                ).normalize().multiplyScalar(0.1 + Math.random()*0.1),
                wingSpeed: 0.2 + Math.random()*0.2,
                wingOffset: Math.random() * Math.PI
            };
            scene.add(bird);
            flyingBirds.push(bird);
        }

        // 1. Stars (Night only)
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1500; i++) {
            // Spread stars wider and lower to be visible in camera view
            starPos.push((Math.random()-0.5)*800, 50 + Math.random()*400, (Math.random()-0.5)*800);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xFFFFFF, size: 0.8, transparent: true, opacity: 0, depthWrite: false}));
        scene.add(stars);

        // 2. Fireflies (Night only)
        const fireflyGeo = new THREE.BufferGeometry();
        const fireflyPos = [];
        for(let i=0; i<80; i++) {
            fireflyPos.push((Math.random()-0.5)*120, 6 + Math.random()*14, (Math.random()-0.5)*120);
        }
        fireflyGeo.setAttribute('position', new THREE.Float32BufferAttribute(fireflyPos, 3));
        fireflies = new THREE.Points(fireflyGeo, new THREE.PointsMaterial({
            color: 0xF8F8FF,
            size: 0.09,
            transparent: true,
            opacity: 0,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        }));
        fireflies.geometry.userData.initPos = fireflyPos.slice();
        scene.add(fireflies);

        // petStarlight Removed per user request
        
        petTopLight = new THREE.SpotLight(0xF8F8FF, 0, 15, Math.PI / 7, 0.65, 1.5);
        petTopLight.position.set(0, 7, 0);
        petTopLight.target = corgiGroup;
        scene.add(petTopLight);
        scene.add(petTopLight.target);

        // 3. Floating Dust (Day/Evening)
        const dustGeo = new THREE.BufferGeometry();
        const dustPos = [];
        for(let i=0; i<120; i++) {
            dustPos.push((Math.random()-0.5)*100, Math.random()*10, (Math.random()-0.5)*100);
        }
        dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
        dust = new THREE.Points(dustGeo, new THREE.PointsMaterial({color: 0xFFFFFF, size: 0.06, transparent: true, opacity: 0.6}));
        scene.add(dust);

        // 4. Rain (Occasional Light Rain) - Replaces God Rays
        const rainGeo = new THREE.BufferGeometry();
        const rainPos = [];
        for(let i=0; i<400; i++) { // Reduced from 1200 to 400
            rainPos.push((Math.random()-0.5)*150, Math.random()*100, (Math.random()-0.5)*150);
        }
        rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPos, 3));
        rainSystem = new THREE.Points(rainGeo, new THREE.PointsMaterial({
            color: 0xAAAAAA, 
            size: 0.1, 
            transparent: true, 
            opacity: 0
        }));
        scene.add(rainSystem);

        // 5. Fishes (Jumping)
        const fishGeo = new THREE.SphereGeometry(0.2, 8, 8); // Simple fish body
        const fishMat = new THREE.MeshStandardMaterial({color: 0xFF5722});
        
        ponds.forEach(pond => {
            const fish = new THREE.Group();
            const body = new THREE.Mesh(fishGeo, fishMat);
            body.scale.set(1, 0.4, 0.2);
            fish.add(body);
            
            // Tail
            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.2, 4), fishMat);
            tail.rotation.z = -Math.PI/2;
            tail.position.x = -0.25;
            fish.add(tail);

            fish.visible = false;
            fish.position.copy(pond.position);
            fish.userData = { 
                home: pond.position.clone(), 
                jumping: false, 
                velocity: new THREE.Vector3(),
                timer: 0 
            };
            
            scene.add(fish);
            fishes.push(fish);
        });
    }
    createVisualEffects();

    // --- Time & Environment Control ---
    // Real-time sync
    let gameTime = 0; 
    
    function updateEnvironment(dt) {
        envCounter++;
        // Sync with Real Time
        const now = new Date();
        const currentSeconds = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
        gameTime = currentSeconds / 86400; // 0.0 to 1.0

        // Shift time to match lighting phases
        // Current Phases: 0.0-0.2 (Sunrise), 0.2-0.6 (Day), 0.6-0.75 (Sunset), 0.75-1.0 (Night)
        // Real Time: 0.0 (Midnight). We want Night at Midnight.
        // So we need to map:
        // 6am (0.25) -> Sunrise Start (0.0)
        // 12pm (0.5) -> Day (0.4)
        // 6pm (0.75) -> Sunset Start (0.6)
        // 
        // Let's adjust the phases to match Real Time (0.0 = Midnight)
        // 0.0 - 0.25: Night
        // 0.25 - 0.35: Sunrise (6am-8am)
        // 0.35 - 0.7: Day
        // 0.7 - 0.8: Sunset (5pm-7pm)
        // 0.8 - 1.0: Night
        
        let t = gameTime;
        const hours = now.getHours();
        if(hours >= 17 && hours < 19) {
            t = 0.75; // Ensure sunset lighting at local 18:00
        }
        const isNight = (t < 0.25 || t >= 0.8);
        
        // Light Colors
        let skyTop, skyBottom, groundColor, sunColor, sunIntensity, fogColor;
        
        if(t >= 0.25 && t < 0.35) { // Sunrise (6am-8am)
            const p = (t-0.25)/0.1;
            skyBottom = new THREE.Color().lerpColors(new THREE.Color(0x1A237E), new THREE.Color(0xFFCC80), p);
            skyTop = new THREE.Color().lerpColors(new THREE.Color(0x000000), new THREE.Color(0x42A5F5), p);
            
            groundColor = new THREE.Color(0x81C784);
            sunColor = new THREE.Color(0xFFE0B2);
            sunIntensity = 0.3 + p*0.7;
            fogColor = skyBottom;
            if(stars) stars.material.opacity = 1 - p;
        } else if(t >= 0.35 && t < 0.7) { // Day (8am-5pm)
            skyBottom = new THREE.Color(0xE0F7FA);
            skyTop = new THREE.Color(0x4FC3F7); // Nice Sky Blue
            
            groundColor = new THREE.Color(0x1B5E20);
            sunColor = new THREE.Color(0xFFC107); // Golden Light
            sunIntensity = 1.3;
            fogColor = skyBottom;
            if(stars) stars.material.opacity = 0;
        } else if(t >= 0.7 && t < 0.8) { // Sunset (5pm-7pm)
            const p = (t-0.7)/0.1;
            // Horizon: Orange -> Deep Purple-Red (0x880E4F)
            skyBottom = new THREE.Color().lerpColors(new THREE.Color(0xFF9800), new THREE.Color(0x880E4F), p);
            // Top: Sky Blue -> Gold (0xFFD700)
            skyTop = new THREE.Color().lerpColors(new THREE.Color(0x4FC3F7), new THREE.Color(0xFFD700), p);
            
            groundColor = new THREE.Color(0x33691E);
            
            // Light: Orange -> Gold (Refracted Light)
            sunColor = new THREE.Color().lerpColors(new THREE.Color(0xFF9800), new THREE.Color(0xFFD700), p); 
            sunIntensity = 1.2; 
            
            // Fog: Match sky for seamless horizon
            fogColor = skyBottom;
            
            if(stars) stars.material.opacity = p;
        } else { // Night (7pm-6am)
            skyBottom = new THREE.Color(0x000000);
            skyTop = new THREE.Color(0x0D1B2A);

            groundColor = new THREE.Color(0x000000);
            sunColor = new THREE.Color(0x5C6BC0); // Moon
            sunIntensity = 0.2;
            fogColor = skyBottom;
            if(stars) stars.material.opacity = 0.9; // High visibility
        }

        // Apply Gradient
        if(skyMat) {
            skyMat.uniforms.topColor.value.copy(skyTop);
            skyMat.uniforms.bottomColor.value.copy(skyBottom);
        }

        hemiLight.color.copy(skyTop);
        // hemiLight.groundColor.copy(groundColor); 
        
        dirLight.color.copy(sunColor);
        dirLight.intensity = sunIntensity;
        scene.fog.color.copy(fogColor);
        // scene.background.copy(fogColor); // Handled by SkyDome

        // Fireflies (Only at night)
        if(fireflies) {
             fireflies.material.opacity = isNight ? 1 : 0;
             if(fireflies.material.opacity > 0 && envCounter % 6 === 0) { // Reduced update frequency
                 const time = Date.now() * 0.001;
                 const pos = fireflies.geometry.attributes.position;
                 const init = fireflies.geometry.userData.initPos;
                 for(let i=0; i<pos.count; i++) {
                     pos.setY(i, init[i*3+1] + Math.sin(time*2 + i)*0.5);
                     pos.setX(i, init[i*3] + Math.sin(time*0.5 + i)*0.5);
                 }
                 pos.needsUpdate = true;
             }
        }

        if(petStarlight) {
            petStarlight.material.opacity = isNight ? 0.95 : 0;
            if(isNight && envCounter % 2 === 0) {
                const pos = petStarlight.geometry.attributes.position;
                for(let i=0; i<pos.count; i++) {
                    let y = pos.getY(i);
                    y -= dt * 1.6;
                    if(y < 0.15) {
                        y = 3.6;
                        pos.setX(i, (Math.random() - 0.5) * 1.2);
                        pos.setZ(i, (Math.random() - 0.5) * 1.2);
                    }
                    pos.setY(i, y);
                }
                pos.needsUpdate = true;
            }
        }

        if(petTopLight) {
            petTopLight.intensity = isNight ? 0.9 : 0;
            petTopLight.position.set(dogPos.x, dogPos.y + 7.5, dogPos.z);
        }
        
        // Dust (Always visible but subtle)
        if(dust && envCounter % 5 === 0) { // Reduced update frequency
            const pos = dust.geometry.attributes.position;
            for(let i=0; i<pos.count; i++) {
                let y = pos.getY(i);
                y -= dt * 0.5; // Fall slowly
                if(y < 0) y = 10;
                pos.setY(i, y);
            }
            pos.needsUpdate = true;
        }
        
        // Rain (Occasional Light Rain)
        if(rainSystem && envCounter % 4 === 0) { // Reduced update frequency
             const pos = rainSystem.geometry.attributes.position;
             for(let i=0; i<pos.count; i++) {
                 let y = pos.getY(i);
                 y -= dt * 20; // Fast fall
                 if(y < 0) y = 100;
                 pos.setY(i, y);
             }
             pos.needsUpdate = true;
             
             // Simple weather cycle: Rain every 30s for 10s?
             // For now, just keep it light and constant for atmosphere
             rainSystem.material.opacity = 0.2; 
        }

        // Update Spiritual Particles (Reiki)
        if(spiritParticles) {
            const pos = spiritParticles.geometry.attributes.position;
            for(let i=0; i<pos.count; i++) {
                let y = pos.getY(i);
                y += dt * 1.5; // Rise slowly
                if(y > 40) {
                    y = 0;
                    pos.setX(i, (Math.random()-0.5)*150);
                    pos.setZ(i, (Math.random()-0.5)*150);
                }
                pos.setY(i, y);
            }
            pos.needsUpdate = true;
            
            // Update Color for "Golden Refraction" in evening
            const targetColor = (t >= 0.7 && t < 0.8) ? new THREE.Color(0xFFD700) : new THREE.Color(0xE0F7FA);
            spiritParticles.material.color.lerp(targetColor, 0.05);
        }

        // Update Flying Birds
        if(flyingBirds.length > 0) {
            const time = Date.now() * 0.005;
            flyingBirds.forEach(bird => {
                // Move
                bird.position.add(bird.userData.velocity);
                
                // Wrap around
                if(bird.position.x > 80) bird.position.x = -80;
                if(bird.position.x < -80) bird.position.x = 80;
                if(bird.position.z > 80) bird.position.z = -80;
                if(bird.position.z < -80) bird.position.z = 80;

                // Flap wings (Scale Y)
                bird.scale.y = Math.sin(time * bird.userData.wingSpeed + bird.userData.wingOffset) * 0.5 + 0.5;
                // Bank turn slightly based on velocity
                bird.rotation.z = Math.sin(time * 0.5) * 0.2;
                // Look forward
                bird.lookAt(bird.position.clone().add(bird.userData.velocity));
            });
        }

        // Swaying Flowers (Wind Effect) - REBUILT
        if(flowerInstances.length > 0 && envCounter % 2 === 0) {
             const time = Date.now() * 0.003; // Faster wind
             const windStrength = 0.15; 
             
             const fDummy = new THREE.Object3D(); 
             const up = new THREE.Vector3(0, 1, 0);
             
             for(let i=0; i<flowerStemMesh.count; i++) {
                 const data = flowerInstances[i];
                 
                 // Wind Sway
                 const swayX = Math.sin(time + data.position.x * 0.5 + data.swayPhase) * windStrength;
                 const swayZ = Math.cos(time + data.position.z * 0.5 + data.swayPhase) * windStrength;
                 
                 // 1. Update Stem
                 fDummy.position.copy(data.position);
                 // fDummy.position.y = data.stemH / 2; // Removed: Pivot is now at base
                 fDummy.scale.set(1, data.stemH, 1);
                 fDummy.rotation.set(swayX, 0, swayZ); 
                 fDummy.updateMatrix();
                 flowerStemMesh.setMatrixAt(i, fDummy.matrix);
                 
                 // 2. Calculate Tip Position
                 // Pivot is at base (0), so top is at (0, stemH, 0)
                 const tipPos = new THREE.Vector3(0, data.stemH, 0);
                 tipPos.applyEuler(new THREE.Euler(swayX, 0, swayZ));
                 tipPos.add(data.position); 
                 
                 // 3. Update Head (Petals)
                 // Oblique Face: Combine sway rotation + initial tilt
                 // We want the flower to face roughly "up" but tilted, and rotate with the stem
                 fDummy.position.copy(tipPos);
                 fDummy.scale.set(1, 1, 1);
                 
                 // Apply rotation: Heading (Y) -> Elevation (X) -> Sway (Z/X perturbation)
                 // Use YXZ order to decouple Heading from Tilt
                 fDummy.rotation.set(data.tiltElevation + swayX, data.tiltHeading, swayZ, 'YXZ');
                 
                 fDummy.updateMatrix();
                 flowerPetalMesh.setMatrixAt(i, fDummy.matrix);
                 
                 // 4. Update Center (Same rotation, slightly higher to prevent Z-fighting)
                 // Offset along LOCAL Z (Normal) because CircleGeometry faces Z
                 const centerOffset = new THREE.Vector3(0, 0, 0.005);
                 centerOffset.applyEuler(fDummy.rotation);
                 fDummy.position.add(centerOffset);
                 fDummy.updateMatrix();
                 flowerCenterMesh.setMatrixAt(i, fDummy.matrix);
             }
             flowerStemMesh.instanceMatrix.needsUpdate = true;
             flowerPetalMesh.instanceMatrix.needsUpdate = true;
             flowerCenterMesh.instanceMatrix.needsUpdate = true;
        }

        // Flower Sway (Logic merged into Swaying Flowers section above)
        /*
        if(flowerInstances && flowerInstances.length) {
             // ...
        }
        */

        // Fish Jumping
        fishes.forEach(fish => {
            if(fish.userData.jumping) {
                // Physics
                fish.position.add(fish.userData.velocity.clone().multiplyScalar(dt));
                fish.userData.velocity.y -= 9.8 * dt; // Gravity
                
                // Rotate
                fish.rotation.z -= 2 * dt;

                if(fish.position.y < 0) {
                    fish.userData.jumping = false;
                    fish.visible = false;
                    fish.position.copy(fish.userData.home);
                }
            } else {
                // Random jump
                if(Math.random() < 0.002) { // Low chance per frame
                    fish.userData.jumping = true;
                    fish.visible = true;
                    fish.position.copy(fish.userData.home);
                    fish.userData.velocity.set((Math.random()-0.5)*2, 4, (Math.random()-0.5)*2);
                    fish.rotation.z = Math.PI/4;
                }
            }
        });
    }

    // --- åŠ¨ç”»å¾ªç¯ ---
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const dt = clock.getDelta();
        const ownerIdle = (time - lastOwnerInteractionTime) > OWNER_IDLE_THRESHOLD;

        if(window.streamFlowTex) {
            window.streamFlowTex.offset.x = (time * 0.06) % 1;
        }

        updateEnvironment(dt);
        if(window.waterfallUniforms) {
            window.waterfallUniforms.time.value = time;
        }

        if(window.lakeMesh && window.lakeCubeCamera) {
            window.lakeUpdateTick = (window.lakeUpdateTick || 0) + 1;
            if(window.lakeUpdateTick % 8 === 0) {
                window.lakeMesh.visible = false;
                window.lakeCubeCamera.update(renderer, scene);
                window.lakeMesh.visible = true;
            }
        }

        // æ›´æ–°è‡ªä¸»è¡Œä¸º
        updatePetBehavior(time);

        // Animate Insects
        if(window.insectMesh && window.insects) {
            const iTime = time * 2.0;
            const iDummy = new THREE.Object3D();
            
            window.insects.forEach((ins, i) => {
                // Circular motion with vertical bobbing
                const angle = ins.phase + iTime * ins.speed * 0.5;
                const x = ins.center.x + Math.cos(angle) * ins.radius;
                const z = ins.center.z + Math.sin(angle) * ins.radius;
                const y = ins.baseY + Math.sin(angle * 2.0) * 0.5;
                
                iDummy.position.set(x, y, z);
                
                // Orient towards movement direction
                const nextX = ins.center.x + Math.cos(angle + 0.1) * ins.radius;
                const nextZ = ins.center.z + Math.sin(angle + 0.1) * ins.radius;
                iDummy.lookAt(nextX, y, nextZ);
                
                // Flapping wings (Scale X)
                iDummy.scale.set(Math.abs(Math.sin(time * 15.0)), 1, 1);
                
                iDummy.updateMatrix();
                window.insectMesh.setMatrixAt(i, iDummy.matrix);
            });
            window.insectMesh.instanceMatrix.needsUpdate = true;
        }

        const forcedSleep = isForcedSleepTime();
        if (forcedSleep && currentState !== STATE.BUSY) {
            if (currentState !== STATE.SLEEP) {
                currentState = STATE.SLEEP;
                if (targetRing) targetRing.visible = false;
                runStateStart = 0; lastRunDist = Infinity; lastDistDecreaseTime = 0;
            }
            if (time - lastSleepNoticeTime > 240) {
                showThought("Zzz...");
                lastSleepNoticeTime = time;
            }
        }

        if (!forcedSleep && ownerIdle && currentState === STATE.IDLE) {
            if (time - lastAttentionTime > 22) {
                const camPos = camera.position.clone();
                camPos.y = corgiGroup.position.y;
                const dx = camPos.x - corgiGroup.position.x;
                const dz = camPos.z - corgiGroup.position.z;
                setPetYaw(Math.atan2(dx, dz));
                if (currentPet === 'corgi') showThought("(ä½ è¿˜åœ¨å—...)");
                else if (currentPet === 'cat') showThought("(ç›¯ç€ä½ ...)");
                else showThought("(æŠ–æŠ–è€³æœµçœ‹ä½ ...)");
                headGroup.rotation.z = (Math.random() < 0.5 ? 1 : -1) * 0.18;
                setTimeout(()=> headGroup.rotation.z = 0, 900);
                lastAttentionTime = time;
            }
        }

        if (currentState === STATE.SLEEP) {
            applySleepPose(dt);
        } else if(currentState === STATE.RUN) {
            const dtRun = Math.min(dt, 0.05);
            const toTarget = targetPos.clone().sub(dogPos);
            const dist = toTarget.length();
            
            // Stop if close enough (prevents spinning)
            // Reduced threshold from 0.3 to 0.05 to make it reach the exact center
            if (dist < 0.05) {
                currentState = STATE.IDLE; 
                if(targetRing) targetRing.visible = false; // Hide ring on arrival
                legs.forEach(l => { 
                    l.rotation.x = 0; 
                    if(currentPet === 'rabbit') l.position.y = 0.28;
                    else if(currentPet === 'corgi') l.position.y = 0.38;
                    else l.position.y = 0.2; // Cat
                }); 
                corgiBody.position.y=0;
                corgiBody.rotation.z=0;
                if(tail) { 
                    tail.rotation.y=0; 
                    tail.rotation.z=0;
                    if(currentPet === 'cat') tail.rotation.x = 0.2;
                    else tail.rotation.x = 0;
                }
                runStateStart = 0; lastRunDist = Infinity; lastDistDecreaseTime = 0;
                return;
            }

            const desiredDir = toTarget.clone().normalize();
            const targetYaw = Math.atan2(desiredDir.x, desiredDir.z);
            const yawDelta = rotatePetTowardsYaw(targetYaw, BASE_TURN_SPEED * dtRun);
            const absYawDelta = Math.abs(yawDelta);

            let currentSpeed = window.moveSpeed || BASE_MOVE_SPEED;
            if(currentPet === 'rabbit') currentSpeed *= 0.85;
            else if(currentPet === 'cat') currentSpeed *= 0.9;
            else currentSpeed *= 1.2;

            if(runStateStart === 0){
                runStateStart = time;
                lastRunDist = dist;
                lastDistDecreaseTime = time;
            } else {
                if(dist < lastRunDist - 0.01){
                    lastDistDecreaseTime = time;
                }
                lastRunDist = dist;
            }

            const shouldMove = absYawDelta < 0.35;

            if(!shouldMove) {
                const turnPhase = time * 15;
                legs.forEach((leg, i) => {
                   leg.rotation.x = Math.sin(turnPhase + (i % 2 === 0 ? 0 : Math.PI)) * 0.3;
                });
            } else {
                const forward = new THREE.Vector3(Math.sin(petYaw), 0, Math.cos(petYaw));
                const stepLen = Math.min(dist, currentSpeed * dtRun);
                const nextPos = dogPos.clone().add(forward.multiplyScalar(stepLen));
                
                // Extra check: if step would overshoot destination (very close)
                if(nextPos.distanceTo(targetPos) < 0.05) {
                    currentState = STATE.IDLE;
                    if(targetRing) targetRing.visible = false;
                    legs.forEach(l => { 
                        l.rotation.x = 0; 
                        if(currentPet === 'rabbit') l.position.y = 0.28;
                        else if(currentPet === 'corgi') l.position.y = 0.38;
                        else l.position.y = 0.2; 
                    }); 
                    corgiBody.position.y=0;
                    corgiBody.rotation.z=0;
                    runStateStart = 0; lastRunDist = Infinity; lastDistDecreaseTime = 0;
                    dogPos.copy(targetPos); // Snap to target
                } else {
                    // Collision (Trees & Ponds)
                    let collision = false;
                    for(let tree of trees) {
                        const dx = nextPos.x - tree.position.x;
                        const dz = nextPos.z - tree.position.z;
                        if(Math.abs(dx) > 2.5 || Math.abs(dz) > 2.5) continue;
                        if(dx*dx + dz*dz < (tree.radius + 0.2)*(tree.radius + 0.2)) {
                            collision = true; break;
                        }
                    }
                    if(!collision) {
                        for(let pond of ponds) {
                            if(nextPos.distanceTo(pond.position) < pond.radius + 0.8) {
                                collision = true; break;
                            }
                        }
                    }

                    if(!collision && nextPos.length() > WORLD_RADIUS) {
                        collision = true;
                    }

                    if (collision) {
                        currentState = STATE.IDLE;
                        showThought("(è¿‡ä¸å»...)");
                        targetRing.visible = false;
                        
                        legs.forEach(l => { 
                            l.rotation.x = 0; 
                            if(currentPet === 'rabbit') l.position.y = 0.28;
                            else if(currentPet === 'corgi') l.position.y = 0.38;
                            else l.position.y = 0.2; 
                        }); 
                        corgiBody.position.y=0;
                        corgiBody.rotation.z=0;
                        if(tail) { 
                            tail.rotation.y=0; 
                            tail.rotation.z=0;
                            if(currentPet === 'cat') tail.rotation.x = 0.2;
                            else tail.rotation.x = 0;
                        }
                        if(headGroup) headGroup.rotation.x = 0;

                        const bounce = dogPos.clone().sub(nextPos).normalize().multiplyScalar(0.5);
                        dogPos.add(bounce);
                    } else {
                        dogPos.copy(nextPos);
                        
                        // --- ä¸“å±è¡Œèµ°åŠ¨ç”» ---
                        if(currentPet === 'rabbit') {
                            const hopPhase = time * 15;
                            corgiBody.position.y = Math.abs(Math.sin(hopPhase)) * 0.25; 
                            if(corgiGroup.userData.ears) {
                                 const earRot = -Math.abs(Math.sin(hopPhase)) * 0.5;
                                 corgiGroup.userData.ears.forEach(e => e.rotation.x = earRot);
                            }
                        } else if(currentPet === 'cat') {
                            const walkPhase = time * 10;
                            const stepAmp = 0.5;
                            
                            corgiBody.rotation.z = Math.sin(walkPhase) * 0.05;
                            corgiBody.position.y = Math.abs(Math.sin(walkPhase*2)) * 0.03;

                            legs.forEach((leg, i) => {
                                const legPhase = (i === 0 || i === 3) ? 0 : Math.PI;
                                leg.rotation.x = Math.sin(walkPhase + legPhase) * stepAmp;
                                const lift = Math.max(0, Math.sin(walkPhase + legPhase));
                                leg.position.y = 0.2 + (lift * 0.1);
                            });

                            if(tail) {
                                tail.rotation.y = Math.sin(walkPhase * 0.5) * 0.2;
                                tail.rotation.x = 0.2 + Math.cos(walkPhase) * 0.05;
                            }

                        } else {
                            const moveSpeed = window.moveSpeed || BASE_MOVE_SPEED;
                            const speedRatio = BASE_MOVE_SPEED > 0 ? (moveSpeed / BASE_MOVE_SPEED) : 1;
                            const isRunning = speedRatio > 2.0;

                            const phaseRate = isRunning ? 28 : 14;
                            const phase = time * phaseRate;
                            const legAmp = isRunning ? 1.15 : 0.65;
                            const bodyBounce = isRunning ? 0.09 : 0.04;
                            const bodyRoll = isRunning ? 0.18 : 0.08;

                            legs.forEach((leg, i) => {
                                leg.rotation.x = Math.sin(phase + (i%2===0?0:Math.PI)) * legAmp;
                            });
                            corgiBody.position.y = Math.abs(Math.sin(phase)) * bodyBounce;
                            corgiBody.rotation.z = Math.sin(phase * 0.5) * bodyRoll;
                            headGroup.rotation.x = 0.1 + Math.abs(Math.sin(phase))* (isRunning ? 0.08 : 0.04);
                            if(tail) {
                                tail.rotation.y = Math.sin(phase * 0.7) * (isRunning ? 1.0 : 0.45); 
                                tail.rotation.z = Math.sin(phase * 1.1) * (isRunning ? 0.35 : 0.15);
                            }
                            // Ear Sway for Corgi
                            if(corgiGroup.userData.ears) {
                                corgiGroup.userData.ears.forEach((e, i) => {
                                    // Ears: Minimal sway (User request: "è€³æœµä¸ç”¨å¤ªæ‘‡æ™ƒ")
                                    e.rotation.z = Math.sin(phase + (i===0?0:Math.PI)) * 0.02; 
                                    e.rotation.x = -0.4 + Math.abs(Math.sin(phase)) * 0.02; // Tiny bounce
                                });
                            }
                        }
                    }
                }
            }
        } else {
            // Idle State Logic - Short Range Exploration
            // Reset Pose Guard (Force exact reset if close enough)
            if(legs && legs.length > 0) {
                 legs.forEach(l => {
                     // Force reset legs if they are still moving or not aligned
                     if(Math.abs(l.rotation.x) > 0.001) {
                         l.rotation.x *= 0.8; // Faster decay
                     } else {
                         l.rotation.x = 0;
                     }
                     
                     // Reset height
                     let targetY = 0;
                     if(currentPet === 'rabbit') targetY = 0.28;
                     else if(currentPet === 'corgi') targetY = 0.32;
                     else targetY = 0.2; // Cat
                     
                     if(Math.abs(l.position.y - targetY) > 0.001) {
                         l.position.y = THREE.MathUtils.lerp(l.position.y, targetY, 0.2);
                     } else {
                         l.position.y = targetY;
                     }
                 });
            }
            if(Math.abs(corgiBody.position.y) > 0.001) corgiBody.position.y *= 0.8;
            else corgiBody.position.y = 0;
            if(Math.abs(corgiBody.rotation.z) > 0.001) corgiBody.rotation.z *= 0.8;
            else corgiBody.rotation.z = 0;
            
            if(Math.abs(corgiBody.rotation.x) > 0.001) corgiBody.rotation.x *= 0.8;
            else corgiBody.rotation.x = 0;
            if(headGroup && Math.abs(headGroup.rotation.x) > 0.001) headGroup.rotation.x *= 0.8;
            else if(headGroup) headGroup.rotation.x = 0;

            corgiBody.scale.y = 1;
            if(tail) {
                if(currentPet === 'corgi') tail.rotation.y = Math.sin(time*5) * 0.15;
                else tail.rotation.z = Math.sin(time*5)*0.2;
            }
            
            // Ear Wiggle (Idle)
            if(corgiGroup.userData.ears && Math.random() < 0.02) {
                corgiGroup.userData.ears.forEach(ear => {
                     ear.rotation.z += (Math.random()-0.5)*0.2; 
                     setTimeout(()=> ear.rotation.z = 0, 200); 
                });
            }
        }

        corgiGroup.position.copy(dogPos);
        if(corgiBody.position.y < 0) corgiBody.position.y = 0;
        
        // ç›¸æœºè·Ÿéš (Only when moving or busy)
        // Improved logic: Pan camera WITH the target to preserve viewing angle/height
        // This prevents the camera from moving directly overhead when the pet moves
        if (currentState !== STATE.IDLE) {
            const desiredTarget = dogPos.clone().add(new THREE.Vector3(0, 0.6, 0));
            
            // Calculate how much the target moves this frame (smoothly)
            const oldTarget = controls.target.clone();
            // Use a lower lerp factor for smoother camera movement
            const newTarget = oldTarget.clone().lerp(desiredTarget, 0.1); 
            const delta = newTarget.clone().sub(oldTarget);
            
            // Apply same translation to camera position to maintain relative view
            camera.position.add(delta);
            controls.target.copy(newTarget);
            
            // Distance Constraints (Soft limits)
            const camDist = camera.position.distanceTo(controls.target);
            let minCamDist = 2.5; // Increased to ensure we don't get too close (overhead)
            let maxCamDist = 5.0; // Allow seeing more context
            
            // äº¤äº’æ—¶æ‹‰è¿‘é•œå¤´ (Adjusted for +0.5 distance)
            if (currentState === STATE.BUSY) {
                minCamDist = 2.0;
                maxCamDist = 3.5;
            }
            
            // Only adjust if out of bounds, and do it gently
            if(camDist < minCamDist) {
                 const dir = camera.position.clone().sub(controls.target).normalize();
                 camera.position.lerp(controls.target.clone().add(dir.multiplyScalar(minCamDist)), 0.1);
            } else if(camDist > maxCamDist) {
                 const dir = camera.position.clone().sub(controls.target).normalize();
                 camera.position.lerp(controls.target.clone().add(dir.multiplyScalar(maxCamDist)), 0.1);
            }
        }
        
        // Limit Camera Height (Tree top max) - Keep this constraint always active for safety
        if (camera.position.y > maxTrunkTop) camera.position.y = maxTrunkTop;
        if (camera.position.y < 0.5) camera.position.y = 0.5;

        // Limit Camera Angle (Pitch)
        controls.minPolarAngle = 0.1; // Don't look from directly above/below
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Don't go below ground
        
        {
            let nearest=null, minD=Infinity;
            for(let i=0;i<ponds.length;i++){
                const p=ponds[i];
                const d=controls.target.distanceTo(p.position);
                if(d<minD){minD=d;nearest=p;}
            }
            if(nearest){
                const angleToPond=Math.atan2(nearest.position.x - controls.target.x, nearest.position.z - controls.target.z);
                if(typeof controls.getAzimuthalAngle==='function' && typeof controls.rotateLeft==='function'){
                    let az=controls.getAzimuthalAngle();
                    let diff=angleToPond - az;
                    while(diff>Math.PI) diff-=Math.PI*2;
                    while(diff<-Math.PI) diff+=Math.PI*2;
                    const avoid=0.25;
                    if(Math.abs(diff)<avoid){
                        controls.rotateLeft(Math.sign(diff)*(avoid - Math.abs(diff)));
                    }
                }
                const camVec=new THREE.Vector3(camera.position.x - nearest.position.x, 0, camera.position.z - nearest.position.z);
                const distCam=camVec.length();
                const minDist=nearest.radius + 1.2;
                if(distCam<minDist){
                    camVec.normalize().multiplyScalar(minDist);
                    camera.position.x = nearest.position.x + camVec.x;
                    camera.position.z = nearest.position.z + camVec.z;
                }
            }
        }
        controls.update();

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    }
    window.initThreeScene = initThreeScene;
    if (window.THREE) { initThreeScene(); }
</script>
</body>
</html>
